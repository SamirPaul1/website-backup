{
    "version": "https://jsonfeed.org/version/1",
    "title": "Samir Paul • All posts by \"short-url\" tag",
    "description": "Software Engineer",
    "home_page_url": "https://samirpaul1.github.io",
    "items": [
        {
            "id": "https://samirpaul1.github.io/posts/url-shortening-service/",
            "url": "https://samirpaul1.github.io/posts/url-shortening-service/",
            "title": "URL Shortening Service",
            "date_published": "2023-08-05T20:52:53.888Z",
            "content_html": "<h1 id=\"URL-Shortening-Service\"><a href=\"#URL-Shortening-Service\" class=\"headerlink\" title=\"URL Shortening Service\"></a>URL Shortening Service</h1><h2 id=\"Summary\"><a href=\"#Summary\" class=\"headerlink\" title=\"Summary\"></a>Summary</h2><p><img src=\"https://raw.githubusercontent.com/SamirPaulb/assets/main/blog/system-design/short-url-overview.png\" alt=\"overview\"><br><img src=\"https://raw.githubusercontent.com/SamirPaulb/assets/main/blog/system-design/short-url-detail.png\" alt=\"summary\"></p>\n<h2 id=\"Requirements\"><a href=\"#Requirements\" class=\"headerlink\" title=\"Requirements\"></a>Requirements</h2><ul>\n<li><p>Functional Requirements</p>\n<ul>\n<li>Given a URL, generate a shorter and unique alias (short link).</li>\n<li>When users access a short link, redirect to the original link.</li>\n<li>Users should optionally be able to pick a custom short link for their URL.</li>\n<li>Links will expire after a standard default timespan. Users should also be able to specify the expiration time.</li>\n</ul>\n</li>\n<li><p>Non-Functional Requirements</p>\n<ul>\n<li>The system should be highly available. This is required because, if our service is down, all the URL redirections will start failing.</li>\n<li>URL redirection should happen in real-time with minimal latency.</li>\n<li>Shortened links should not be guessable (not predictable).</li>\n</ul>\n</li>\n<li><p>Extended Requirements</p>\n<ul>\n<li>Analytics; e.g., how many times a redirection happened?</li>\n<li>Be accessible through REST APIs by other services.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Capacity-Estimation-and-Constraints\"><a href=\"#Capacity-Estimation-and-Constraints\" class=\"headerlink\" title=\"Capacity Estimation and Constraints\"></a>Capacity Estimation and Constraints</h2><ul>\n<li><p>Assumption</p>\n<ul>\n<li>Read-heavy. More redirection requests compared to new URL shortenings.</li>\n<li>Assume <strong>100:1</strong> ratio between read and write.</li>\n</ul>\n</li>\n<li><p>Traffic estimates</p>\n<ul>\n<li><strong>500M</strong> new URL shortenings per month, 100 * 500M &#x3D;&gt; 50B redirections per month.</li>\n<li>New URL shortenings per second<ul>\n<li>500 million &#x2F; (30 days * 24 hours * 3600 seconds) &#x3D; <strong>~200 URLs&#x2F;s</strong></li>\n</ul>\n</li>\n<li>URLs redirections per second<ul>\n<li>50 billion &#x2F; (30 days * 24 hours * 3600 sec) &#x3D; <strong>~19K&#x2F;s</strong></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>Storage estimates</p>\n<ul>\n<li>Assume storing every URL shortening request for 5 years, each object takes <strong>500 bytes</strong></li>\n<li>Total objects: 500 million * 5 years * 12 months &#x3D; <strong>30 billion</strong></li>\n<li>Total storage: 30 billion * 500 bytes &#x3D; <strong>15 TB</strong></li>\n</ul>\n</li>\n<li><p>Bandwidth estimates</p>\n<ul>\n<li>Write: 200 URL&#x2F;s * 500 bytes&#x2F;URL &#x3D; <strong>100 KB&#x2F;s</strong></li>\n<li>Read: 19K URL&#x2F;s * 500 bytes&#x2F;URL &#x3D; <strong>~9 MB&#x2F;s</strong></li>\n</ul>\n</li>\n<li><p>Cache memory estimates</p>\n<ul>\n<li>Follow the 80-20 rule, assuming 20% of URLs generate 80% of traffic, cache 20% hot URLs</li>\n<li>Requests per day: 19K * 3600 seconds * 24 hours &#x3D; <strong>~1.7 billion&#x2F;day</strong></li>\n<li>Cache 20%: 0.2 * 1.7 billion * 500 bytes &#x3D; <strong>~170GB</strong></li>\n</ul>\n</li>\n<li><p>Summary</p>\n<ul>\n<li>Assuming 500 million new URLs per month and 100:1 read:write ratio</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>Category</th>\n<th>Calculation</th>\n<th>Estimate</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>New URLs</td>\n<td>500 million &#x2F; (30 days * 24 hours * 3600 seconds)</td>\n<td>200 &#x2F;s</td>\n</tr>\n<tr>\n<td>URL redirections</td>\n<td>500 million * 100 &#x2F; (30 days * 24 hours * 3600 seconds)</td>\n<td>19 K&#x2F;s</td>\n</tr>\n<tr>\n<td>Incoming data</td>\n<td>500 bytes&#x2F;URL * 200 URL&#x2F;s</td>\n<td>100 KB&#x2F;s</td>\n</tr>\n<tr>\n<td>Outgoing data</td>\n<td>500 bytes&#x2F;URL * 19K URL&#x2F;s</td>\n<td>9 MB&#x2F;s</td>\n</tr>\n<tr>\n<td>Storage for 5 years</td>\n<td>500 bytes&#x2F;URL * 500 million * 60 months</td>\n<td>15 TB</td>\n</tr>\n<tr>\n<td>Memory for cache</td>\n<td>19K URL * 3600 seconds * 24 hours * 500 bytes * 20%</td>\n<td>170 GB</td>\n</tr>\n</tbody></table>\n</li>\n</ul>\n<h2 id=\"System-APIs\"><a href=\"#System-APIs\" class=\"headerlink\" title=\"System APIs\"></a>System APIs</h2><h3 id=\"createUrl\"><a href=\"#createUrl\" class=\"headerlink\" title=\"createUrl\"></a><code>createUrl</code></h3><ul>\n<li>Parameters<table>\n<thead>\n<tr>\n<th>Name</th>\n<th>Type</th>\n<th>Note</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>api_dev_key</code></td>\n<td><code>string</code></td>\n<td>The API developer key of a registered account. This will be used to, among other things, throttle users based on their allocated quota.</td>\n</tr>\n<tr>\n<td><code>original_url</code></td>\n<td><code>string</code></td>\n<td>Original URL to be shortened.</td>\n</tr>\n<tr>\n<td><code>custom_alias</code></td>\n<td><code>string</code></td>\n<td>Optional custom key for the URL.</td>\n</tr>\n<tr>\n<td><code>user_name</code></td>\n<td><code>string</code></td>\n<td>Optional user name to be used in encoding.</td>\n</tr>\n<tr>\n<td><code>expire_date</code></td>\n<td><code>string</code></td>\n<td>Optional expiration date for the shortened URL.</td>\n</tr>\n</tbody></table>\n</li>\n<li>Return<ul>\n<li><code>string</code></li>\n<li>A successful insertion returns the shortened URL; otherwise, it returns an error code.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"deleteUrl\"><a href=\"#deleteUrl\" class=\"headerlink\" title=\"deleteUrl\"></a><code>deleteUrl</code></h3><ul>\n<li>Parameters<table>\n<thead>\n<tr>\n<th>Name</th>\n<th>Type</th>\n<th>Note</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>api_dev_key</code></td>\n<td><code>string</code></td>\n<td>The API developer key of a registered account. This will be used to, among other things, throttle users based on their allocated quota.</td>\n</tr>\n<tr>\n<td><code>url_key</code></td>\n<td><code>string</code></td>\n<td>Short URL.</td>\n</tr>\n</tbody></table>\n</li>\n<li>Return<ul>\n<li><code>string</code></li>\n<li>A successful deletion returns ‘URL Removed’.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Database-design\"><a href=\"#Database-design\" class=\"headerlink\" title=\"Database design\"></a>Database design</h2><ul>\n<li><p>Observations</p>\n<ul>\n<li>Need to store billions of records.</li>\n<li>Each object is small (less than 1K).</li>\n<li>No relationships between records—other than storing which user created a URL.</li>\n<li>Read-heavy.</li>\n<li>A NoSQL choice would also be easier to scale.</li>\n<li>Comment: SQL with sharding should also work</li>\n</ul>\n</li>\n<li><p>Schema</p>\n<ul>\n<li>URL<table>\n<thead>\n<tr>\n<th>Column</th>\n<th>Type</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>hash</code></td>\n<td>varchar(16)</td>\n</tr>\n<tr>\n<td><code>original_url</code></td>\n<td>varchar(512)</td>\n</tr>\n<tr>\n<td><code>creation_date</code></td>\n<td>datetime</td>\n</tr>\n<tr>\n<td><code>expiration_date</code></td>\n<td>datetime</td>\n</tr>\n<tr>\n<td><code>user_id</code></td>\n<td>int</td>\n</tr>\n</tbody></table>\n</li>\n<li>User<table>\n<thead>\n<tr>\n<th>Column</th>\n<th>Type</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>name</code></td>\n<td>varchar(20)</td>\n</tr>\n<tr>\n<td><code>email</code></td>\n<td>varchar(32)</td>\n</tr>\n<tr>\n<td><code>creation_date</code></td>\n<td>datetime</td>\n</tr>\n<tr>\n<td><code>last_login</code></td>\n<td>datetime</td>\n</tr>\n</tbody></table>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Basic-System-Design-and-Algorithm\"><a href=\"#Basic-System-Design-and-Algorithm\" class=\"headerlink\" title=\"Basic System Design and Algorithm\"></a>Basic System Design and Algorithm</h2><h3 id=\"Encoding-actual-URL\"><a href=\"#Encoding-actual-URL\" class=\"headerlink\" title=\"Encoding actual URL\"></a>Encoding actual URL</h3><ul>\n<li>Compute unique hash<ul>\n<li><code>base64</code>: A-Z, a-z, 0-9, <code>-</code>, <code>.</code></li>\n<li>6 letters: 64 ^ 6 &#x3D; ~68.7 billion</li>\n<li>8 letters: 64 ^ 8 &#x3D; ~281 trillion</li>\n<li>Use 6 letters</li>\n<li><code>MD5</code> generates 128 bit hash value</li>\n<li>Each <code>base64</code> character encodes 6 bits</li>\n<li><code>base64</code> encoding generates 22 characters</li>\n<li>Select 8 characters</li>\n</ul>\n</li>\n<li>Issues with this approach<ul>\n<li>Same URL from multiple users</li>\n<li>URL-encoded</li>\n</ul>\n</li>\n<li>Workaround<ul>\n<li>Append an increasing sequence number to each input URL, and generate a hash for it</li>\n<li>Append user id to input URL</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Generating-keys-offline\"><a href=\"#Generating-keys-offline\" class=\"headerlink\" title=\"Generating keys offline\"></a>Generating keys offline</h3><ul>\n<li><p>Standalone Key Generation Service (KGS)</p>\n<ul>\n<li>Generate random 6 letter strings and store them in a database (key DB)</li>\n<li>When a short URL is needed, take one from the key DB</li>\n</ul>\n</li>\n<li><p>Key DB size</p>\n<ul>\n<li>6 characters&#x2F;key * 68.7B unique keys &#x3D; 412 GB</li>\n</ul>\n</li>\n<li><p>Concurrency issue</p>\n<ul>\n<li>If there are multiple servers reading keys concurrently, two or more servers try to read the same key from the database.</li>\n</ul>\n</li>\n<li><p>Workaround</p>\n<ul>\n<li>Servers can use KGS to read&#x2F;mark keys in the database.</li>\n<li>KGS can use two tables to store keys: one for keys that are not used yet, and one for all the used keys.</li>\n<li>KGS can always keep some keys in memory so that it can quickly provide them whenever a server needs them.</li>\n<li>KGS needs to make sure not to give the same key to multiple servers.</li>\n<li>Comment: keys are sharded. Each KGS server only serves one application server.</li>\n</ul>\n</li>\n<li><p>Key lookup</p>\n<ul>\n<li>When a key is found, issue an “HTTP 302 Redirect” status and passing the stored URL.</li>\n<li>When a key is not found, issue an “HTTP 404 Not Found”, or redirect to homepage.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"UUID\"><a href=\"#UUID\" class=\"headerlink\" title=\"UUID\"></a>UUID</h3><p>Replace KGS with UUID.</p>\n<h2 id=\"Data-Partitioning-and-Replication\"><a href=\"#Data-Partitioning-and-Replication\" class=\"headerlink\" title=\"Data Partitioning and Replication\"></a>Data Partitioning and Replication</h2><ul>\n<li><p>Range Based Partitioning</p>\n<ul>\n<li>Store URLs in separate partitions based on the first letter of the URL or the hash key.</li>\n<li>Combine certain less frequently occurring letters into one database partition.</li>\n</ul>\n</li>\n<li><p>Problem with this approach</p>\n<ul>\n<li>Unbalanced servers.</li>\n</ul>\n</li>\n<li><p>Hash-Based Partitioning</p>\n<ul>\n<li>Take a hash of the short URL we are storing, and calculate which partition to use based upon the hash.</li>\n<li>Use consistent hashing</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Cache\"><a href=\"#Cache\" class=\"headerlink\" title=\"Cache\"></a>Cache</h2><ul>\n<li>Eviction policy<ul>\n<li>LRU: discard the least recently used URL first</li>\n</ul>\n</li>\n<li>Cache update<ul>\n<li>Cache miss: hit backend database and pass new entry to all cache replicas</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Load-Balancer-LB\"><a href=\"#Load-Balancer-LB\" class=\"headerlink\" title=\"Load Balancer (LB)\"></a>Load Balancer (LB)</h2><ul>\n<li>LB locations<ul>\n<li>Between Clients and Application servers</li>\n<li>Between Application Servers and database servers</li>\n<li>Between Application Servers and Cache servers</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"DB-Sweeping\"><a href=\"#DB-Sweeping\" class=\"headerlink\" title=\"DB Sweeping\"></a>DB Sweeping</h2><p>A separate Cleanup service can run periodically to remove expired links from our storage and cache.</p>\n<h2 id=\"Telemetry\"><a href=\"#Telemetry\" class=\"headerlink\" title=\"Telemetry\"></a>Telemetry</h2><p>Statistics about the system: how many times a short URL has been used</p>\n<h2 id=\"Security-and-Permissions\"><a href=\"#Security-and-Permissions\" class=\"headerlink\" title=\"Security and Permissions\"></a>Security and Permissions</h2><ul>\n<li>Store permission level (public&#x2F;private) with each URL in the database</li>\n<li>Send an error (HTTP 401) for unauthorized access</li>\n</ul>\n",
            "tags": [
                "blog",
                "coding",
                "computer-science",
                "system-design",
                "design-interview",
                "preparation",
                "short-url",
                "url-shortner"
            ]
        }
    ]
}