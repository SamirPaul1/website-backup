{
    "version": "https://jsonfeed.org/version/1",
    "title": "Samir Paul â€¢ All posts by \"dynamic programming\" tag",
    "description": "Software Engineer",
    "home_page_url": "https://samirpaul.in",
    "items": [
        {
            "id": "https://samirpaul.in/posts/dynamic-programming-patterns/",
            "url": "https://samirpaul.in/posts/dynamic-programming-patterns/",
            "title": "Dynamic Programming Patterns",
            "date_published": "2023-08-05T20:52:53.890Z",
            "content_html": "<p><img src=\"https://user-images.githubusercontent.com/77569653/226705479-a4d6c0a3-0191-4d45-8bf6-597ffaa5de40.png\" alt=\"Banner\"></p>\n<p>Before starting the topic let me introduce myself. I am a Mobile Developer currently working in Warsaw and spending my free time for interview preparations. I started to prepare for interviews two years ago. At that time I should say I could not solve the two sum problem. Easy problems seemed to me like hard ones so most of the time I had to look at editorials and discuss section. Currently, I have solved ~800 problems and time to time participate in contests. I usually solve 3 problems in a contest and sometimes 4 problems. Ok, lets come back to the topic.</p>\n<p>Recently I have concentrated my attention on Dynamic Programming cause its one of the hardest topics in an interview prep. After solving ~140 problems in DP I have noticed that there are few patterns that can be found in different problems. So I did a research on that and find the following topics. I will not give complete ways how to solve problems but these patterns may be helpful in solving DP.</p>\n<h1 id=\"Patterns\"><a href=\"#Patterns\" class=\"headerlink\" title=\"Patterns\"></a>Patterns</h1><hr>\n<p><a href=\"https://leetcode.com/discuss/study-guide/458695/Dynamic-Programming-Patterns#Minimum-(Maximum)-Path-to-Reach-a-Target\">Minimum (Maximum) Path to Reach a Target</a><br><a href=\"https://leetcode.com/discuss/study-guide/458695/Dynamic-Programming-Patterns#distinct-ways\">Distinct Ways</a><br><a href=\"https://leetcode.com/discuss/study-guide/458695/Dynamic-Programming-Patterns#Merging-Intervals\">Merging Intervals</a><br><a href=\"https://leetcode.com/discuss/study-guide/458695/Dynamic-Programming-Patterns#DP-on-Strings\">DP on Strings</a><br><a href=\"https://leetcode.com/discuss/study-guide/458695/Dynamic-Programming-Patterns#Decision-Making\">Decision Making</a></p>\n<h1 id=\"Minimum-Maximum-Path-to-Reach-a-Target\"><a href=\"#Minimum-Maximum-Path-to-Reach-a-Target\" class=\"headerlink\" title=\"Minimum (Maximum) Path to Reach a Target\"></a>Minimum (Maximum) Path to Reach a Target</h1><hr>\n<p>Problem list: <a href=\"https://leetcode.com/list/55ac4kuc\">https://leetcode.com/list/55ac4kuc</a></p>\n<p>Generate problem statement for this pattern</p>\n<h3 id=\"Statement\"><a href=\"#Statement\" class=\"headerlink\" title=\"Statement\"></a>Statement</h3><blockquote>\n<p>Given a target find minimum (maximum) cost &#x2F; path &#x2F; sum to reach the target.</p>\n</blockquote>\n<h3 id=\"Approach\"><a href=\"#Approach\" class=\"headerlink\" title=\"Approach\"></a>Approach</h3><blockquote>\n<p>Choose minimum (maximum) path among all possible paths before the current state, then add value for the current state.</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">routes[i] = min(routes[i-1], routes[i-2], ... , routes[i-k]) + cost[i]</span><br></pre></td></tr></table></figure>\n\n<p>Generate optimal solutions for all values in the target and return the value for the target.</p>\n<h3 id=\"Top-Down\"><a href=\"#Top-Down\" class=\"headerlink\" title=\"Top-Down\"></a>Top-Down</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for (int j = 0; j &lt; ways.size(); ++j) &#123;</span><br><span class=\"line\">    result = min(result, topDown(target - ways[j]) + cost/ path / sum);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">return memo[/*state parameters*/] = result;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Bottom-Up\"><a href=\"#Bottom-Up\" class=\"headerlink\" title=\"Bottom-Up\"></a>Bottom-Up</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for (int i = 1; i &lt;= target; ++i) &#123;</span><br><span class=\"line\">   for (int j = 0; j &lt; ways.size(); ++j) &#123;</span><br><span class=\"line\">       if (ways[j] &lt;= i) &#123;</span><br><span class=\"line\">           dp[i] = min(dp[i], dp[i - ways[j]] + cost / path / sum) ;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">return dp[target]</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Similar-Problems\"><a href=\"#Similar-Problems\" class=\"headerlink\" title=\"Similar Problems\"></a>Similar Problems</h3><p><a href=\"https://leetcode.com/problems/min-cost-climbing-stairs/\">746. Min Cost Climbing Stairs</a> <code>Easy</code></p>\n<h3 id=\"Top-Down-1\"><a href=\"#Top-Down-1\" class=\"headerlink\" title=\"Top-Down\"></a>Top-Down</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int result = min(minCost(n-1, cost, memo), minCost(n-2, cost, memo)) + (n == cost.size() ? 0 : cost[n]);</span><br><span class=\"line\">return memo[n] = result;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Bottom-Up-1\"><a href=\"#Bottom-Up-1\" class=\"headerlink\" title=\"Bottom-Up\"></a>Bottom-Up</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for (int i = 2; i &lt;= n; ++i) &#123;</span><br><span class=\"line\">   dp[i] = min(dp[i-1], dp[i-2]) + (i == n ? 0 : cost[i]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">return dp[n]</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://leetcode.com/problems/minimum-path-sum/\">64. Minimum Path Sum</a> <code>Medium</code></p>\n<h3 id=\"Top-Down-2\"><a href=\"#Top-Down-2\" class=\"headerlink\" title=\"Top-Down\"></a>Top-Down</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int result = min(pathSum(i+1, j, grid, memo), pathSum(i, j+1, grid, memo)) + grid[i][j];</span><br><span class=\"line\">    </span><br><span class=\"line\">return memo[i][j] = result;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Bottom-Up-2\"><a href=\"#Bottom-Up-2\" class=\"headerlink\" title=\"Bottom-Up\"></a>Bottom-Up</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for (int i = 1; i &lt; n; ++i) &#123;</span><br><span class=\"line\">   for (int j = 1; j &lt; m; ++j) &#123;</span><br><span class=\"line\">       grid[i][j] = min(grid[i-1][j], grid[i][j-1]) + grid[i][j];</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">return grid[n-1][m-1]</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://leetcode.com/problems/coin-change/\">322. Coin Change</a> <code>Medium</code></p>\n<h3 id=\"Top-Down-3\"><a href=\"#Top-Down-3\" class=\"headerlink\" title=\"Top-Down\"></a>Top-Down</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for (int i = 0; i &lt; coins.size(); ++i) &#123;</span><br><span class=\"line\">    if (coins[i] &lt;= target) &#123; // check validity of a sub-problem</span><br><span class=\"line\">        result = min(ans, CoinChange(target - coins[i], coins) + 1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">return memo[target] = result;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Bottom-Up-3\"><a href=\"#Bottom-Up-3\" class=\"headerlink\" title=\"Bottom-Up\"></a>Bottom-Up</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for (int j = 1; j &lt;= amount; ++j) &#123;</span><br><span class=\"line\">   for (int i = 0; i &lt; coins.size(); ++i) &#123;</span><br><span class=\"line\">       if (coins[i] &lt;= j) &#123;</span><br><span class=\"line\">           dp[j] = min(dp[j], dp[j - coins[i]] + 1);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://leetcode.com/problems/minimum-falling-path-sum/\">931. Minimum Falling Path Sum</a> <code>Medium</code></p>\n<p><a href=\"https://leetcode.com/problems/minimum-cost-for-tickets/\">983. Minimum Cost For Tickets</a> <code>Medium</code></p>\n<p><a href=\"https://leetcode.com/problems/2-keys-keyboard/\">650. 2 Keys Keyboard</a> <code>Medium</code></p>\n<p><a href=\"https://leetcode.com/problems/perfect-squares/\">279. Perfect Squares</a> <code>Medium</code></p>\n<p><a href=\"https://leetcode.com/problems/last-stone-weight-ii/\">1049. Last Stone Weight II</a> <code>Medium</code></p>\n<p><a href=\"https://leetcode.com/problems/triangle/\">120. Triangle</a> <code>Medium</code></p>\n<p><a href=\"https://leetcode.com/problems/ones-and-zeroes/\">474. Ones and Zeroes</a> <code>Medium</code></p>\n<p><a href=\"https://leetcode.com/problems/maximal-square/\">221. Maximal Square</a> <code>Medium</code></p>\n<p><a href=\"https://leetcode.com/problems/coin-change/\">322. Coin Change</a> <code>Medium</code></p>\n<p><a href=\"https://leetcode.com/problems/tiling-a-rectangle-with-the-fewest-squares/\">1240. Tiling a Rectangle with the Fewest Squares</a> <code>Hard</code></p>\n<p><a href=\"https://leetcode.com/problems/dungeon-game/\">174. Dungeon Game</a> <code>Hard</code></p>\n<p><a href=\"https://leetcode.com/problems/minimum-number-of-refueling-stops/\">871. Minimum Number of Refueling Stops</a> <code>Hard</code></p>\n<h1 id=\"Distinct-Ways\"><a href=\"#Distinct-Ways\" class=\"headerlink\" title=\"Distinct Ways\"></a>Distinct Ways</h1><hr>\n<p>Problem List: <a href=\"https://leetcode.com/list/55ajm50i\">https://leetcode.com/list/55ajm50i</a></p>\n<p>Generate problem statement for this pattern</p>\n<h3 id=\"Statement-1\"><a href=\"#Statement-1\" class=\"headerlink\" title=\"Statement\"></a>Statement</h3><blockquote>\n<p>Given a target find a number of distinct ways to reach the target.</p>\n</blockquote>\n<h3 id=\"Approach-1\"><a href=\"#Approach-1\" class=\"headerlink\" title=\"Approach\"></a>Approach</h3><blockquote>\n<p>Sum all possible ways to reach the current state.</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">routes[i] = routes[i-1] + routes[i-2], ... , + routes[i-k]</span><br></pre></td></tr></table></figure>\n\n<p>Generate sum for all values in the target and return the value for the target.</p>\n<h3 id=\"Top-Down-4\"><a href=\"#Top-Down-4\" class=\"headerlink\" title=\"Top-Down\"></a>Top-Down</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for (int j = 0; j &lt; ways.size(); ++j) &#123;</span><br><span class=\"line\">    result += topDown(target - ways[j]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">return memo[/*state parameters*/] = result;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Bottom-Up-4\"><a href=\"#Bottom-Up-4\" class=\"headerlink\" title=\"Bottom-Up\"></a>Bottom-Up</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for (int i = 1; i &lt;= target; ++i) &#123;</span><br><span class=\"line\">   for (int j = 0; j &lt; ways.size(); ++j) &#123;</span><br><span class=\"line\">       if (ways[j] &lt;= i) &#123;</span><br><span class=\"line\">           dp[i] += dp[i - ways[j]];</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">return dp[target]</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Similar-Problems-1\"><a href=\"#Similar-Problems-1\" class=\"headerlink\" title=\"Similar Problems\"></a>Similar Problems</h3><p><a href=\"https://leetcode.com/problems/climbing-stairs/\">70. Climbing Stairs</a> <code>Easy</code></p>\n<h3 id=\"Top-Down-5\"><a href=\"#Top-Down-5\" class=\"headerlink\" title=\"Top-Down\"></a>Top-Down</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int result = climbStairs(n-1, memo) + climbStairs(n-2, memo); </span><br><span class=\"line\">    </span><br><span class=\"line\">return memo[n] = result;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Bottom-Up-5\"><a href=\"#Bottom-Up-5\" class=\"headerlink\" title=\"Bottom-Up\"></a>Bottom-Up</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for (int stair = 2; stair &lt;= n; ++stair) &#123;</span><br><span class=\"line\">   for (int step = 1; step &lt;= 2; ++step) &#123;</span><br><span class=\"line\">       dp[stair] += dp[stair-step];   </span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://leetcode.com/problems/unique-paths/\">62. Unique Paths</a> <code>Medium</code></p>\n<h3 id=\"Top-Down-6\"><a href=\"#Top-Down-6\" class=\"headerlink\" title=\"Top-Down\"></a>Top-Down</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int result = UniquePaths(x-1, y) + UniquePaths(x, y-1);</span><br><span class=\"line\"></span><br><span class=\"line\">return memo[x][y] = result;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Bottom-Up-6\"><a href=\"#Bottom-Up-6\" class=\"headerlink\" title=\"Bottom-Up\"></a>Bottom-Up</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for (int i = 1; i &lt; m; ++i) &#123;</span><br><span class=\"line\">   for (int j = 1; j &lt; n; ++j) &#123;</span><br><span class=\"line\">       dp[i][j] = dp[i][j-1] + dp[i-1][j];</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://leetcode.com/problems/number-of-dice-rolls-with-target-sum/\">1155. Number of Dice Rolls With Target Sum</a> <code>Medium</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for (int rep = 1; rep &lt;= d; ++rep) &#123;</span><br><span class=\"line\">   vector&lt;int&gt; new_ways(target+1);</span><br><span class=\"line\">   for (int already = 0; already &lt;= target; ++already) &#123;</span><br><span class=\"line\">       for (int pipe = 1; pipe &lt;= f; ++pipe) &#123;</span><br><span class=\"line\">           if (already - pipe &gt;= 0) &#123;</span><br><span class=\"line\">               new_ways[already] += ways[already - pipe];</span><br><span class=\"line\">               new_ways[already] %= mod;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   ways = new_ways;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>Note</strong></p>\n<p>Some questions point out the number of repetitions, in that case, add one more loop to simulate every repetition.</p>\n<p><a href=\"https://leetcode.com/problems/knight-probability-in-chessboard/\">688. Knight Probability in Chessboard</a> <code>Medium</code></p>\n<p><a href=\"https://leetcode.com/problems/target-sum/\">494. Target Sum</a> <code>Medium</code></p>\n<p><a href=\"https://leetcode.com/problems/combination-sum-iv/\">377. Combination Sum IV</a> <code>Medium</code></p>\n<p><a href=\"https://leetcode.com/problems/knight-dialer/\">935. Knight Dialer</a> <code>Medium</code></p>\n<p><a href=\"https://leetcode.com/problems/dice-roll-simulation/\">1223. Dice Roll Simulation</a> <code>Medium</code></p>\n<p><a href=\"https://leetcode.com/problems/partition-equal-subset-sum/\">416. Partition Equal Subset Sum</a> <code>Medium</code></p>\n<p><a href=\"https://leetcode.com/problems/soup-servings/\">808. Soup Servings</a> <code>Medium</code></p>\n<p><a href=\"https://leetcode.com/problems/domino-and-tromino-tiling/\">790. Domino and Tromino Tiling</a> <code>Medium</code></p>\n<p><a href=\"https://leetcode.com/problems/minimum-swaps-to-make-sequences-increasing/\">801. Minimum Swaps To Make Sequences Increasing</a></p>\n<p><a href=\"https://leetcode.com/problems/number-of-longest-increasing-subsequence/\">673. Number of Longest Increasing Subsequence</a> <code>Medium</code></p>\n<p><a href=\"https://leetcode.com/problems/unique-paths-ii/\">63. Unique Paths II</a> <code>Medium</code></p>\n<p><a href=\"https://leetcode.com/problems/out-of-boundary-paths/\">576. Out of Boundary Paths</a> <code>Medium</code></p>\n<p><a href=\"https://leetcode.com/problems/number-of-ways-to-stay-in-the-same-place-after-some-steps/\">1269. Number of Ways to Stay in the Same Place After Some Steps</a> <code>Hard</code></p>\n<p><a href=\"https://leetcode.com/problems/count-vowels-permutation/\">1220. Count Vowels Permutation</a> <code>Hard</code></p>\n<h1 id=\"Merging-Intervals\"><a href=\"#Merging-Intervals\" class=\"headerlink\" title=\"Merging Intervals\"></a>Merging Intervals</h1><hr>\n<p>Problem List: <a href=\"https://leetcode.com/list/55aj8s16\">https://leetcode.com/list/55aj8s16</a></p>\n<p>Generate problem statement for this pattern</p>\n<h3 id=\"Statement-2\"><a href=\"#Statement-2\" class=\"headerlink\" title=\"Statement\"></a>Statement</h3><blockquote>\n<p>Given a set of numbers find an optimal solution for a problem considering the current number and the best you can get from the left and right sides.</p>\n</blockquote>\n<h3 id=\"Approach-2\"><a href=\"#Approach-2\" class=\"headerlink\" title=\"Approach\"></a>Approach</h3><blockquote>\n<p>Find all optimal solutions for every interval and return the best possible answer.</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// from i to j</span><br><span class=\"line\">dp[i][j] = dp[i][k] + result[k] + dp[k+1][j]</span><br></pre></td></tr></table></figure>\n\n<p>Get the best from the left and right sides and add a solution for the current position.</p>\n<h3 id=\"Top-Down-7\"><a href=\"#Top-Down-7\" class=\"headerlink\" title=\"Top-Down\"></a>Top-Down</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for (int k = i; k &lt;= j; ++k) &#123;</span><br><span class=\"line\">    result = max(result, topDown(nums, i, k-1) + result[k] + topDown(nums, k+1, j));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">return memo[/*state parameters*/] = result;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Bottom-Up-7\"><a href=\"#Bottom-Up-7\" class=\"headerlink\" title=\"Bottom-Up\"></a>Bottom-Up</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for(int l = 1; l&lt;n; l++) &#123;</span><br><span class=\"line\">   for(int i = 0; i&lt;n-l; i++) &#123;</span><br><span class=\"line\">       int j = i+l;</span><br><span class=\"line\">       for(int k = i; k&lt;j; k++) &#123;</span><br><span class=\"line\">           dp[i][j] = max(dp[i][j], dp[i][k] + result[k] + dp[k+1][j]);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">return dp[0][n-1];</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for(int l = 1; l&lt;n; l++) &#123;</span><br><span class=\"line\">   for(int i = 0; i&lt;n-l; i++) &#123;</span><br><span class=\"line\">       int j = i+l;</span><br><span class=\"line\">       for(int k = i; k&lt;j; k++) &#123;</span><br><span class=\"line\">           dp[i][j] = max(dp[i][j], dp[i][k] + result[k] + dp[k+1][j]);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">return dp[0][n-1]</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Similar-Problems-2\"><a href=\"#Similar-Problems-2\" class=\"headerlink\" title=\"Similar Problems\"></a>Similar Problems</h3><p><a href=\"https://leetcode.com/problems/minimum-cost-tree-from-leaf-values/\">1130. Minimum Cost Tree From Leaf Values</a> <code>Medium</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for (int l = 1; l &lt; n; ++l) &#123;</span><br><span class=\"line\">   for (int i = 0; i &lt; n - l; ++i) &#123;</span><br><span class=\"line\">       int j = i + l;</span><br><span class=\"line\">       dp[i][j] = INT_MAX;</span><br><span class=\"line\">       for (int k = i; k &lt; j; ++k) &#123;</span><br><span class=\"line\">           dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j] + maxs[i][k] * maxs[k+1][j]);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://leetcode.com/problems/unique-binary-search-trees/\">96. Unique Binary Search Trees</a> <code>Medium</code></p>\n<p><a href=\"https://leetcode.com/problems/minimum-score-triangulation-of-polygon/\">1039. Minimum Score Triangulation of Polygon</a> <code>Medium</code></p>\n<p><a href=\"https://leetcode.com/problems/remove-boxes/\">546. Remove Boxes</a> <code>Medium</code></p>\n<p><a href=\"https://leetcode.com/problems/minimum-cost-to-merge-stones/\">1000. Minimum Cost to Merge Stones</a> <code>Medium</code></p>\n<p><a href=\"https://leetcode.com/problems/burst-balloons/\">312. Burst Balloons</a> <code>Hard</code></p>\n<h3 id=\"Top-Down-8\"><a href=\"#Top-Down-8\" class=\"headerlink\" title=\"Top-Down\"></a>Top-Down</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for (int k = i; k &lt;= j; ++k) &#123;</span><br><span class=\"line\">    result = max(result, topDown(nums, i, k-1, memo) + (i-1 &gt;= 0 ? nums[i-1] : 1) * nums[k] * (j+1 &lt; nums.size() ? nums[j+1] : 1) + topDown(nums, k+1, j, memo));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">return memo[i][j] = result;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Bottom-Up-8\"><a href=\"#Bottom-Up-8\" class=\"headerlink\" title=\"Bottom-Up\"></a>Bottom-Up</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for(int l = 1; l &lt; n; l++) &#123;</span><br><span class=\"line\">    for(int i = 0; i &lt; n-l; i++) &#123;</span><br><span class=\"line\">        int j = i+l;</span><br><span class=\"line\">        for(int k = i; k &lt;= j; k++) &#123;</span><br><span class=\"line\">            dp[i][j] = max(dp[i][j], (((k&gt;i &amp;&amp; k&gt;0) ? dp[i][k-1] : 0) + (i&gt;0 ? nums[i-1] : 1) * nums[k] * (j&lt;n-1 ? nums[j+1] : 1) + ((k&lt;j &amp;&amp; k&lt;n-1) ? dp[k+1][j] : 0)));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">return dp[0][n-1];</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://leetcode.com/problems/guess-number-higher-or-lower-ii/\">375. Guess Number Higher or Lower II</a> <code>Medium</code></p>\n<h1 id=\"DP-on-Strings\"><a href=\"#DP-on-Strings\" class=\"headerlink\" title=\"DP on Strings\"></a>DP on Strings</h1><hr>\n<p>Problem List: <a href=\"https://leetcode.com/list/55afh7m7\">https://leetcode.com/list/55afh7m7</a></p>\n<p>General problem statement for this pattern can vary but most of the time you are given two strings where lengths of those strings are not big</p>\n<h3 id=\"Statement-3\"><a href=\"#Statement-3\" class=\"headerlink\" title=\"Statement\"></a>Statement</h3><blockquote>\n<p>Given two strings <code>s1</code> and <code>s2</code>, return <code>some result</code>.</p>\n</blockquote>\n<h3 id=\"Approach-3\"><a href=\"#Approach-3\" class=\"headerlink\" title=\"Approach\"></a>Approach</h3><blockquote>\n<p>Most of the problems on this pattern requires a solution that can be accepted in O(n^2) complexity.</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// i - indexing string s1</span><br><span class=\"line\">// j - indexing string s2</span><br><span class=\"line\">for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class=\"line\">   for (int j = 1; j &lt;= m; ++j) &#123;</span><br><span class=\"line\">       if (s1[i-1] == s2[j-1]) &#123;</span><br><span class=\"line\">           dp[i][j] = /*code*/;</span><br><span class=\"line\">       &#125; else &#123;</span><br><span class=\"line\">           dp[i][j] = /*code*/;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>If you are given one string <code>s</code> the approach may little vary</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for (int l = 1; l &lt; n; ++l) &#123;</span><br><span class=\"line\">   for (int i = 0; i &lt; n-l; ++i) &#123;</span><br><span class=\"line\">       int j = i + l;</span><br><span class=\"line\">       if (s[i] == s[j]) &#123;</span><br><span class=\"line\">           dp[i][j] = /*code*/;</span><br><span class=\"line\">       &#125; else &#123;</span><br><span class=\"line\">           dp[i][j] = /*code*/;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://leetcode.com/problems/longest-common-subsequence/\">1143. Longest Common Subsequence</a> <code>Medium</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class=\"line\">   for (int j = 1; j &lt;= m; ++j) &#123;</span><br><span class=\"line\">       if (text1[i-1] == text2[j-1]) &#123;</span><br><span class=\"line\">           dp[i][j] = dp[i-1][j-1] + 1;</span><br><span class=\"line\">       &#125; else &#123;</span><br><span class=\"line\">           dp[i][j] = max(dp[i-1][j], dp[i][j-1]);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://leetcode.com/problems/palindromic-substrings/\">647. Palindromic Substrings</a> <code>Medium</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for (int l = 1; l &lt; n; ++l) &#123;</span><br><span class=\"line\">   for (int i = 0; i &lt; n-l; ++i) &#123;</span><br><span class=\"line\">       int j = i + l;</span><br><span class=\"line\">       if (s[i] == s[j] &amp;&amp; dp[i+1][j-1] == j-i-1) &#123;</span><br><span class=\"line\">           dp[i][j] = dp[i+1][j-1] + 2;</span><br><span class=\"line\">       &#125; else &#123;</span><br><span class=\"line\">           dp[i][j] = 0;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://leetcode.com/problems/longest-palindromic-subsequence/\">516. Longest Palindromic Subsequence</a> <code>Medium</code></p>\n<p><a href=\"https://leetcode.com/problems/shortest-common-supersequence/\">1092. Shortest Common Supersequence</a> <code>Medium</code></p>\n<p><a href=\"https://leetcode.com/problems/edit-distance/\">72. Edit Distance</a> <code>Hard</code></p>\n<p><a href=\"https://leetcode.com/problems/distinct-subsequences/\">115. Distinct Subsequences</a> <code>Hard</code></p>\n<p><a href=\"https://leetcode.com/problems/minimum-ascii-delete-sum-for-two-strings/\">712. Minimum ASCII Delete Sum for Two Strings</a> <code>Medium</code></p>\n<p><a href=\"https://leetcode.com/problems/longest-palindromic-substring/\">5. Longest Palindromic Substring</a> <code>Medium</code></p>\n<h1 id=\"Decision-Making\"><a href=\"#Decision-Making\" class=\"headerlink\" title=\"Decision Making\"></a>Decision Making</h1><hr>\n<p>Problem List: <a href=\"https://leetcode.com/list/55af7bu7\">https://leetcode.com/list/55af7bu7</a></p>\n<p>The general problem statement for this pattern is forgiven situation decide whether to use or not to use the current state. So, the problem requires you to make a decision at a current state.</p>\n<h3 id=\"Statement-4\"><a href=\"#Statement-4\" class=\"headerlink\" title=\"Statement\"></a>Statement</h3><blockquote>\n<p>Given a set of values find an answer with an option to choose or ignore the current value.</p>\n</blockquote>\n<h3 id=\"Approach-4\"><a href=\"#Approach-4\" class=\"headerlink\" title=\"Approach\"></a>Approach</h3><blockquote>\n<p>If you decide to choose the current value use the previous result where the value was ignored; vice-versa, if you decide to ignore the current value use previous result where value was used.</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// i - indexing a set of values</span><br><span class=\"line\">// j - options to ignore j values</span><br><span class=\"line\">for (int i = 1; i &lt; n; ++i) &#123;</span><br><span class=\"line\">   for (int j = 1; j &lt;= k; ++j) &#123;</span><br><span class=\"line\">       dp[i][j] = max(&#123;dp[i][j], dp[i-1][j] + arr[i], dp[i-1][j-1]&#125;);</span><br><span class=\"line\">       dp[i][j-1] = max(&#123;dp[i][j-1], dp[i-1][j-1] + arr[i], arr[i]&#125;);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://leetcode.com/problems/house-robber/\">198. House Robber</a> <code>Easy</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for (int i = 1; i &lt; n; ++i) &#123;</span><br><span class=\"line\">   dp[i][1] = max(dp[i-1][0] + nums[i], dp[i-1][1]);</span><br><span class=\"line\">   dp[i][0] = dp[i-1][1];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://leetcode.com/problems/best-time-to-buy-and-sell-stock/\">121. Best Time to Buy and Sell Stock</a> <code>Easy</code></p>\n<p><a href=\"https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/\">714. Best Time to Buy and Sell Stock with Transaction Fee</a> <code>Medium</code></p>\n<p><a href=\"https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/\">309. Best Time to Buy and Sell Stock with Cooldown</a> <code>Medium</code></p>\n<p><a href=\"https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/\">123. Best Time to Buy and Sell Stock III</a> <code>Hard</code></p>\n<p><a href=\"https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/\">188. Best Time to Buy and Sell Stock IV</a> <code>Hard</code></p>\n<p>I hope these tips will be helpful ðŸ˜Š</p>\n",
            "tags": [
                "blog",
                "coding",
                "computer-science",
                "Dynamic Programming",
                "Patterns"
            ]
        }
    ]
}