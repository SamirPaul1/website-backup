{
    "version": "https://jsonfeed.org/version/1",
    "title": "Samir Paul • All posts by \"sql\" tag",
    "description": "Here I write content about Computer Science, Data Structures Algorithms, Networking, Artificial Intelligence and Coding Interview Preparation.",
    "home_page_url": "https://samirpaul1.github.io",
    "items": [
        {
            "id": "https://samirpaul1.github.io/posts/sql-joins-inner-left-right-and-full-joins/",
            "url": "https://samirpaul1.github.io/posts/sql-joins-inner-left-right-and-full-joins/",
            "title": "SQL Joins - Inner, Left, Right and Full Joins",
            "date_published": "2023-08-05T20:52:53.910Z",
            "content_html": "<p><strong>SQL Join</strong> statement is used to combine data or rows from two or more tables based on a common field between them. Different types of Joins are as follows: </p>\n<ul>\n<li>INNER JOIN</li>\n<li>LEFT JOIN</li>\n<li>RIGHT JOIN</li>\n<li>FULL JOIN</li>\n</ul>\n<p><img src=\"https://user-images.githubusercontent.com/77569653/227738791-78897c64-4c15-4d6a-b75a-656c6a59a5d2.png\" alt=\"SQL Joins\"></p>\n",
            "tags": [
                "blog",
                "coding",
                "computer-science",
                "INNER JOIN",
                "RIGHT JOIN",
                "FULL JOIN",
                "SQL",
                "SQL Joins"
            ]
        },
        {
            "id": "https://samirpaul1.github.io/posts/sql-vs-nosql/",
            "url": "https://samirpaul1.github.io/posts/sql-vs-nosql/",
            "title": "SQL vs. NoSQL",
            "date_published": "2023-08-05T20:52:53.878Z",
            "content_html": "<h1 id=\"SQL-vs-NoSQL\"><a href=\"#SQL-vs-NoSQL\" class=\"headerlink\" title=\"SQL vs. NoSQL\"></a>SQL vs. NoSQL</h1><h2 id=\"Common-types-of-NoSQL\"><a href=\"#Common-types-of-NoSQL\" class=\"headerlink\" title=\"Common types of NoSQL\"></a>Common types of NoSQL</h2><h3 id=\"Key-value-stores\"><a href=\"#Key-value-stores\" class=\"headerlink\" title=\"Key-value stores\"></a>Key-value stores</h3><ul>\n<li>Array of key-value pairs. The “key” is an attribute name.</li>\n<li>Redis, Vodemort, Dynamo.</li>\n</ul>\n<h3 id=\"Document-databases\"><a href=\"#Document-databases\" class=\"headerlink\" title=\"Document databases\"></a>Document databases</h3><ul>\n<li>Data is stored in documents.</li>\n<li>Documents are grouped in collections.</li>\n<li>Each document can have an entirely different structure.</li>\n<li>CouchDB, MongoDB.</li>\n</ul>\n<h3 id=\"Wide-column-columnar-databases\"><a href=\"#Wide-column-columnar-databases\" class=\"headerlink\" title=\"Wide-column &#x2F; columnar databases\"></a>Wide-column &#x2F; columnar databases</h3><ul>\n<li>Column families - containers for rows.</li>\n<li>No need to know all the columns up front.</li>\n<li>Each row can have different number of columns.</li>\n<li>Cassandra, HBase.</li>\n</ul>\n<h3 id=\"Graph-database\"><a href=\"#Graph-database\" class=\"headerlink\" title=\"Graph database\"></a>Graph database</h3><ul>\n<li>Data is stored in graph structures<ul>\n<li>Nodes: entities</li>\n<li>Properties: information about the entities</li>\n<li>Lines: connections between the entities</li>\n</ul>\n</li>\n<li>Neo4J, InfiniteGraph</li>\n</ul>\n<h2 id=\"Differences-between-SQL-and-NoSQL\"><a href=\"#Differences-between-SQL-and-NoSQL\" class=\"headerlink\" title=\"Differences between SQL and NoSQL\"></a>Differences between SQL and NoSQL</h2><h3 id=\"Storage\"><a href=\"#Storage\" class=\"headerlink\" title=\"Storage\"></a>Storage</h3><ul>\n<li>SQL: store data in tables.</li>\n<li>NoSQL: have different data storage models.</li>\n</ul>\n<h3 id=\"Schema\"><a href=\"#Schema\" class=\"headerlink\" title=\"Schema\"></a>Schema</h3><ul>\n<li>SQL<ul>\n<li>Each record conforms to a fixed schema.</li>\n<li>Schema can be altered, but it requires modifying the whole database.</li>\n</ul>\n</li>\n<li>NoSQL:<ul>\n<li>Schemas are dynamic.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Querying\"><a href=\"#Querying\" class=\"headerlink\" title=\"Querying\"></a>Querying</h3><ul>\n<li>SQL<ul>\n<li>Use SQL (structured query language) for defining and manipulating the data.</li>\n</ul>\n</li>\n<li>NoSQL<ul>\n<li>Queries are focused on a collection of documents.</li>\n<li>UnQL (unstructured query language).</li>\n<li>Different databases have different syntax.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Scalability\"><a href=\"#Scalability\" class=\"headerlink\" title=\"Scalability\"></a>Scalability</h3><ul>\n<li>SQL<ul>\n<li>Vertically scalable (by increasing the horsepower: memory, CPU, etc) and expensive.</li>\n<li>Horizontally scalable (across multiple servers); but it can be challenging and time-consuming.</li>\n</ul>\n</li>\n<li>NoSQL<ul>\n<li>Horizontablly scalable (by adding more servers) and cheap.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"ACID\"><a href=\"#ACID\" class=\"headerlink\" title=\"ACID\"></a>ACID</h3><ul>\n<li>Atomicity, consistency, isolation, durability</li>\n<li>SQL<ul>\n<li>ACID compliant</li>\n<li>Data reliability</li>\n<li>Gurantee of transactions</li>\n</ul>\n</li>\n<li>NoSQL<ul>\n<li>Most sacrifice ACID compliance for performance and scalability.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Which-one-to-use\"><a href=\"#Which-one-to-use\" class=\"headerlink\" title=\"Which one to use?\"></a>Which one to use?</h2><h3 id=\"SQL\"><a href=\"#SQL\" class=\"headerlink\" title=\"SQL\"></a>SQL</h3><ul>\n<li>Ensure ACID compliance.<ul>\n<li>Reduce anomalies.</li>\n<li>Protect database integrity.</li>\n</ul>\n</li>\n<li>Data is structured and unchanging.</li>\n</ul>\n<h3 id=\"NoSQL\"><a href=\"#NoSQL\" class=\"headerlink\" title=\"NoSQL\"></a>NoSQL</h3><ul>\n<li>Data has little or no structure.</li>\n<li>Make the most of cloud computing and storage.<ul>\n<li>Cloud-based storage requires data to be easily spread across multiple servers to scale up.</li>\n</ul>\n</li>\n<li>Rapid development.<ul>\n<li>Frequent updates to the data structure.</li>\n</ul>\n</li>\n</ul>\n",
            "tags": [
                "blog",
                "coding",
                "computer-science",
                "system-design",
                "design-interview",
                "sql",
                "nosql"
            ]
        },
        {
            "id": "https://samirpaul1.github.io/posts/sharding-or-data-partitioning/",
            "url": "https://samirpaul1.github.io/posts/sharding-or-data-partitioning/",
            "title": "Sharding or Data Partitioning",
            "date_published": "2023-08-05T20:52:53.876Z",
            "content_html": "<h1 id=\"Sharding-Data-Partitioning\"><a href=\"#Sharding-Data-Partitioning\" class=\"headerlink\" title=\"Sharding &#x2F; Data Partitioning\"></a>Sharding &#x2F; Data Partitioning</h1><h2 id=\"Partitioning-methods\"><a href=\"#Partitioning-methods\" class=\"headerlink\" title=\"Partitioning methods\"></a>Partitioning methods</h2><ul>\n<li>Horizontal partitioning<ul>\n<li>Range based sharding.</li>\n<li>Put different rows into different tables.</li>\n<li>Con<ul>\n<li>If the value whose range is used for sharding isn’t chosen carefully, the partitioning scheme will lead to unbalanced servers.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Vertical partitioning<ul>\n<li>Divide data for a specific feature to their own server.</li>\n<li>Pro<ul>\n<li>Straightforward to implement.</li>\n<li>Low impact on the application.</li>\n</ul>\n</li>\n<li>Con<ul>\n<li>To support growth of the application, a database may need further partitioning.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Directory-based partitioning<ul>\n<li>A lookup service that knows the partitioning scheme and abstracts it away from the database access code.</li>\n<li>Allow addition of db servers or change of partitioning schema without impacting application.</li>\n<li>Con<ul>\n<li>Can be a single point of failure.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Partitioning-criteria\"><a href=\"#Partitioning-criteria\" class=\"headerlink\" title=\"Partitioning criteria\"></a>Partitioning criteria</h2><ul>\n<li>Key or hash-based partitioning<ul>\n<li>Apply a hash function to some key attribute of the entry to get the partition number.</li>\n<li>Problem<ul>\n<li>Adding new servers may require changing the hash function, which would need redistribution of data and downtime for the service.</li>\n<li>Workaround: <a href=\"https://en.wikipedia.org/wiki/Consistent_hashing\">consistent hashing</a>.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>List partitioning<ul>\n<li>Each partition is assigned a list of values.</li>\n</ul>\n</li>\n<li>Round-robin partitioning<ul>\n<li>With <code>n</code> partitions, the <code>i</code> tuple is assigned to partition <code>i % n</code>.</li>\n</ul>\n</li>\n<li>Composite partitioning<ul>\n<li>Combine any of above partitioning schemes to devise a new scheme.</li>\n<li>Consistent hashing is a composite of hash and list partitioning.<ul>\n<li>Key -&gt; reduced key space through hash -&gt; list -&gt; partition.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Common-problems-of-sharding\"><a href=\"#Common-problems-of-sharding\" class=\"headerlink\" title=\"Common problems of sharding\"></a>Common problems of sharding</h2><p>Most of the constraints are due to the fact that operations across multiple tables or multiple rows in the same table will no longer run on the same server.</p>\n<ul>\n<li>Joins and denormalization<ul>\n<li>Joins will not be performance efficient since data has to be compiled from multiple servers.</li>\n<li>Workaround: denormalize the database so that queries can be performed from a single table. But this can lead to data inconsistency.</li>\n</ul>\n</li>\n<li>Referential integrity<ul>\n<li>Difficult to enforce data integrity constraints (e.g. foreign keys).</li>\n<li>Workaround<ul>\n<li>Referential integrity is enforced by application code.</li>\n<li>Applications can run SQL jobs to clean up dangling references.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Rebalancing<ul>\n<li>Necessity of rebalancing<ul>\n<li>Data distribution is not uniform.</li>\n<li>A lot of load on one shard.</li>\n</ul>\n</li>\n<li>Create more db shards or rebalance existing shards changes partitioning scheme and requires data movement.</li>\n</ul>\n</li>\n</ul>\n",
            "tags": [
                "blog",
                "coding",
                "computer-science",
                "system-design",
                "design-interview",
                "sql",
                "nosql",
                "sharding",
                "data-partitioning"
            ]
        }
    ]
}