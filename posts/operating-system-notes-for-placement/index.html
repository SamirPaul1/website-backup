<!doctype html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover" ><meta name="generator" content="Jekyll v4.3.2" /><meta property="og:title" content="Operating System Notes For Placement" /><meta name="author" content="Samir Paul" /><meta property="og:locale" content="en" /><meta name="description" content="Operating System Notes For Tech Placements" /><meta property="og:description" content="Operating System Notes For Tech Placements" /><link rel="canonical" href="https://samir.pages.dev/posts/operating-system-notes-for-placement/" /><meta property="og:url" content="https://samir.pages.dev/posts/operating-system-notes-for-placement/" /><meta property="og:site_name" content="Samir Paul" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2023-06-11T00:00:00+05:30" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Operating System Notes For Placement" /><meta name="twitter:site" content="@SamirPaulb" /><meta name="twitter:creator" content="@Samir Paul" /><meta property="fb:app_id" content="6800281970014175" /><meta name="google-site-verification" content="vJAOBxbJTCK2vXG-hLFeGsoC9hXgFlCpuJJ8AcJLROQ" /><meta name="msvalidate.01" content="1A92FC2EC113F8616A21D76DA684A133" /><meta name="yandex-verification" content="fe6a06c57be84984" /><meta name="facebook-domain-verification" content="3pkgruuk3kzlsn3jdfehgbd4sem1qb" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Samir Paul"},"dateModified":"2023-06-11T00:00:00+05:30","datePublished":"2023-06-11T00:00:00+05:30","description":"Operating System Notes For Tech Placements","headline":"Operating System Notes For Placement","mainEntityOfPage":{"@type":"WebPage","@id":"https://samir.pages.dev/posts/operating-system-notes-for-placement/"},"url":"https://samir.pages.dev/posts/operating-system-notes-for-placement/"}</script><title>Operating System Notes For Placement | Samir Paul</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Samir Paul"><meta name="application-name" content="Samir Paul"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/jekyll-theme-chirpy.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.21.2/dist/tocbot.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return 'mode'; } static get MODE_ATTR() { return 'data-mode'; } static get DARK_MODE() { return 'dark'; } static get LIGHT_MODE() { return 'light'; } static get ID() { return 'mode-toggle'; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener('change', () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia('(prefers-color-scheme: dark)'); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { document.documentElement.setAttribute(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { document.documentElement.setAttribute(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { document.documentElement.removeAttribute(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage( { direction: ModeToggle.ID, message: this.modeStatus }, '*' ); } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.notify(); } /* flipMode() */ } /* ModeToggle */ const modeToggle = new ModeToggle(); </script><body><aside aria-label="Sidebar" id="sidebar" class="d-flex flex-column align-items-end"><header class="profile-wrapper"> <a href="/" id="avatar" class="rounded-circle"> <img src="/assets/img/avatar.webp" width="112" height="112" alt="avatar" onerror="this.style.display='none'"> </a><h1 class="site-title"> <a href="/">Samir Paul</a></h1><p class="site-subtitle fst-italic mb-0">Software Engineer</p></header><nav class="flex-column flex-grow-1 w-100 ps-0"><ul class="nav"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle"></i> <span>ABOUT</span> </a><li class="nav-item"> <a href="/posts/" class="nav-link"> <i class="fa-fw fas fa-archive"></i> <span>ALL POSTS</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream"></i> <span>CATEGORIES</span> </a></ul></nav><div class="sidebar-bottom d-flex flex-wrap align-items-center w-100"> <button type="button" class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/SamirPaul1" aria-label="github" target="_blank" rel="noopener noreferrer" > <i class="fab fa-github"></i> </a> <a href="https://twitter.com/SamirPaulb" aria-label="twitter" target="_blank" rel="noopener noreferrer" > <i class="fa-brands fa-x-twitter"></i> </a> <a href="javascript:location.href = 'mailto:' + ['',''].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></aside><div id="main-wrapper" class="d-flex justify-content-center"><div class="container d-flex flex-column px-xxl-5"><header id="topbar-wrapper" aria-label="Top Bar"><div id="topbar" class="d-flex align-items-center justify-content-between px-lg-3 h-100" ><nav id="breadcrumb" aria-label="Breadcrumb"> <span> <a href="/"> Home </a> </span> <span>Operating System Notes For Placement</span></nav><button type="button" id="sidebar-trigger" class="btn btn-link"> <i class="fas fa-bars fa-fw"></i> </button><div id="topbar-title"> Post</div><button type="button" id="search-trigger" class="btn btn-link"> <i class="fas fa-search fa-fw"></i> </button> <search class="align-items-center ms-3 ms-lg-0"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..." > </search> <button type="button" class="btn btn-link text-decoration-none" id="search-cancel">Cancel</button></div></header><div class="row flex-grow-1"><main aria-label="Main Content" class="col-12 col-lg-11 col-xl-9 px-md-4"><article class="px-1"><header><h1 data-toc-skip>Operating System Notes For Placement</h1><div class="post-meta text-muted"> <span> Posted <time data-ts="1686421800" data-df="ll" data-bs-toggle="tooltip" data-bs-placement="bottom" > Jun 11, 2023 </time> </span><div class="d-flex justify-content-between"> <span> By <em> <a href="https://twitter.com/SamirPaulb">Samir Paul</a> </em> </span> <span class="readtime" data-bs-toggle="tooltip" data-bs-placement="bottom" title="8617 words" > <em>47 min</em> read</span></div></div></header><div class="content"><h1 id="operating-systems-overview">Operating Systems Overview</h1><hr /><h3><a href="https://github.com/github/docs/files/12329707/OS-All-Notes.pdf" target="_blank">Download PDF Notes➥</a></h3><iframe loading="lazy" src="https://scdn.web.app/books-pdfs/1-Placements-Notes/OS-All-Notes.pdf" width="100%" height="600"></iframe><p><strong>Operating Systems</strong> :</p><ul><li>Direct operational resources [CPU, memory, devices]<li>Enforces working policies [Resource usage, access]<li>Mitigates difficulty of complex tasks [abstract hardware details (using system calls)]</ul><h2 id="what-is-an-operating-system"><span class="me-2">What is an Operating System?</span><a href="#what-is-an-operating-system" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>Intermediate between Hardware and Software applications<li>Hides hardware complexity (Read/write file storage, send/receive socket network)<li>Handles resource management (CPU scheduling, Memory management)<li>Provide isolation and protection (allocate different parts of memory to different applications so that applications don’t overwrite other memory locations)</ul><h2 id="operating-system-definition"><span class="me-2">Operating System definition:</span><a href="#operating-system-definition" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>An <strong>Operating System</strong> is a layer of systems software that:</p><ul><li>directly has privileged access to the underlying hardware;<li>hides the hardware complexity;<li>manages hardware on behalf of one or more application according to some predifined policies.<li>In addition, it ensures that applications are isolated and protected from one another.</ul><h2 id="operating-system-examples"><span class="me-2">Operating System examples:</span><a href="#operating-system-examples" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><div class="table-wrapper"><table><thead><tr><th>Desktop<th>Embedded devices<tbody><tr><td>Microsoft Windows<td>Android OS<tr><td>MAC OS X (BSD)<td>iOS<tr><td>LINUX<td>Symbian<tr><td>…<td>…</table></div><h2 id="os-elements"><span class="me-2">OS Elements</span><a href="#os-elements" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li><strong>Abstractions</strong> (corresponds to applications that OS executes)<ul><li>process, thread, file, socket, memory page</ul><li><strong>Mechanisms</strong> (on top of Abstractions)<ul><li>create, schedule, open, write, allocate</ul><li><strong>Policies</strong> (how mechanisms are used to manage underlying hardware)<ul><li>Least Recently Used (LRU) , Earliest Deadline First (EDF), etc.</ul></ul><h4 id="example-"><span class="me-2">Example :</span><a href="#example-" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p><em>Memory Management:</em></p><ul><li><strong>Abstractions</strong>: Memory page<li><strong>Mechanisms</strong>: Allocate, map to a process<li><strong>Policies</strong>: LRU</ul><h2 id="os-design-principles"><span class="me-2">OS Design Principles</span><a href="#os-design-principles" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>Seperation of mechanism and policy<ul><li>implement flexible mechanisms to support many policies<li>e.g. LRU, LFU, random</ul><li>Optimize for common case<ul><li>Where will the OS be used?<li>What will the user want to execute on that machine?<li>What are the workload requirements?</ul></ul><h2 id="user-kernel-protection-boundary"><span class="me-2">User/ Kernel Protection Boundary</span><a href="#user-kernel-protection-boundary" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>user-level =&gt; applications [underprivileged mode]<li>kernel-level =&gt; OS Kernel [privileged access, hardware access]</ul><p><a href="https://spcdn.pages.dev/blog/os/userkernelprotectionboundary.png" class="popup img-link shimmer"><img src="https://spcdn.pages.dev/blog/os/userkernelprotectionboundary.png" alt="userkernelprotectionboundary" loading="lazy"></a></p><ul><li>User-Kernel switch is supported by hardware.<ul><li>using trap instructions<li>system calls like: - open (file)<ul><li>send (socket)<li>malloc (memory)</ul><li>signals</ul></ul><h2 id="system-call-flowcart"><span class="me-2">System call Flowcart</span><a href="#system-call-flowcart" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><a href="https://spcdn.pages.dev/blog/os/systemcallflowchart.png" class="popup img-link shimmer"><img src="https://spcdn.pages.dev/blog/os/systemcallflowchart.png" alt="systemcallflowchart" loading="lazy"></a></p><ul><li>To make a system call, an application must:<ul><li>write arguments<li>save relevant data ast well defined location<li>make system calls using system call number</ul><li>In synchronous mode : wait until system call completes.</ul><h2 id="basic-os-services"><span class="me-2">Basic OS services</span><a href="#basic-os-services" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>process management<li>file management<li>device management<li>memory management<li>storage management<li>security</ul><h2 id="linux-system-calls"><span class="me-2">Linux System Calls</span><a href="#linux-system-calls" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><div class="table-wrapper"><table><thead><tr><th>Task<th>Commands<tbody><tr><td>Process Control<td>fork (); exit(); wait();<tr><td>File Manipulation<td>open(); read(); write();<tr><td>Device Manipulation<td>ioctl(); read(); write();<tr><td>Information Maintenance<td>getpid(); alarm(); sleep();<tr><td>Communication<td>pipe(); shmget(); mmap();<tr><td>Protection<td>chmod(); umask(); chown();</table></div><h2 id="linux-architecture"><span class="me-2">Linux Architecture</span><a href="#linux-architecture" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><a href="https://spcdn.pages.dev/blog/os/linuxarch.png" class="popup img-link shimmer"><img src="https://spcdn.pages.dev/blog/os/linuxarch.png" alt="linuxarchitecture" loading="lazy"></a></p><hr /><h1 id="process-and-process-management">Process and Process Management</h1><p><strong>Process</strong>: Instance of an executing program.</p><ul><li>State of execution<ul><li>program counter, stack pointer</ul><li>Parts and temporary holding area<ul><li>data, register state, occupies state in memory</ul><li>May require special hardware<ul><li>I/O devices</ul></ul><p>Process is a state of a program when executing and loaded in memory (active state) as opposed to application (static state).</p><h2 id="what-does-a-process-look-like"><span class="me-2">What does a process look like?</span><a href="#what-does-a-process-look-like" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><a href="https://spcdn.pages.dev/blog/os/process.png" class="popup img-link shimmer"><img src="https://spcdn.pages.dev/blog/os/process.png" alt="Process" loading="lazy"></a></p><h3 id="type-of-state"><span class="me-2">Type of state</span><a href="#type-of-state" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>Text and Data<ul><li>static state when process loads first</ul><li>Heap<ul><li>dynamically created during execution</ul><li>Stack<ul><li>grows and shrinks<li>LIFO queue (used to store task checkpoints to resume the original process after switching from another.)</ul></ul><h2 id="how-does-the-os-know-what-a-process-is-doing"><span class="me-2">How does the OS know what a process is doing?</span><a href="#how-does-the-os-know-what-a-process-is-doing" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Using:</p><ul><li>Program counter<li>CPU registers<li>Stack pointer</ul><h2 id="process-control-block-pcb"><span class="me-2">Process Control Block (PCB)</span><a href="#process-control-block-pcb" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><a href="https://spcdn.pages.dev/blog/os/pcb.png" class="popup img-link shimmer"><img src="https://spcdn.pages.dev/blog/os/pcb.png" alt="PCB" loading="lazy"></a></p><ul><li>PCB created when process is created<li>Certain fields are updated when process state change e.g. memory mapping<li>or other fields that change very frequently e.g. Program Counter</ul><h2 id="how-is-pcb-used-"><span class="me-2">How is PCB used ?</span><a href="#how-is-pcb-used-" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><a href="https://spcdn.pages.dev/blog/os/howpcbisused.png" class="popup img-link shimmer"><img src="https://spcdn.pages.dev/blog/os/howpcbisused.png" alt="howpcbisused" loading="lazy"></a></p><h2 id="context-switch"><span class="me-2">Context Switch</span><a href="#context-switch" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li><p>Mechanism used to switch from the context of one process to another in the CPU.</p><li><p>They are expensive!</p><ul><li>direct costs: no of cycles for load and store instructions.<li>indirect costs: <strong>COLD</strong> cache (read more <a href="http://stackoverflow.com/questions/22756092/what-does-it-mean-by-cold-cache-and-warm-cache-concept">here</a>)<ul><li>Therefore limit frequency how context switching is done.</ul></ul></ul><p>When a cache is <strong>HOT</strong>, most process data is in the cache so the process performance will be at its best.</p><p>Sometimes there are situations where we have to Context Switch (higher priority process, timesharing, etc.)</p><h2 id="process-lifecycle"><span class="me-2">Process Lifecycle</span><a href="#process-lifecycle" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><a href="https://spcdn.pages.dev/blog/os/processlifecycle.png" class="popup img-link shimmer"><img src="https://spcdn.pages.dev/blog/os/processlifecycle.png" alt="processlifecycle" loading="lazy"></a></p><p>CPU is able to execute a process when the process is in Running or Ready state.</p><h2 id="process-creation"><span class="me-2">Process Creation</span><a href="#process-creation" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h4 id="mechanisms"><span class="me-2">Mechanisms:</span><a href="#mechanisms" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>fork :<ul><li>copies the parent PCB into new child PCB<li>child contains execution at instruction after fork</ul><li>exec :<ul><li>replace child image<li>load new program and start from first instruction</ul></ul><h2 id="what-is-the-role-of-cpu-scheduler"><span class="me-2">What is the role of CPU scheduler?</span><a href="#what-is-the-role-of-cpu-scheduler" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>CPU scheduler determines which one of the currently ready processes will be dispatched to the CPU to start running, and how long it should run for.</p><p>OS must :</p><ul><li>preempt =&gt; interrupt and save current context<li>schedule =&gt; run scheduler to choose next process<li>dispatch =&gt; dispatch process 2 switch into its context</ul><h2 id="scheduling-design-decisions"><span class="me-2">Scheduling design decisions</span><a href="#scheduling-design-decisions" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><a href="https://spcdn.pages.dev/blog/os/timeslice.png" class="popup img-link shimmer"><img src="https://spcdn.pages.dev/blog/os/timeslice.png" alt="timeslice" loading="lazy"></a></p><ul><li>What are the appropriate timeslice values?<li>Metrics to choose next process to run?</ul><h2 id="io"><span class="me-2">I/O</span><a href="#io" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>A process can make way in the ready queue in a number of ways.</p><p><a href="https://spcdn.pages.dev/blog/os/io.png" class="popup img-link shimmer"><img src="https://spcdn.pages.dev/blog/os/io.png" alt="io" loading="lazy"></a></p><h2 id="can-process-interact"><span class="me-2">Can process interact?</span><a href="#can-process-interact" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h4 id="inter-process-communication"><span class="me-2">Inter Process communication:</span><a href="#inter-process-communication" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>IPC mechanisms:</p><ul><li>transfer data/info between address space<li>maintain protection and isolation<li>provide flexibility and performance</ul><p>Two types of IPC models:</p><h4 id="1-message-passing-ipc"><span class="me-2">1. <strong>Message Passing IPC</strong></span><a href="#1-message-passing-ipc" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p><a href="https://spcdn.pages.dev/blog/os/messagepassing.png" class="popup img-link shimmer"><img src="https://spcdn.pages.dev/blog/os/messagepassing.png" alt="messagepassing" loading="lazy"></a></p><ul><li>OS provides communication channel line shared buffer<li>Processes can write(send), read(receive) msg to/from channel</ul><p><strong>Advantages</strong>: OS manages the channel<br /> <strong>Disadvantages</strong>: Overheads</p><h4 id="2-shared-memory-ipc"><span class="me-2">2. <strong>Shared Memory IPC</strong></span><a href="#2-shared-memory-ipc" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p><a href="https://spcdn.pages.dev/blog/os/sharedmemory.png" class="popup img-link shimmer"><img src="https://spcdn.pages.dev/blog/os/sharedmemory.png" alt="sharedmemory" loading="lazy"></a></p><ul><li>OS establishes a shared channel and maps it into each processes’ address space<li>Processes directly write(send), read(receive) msg to/from this memory</ul><p><strong>Advantages</strong>: OS is out of the way after establishing the shared channel<br /> <strong>Disadvantages</strong>: Re-implementing a lot of code that could have been done by the OS</p><p>Overall, <strong>shared memory</strong> based communication is better if mapping memory between two processes is ammortized over a large number of messages.</p><hr /><h1 id="threads-and-concurrency">Threads and Concurrency</h1><p><strong>Thread</strong>:</p><ul><li>is an active<ul><li>entity executing unit of a process</ul><li>works simultaneously with others<ul><li>many threads execute together</ul><li>requires coordination<ul><li>sharing of I/O devices, CPUs, memory</ul></ul><h2 id="process-vs-thread"><span class="me-2">Process vs Thread</span><a href="#process-vs-thread" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><a href="https://spcdn.pages.dev/blog/os/processvthread.png" class="popup img-link shimmer"><img src="https://spcdn.pages.dev/blog/os/processvthread.png" alt="processvthread" loading="lazy"></a></p><h2 id="why-are-threads-useful"><span class="me-2">Why are threads useful?</span><a href="#why-are-threads-useful" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>Parallelization =&gt; Speedup<li>Specialization =&gt; Hot cache<li>Efficiency =&gt; lower memory requirement &amp; cheaper IPC<li>Time for context switch in threads is less, since memory is shared, hence mapping is not required between virtual and physical memory.<ul><li>Therefore multithreading can be used to hide latency.</ul><li>Benefits to both applicatioons and OS code<ul><li>Multithreaded OS kernel<ul><li>threads working on behalf of applications<li>OS level services like daemons and drivers</ul></ul></ul><h2 id="what-do-we-need-to-support-threads"><span class="me-2">What do we need to support threads?</span><a href="#what-do-we-need-to-support-threads" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>Threads data structure<ul><li>Identify threads, keep track of resource usage..</ul><li>Mechanisms to create and manage threads<li>Mechanisms to safely coordinate among threads running concurrently in the same address space</ul><h2 id="concurrency-control-and-coordination"><span class="me-2">Concurrency control and Coordination</span><a href="#concurrency-control-and-coordination" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>Mutual exclusion<ul><li>Exclusive access to only one thread at a time<li><strong>mutex</strong></ul><li>Waiting on other threads<ul><li>Specific condition before proceeding<li><strong>condition variable</strong></ul><li>Waking up other threads from wait state</ul><h2 id="threads-and-threads-creation"><span class="me-2">Threads and Threads creation</span><a href="#threads-and-threads-creation" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>Thread data structure:<ul><li>Thread type, Thread ID, PC, SP, registers, stack, attributes.</ul><li><strong>Fork</strong>(proc, args)<ul><li>create a thread<li>not UNIX fork</ul></ul><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>t1 = fork(proc, args)   
</pre></table></code></div></div><ul><li><strong>Join</strong>(thread)<ul><li>terminate a thread</ul></ul><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>child_result = join(t1)   
</pre></table></code></div></div><h3 id="example"><span class="me-2">Example:</span><a href="#example" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>Thread  t1;
Shared_List list;
t1 = fork(safe_insert, 4);
safe_insert(6);
join(t1); //Optional
</pre></table></code></div></div><p>The list can be accessed by reading shared variable.</p><h2 id="mutual-exclusion"><span class="me-2">Mutual Exclusion</span><a href="#mutual-exclusion" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>Mutex data structure:<ul><li>locked?, owner, blocked_threads</ul></ul><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>lock(mutex){
	//Critical Section
    //Only one thread can access at a time
}
unlock(mutex)
</pre></table></code></div></div><p><a href="https://spcdn.pages.dev/blog/os/mutex.png" class="popup img-link shimmer"><img src="https://spcdn.pages.dev/blog/os/mutex.png" alt="mutex" loading="lazy"></a></p><h2 id="producer-consumer-problem"><span class="me-2">Producer Consumer problem</span><a href="#producer-consumer-problem" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>What if the processing you wish to perform with mutual exclusion needs to occur under certai conditions?</p><p>For e.g. The producer appends items to a list until the list is full, and the consumer has to print out all the items of the list once the list if full and then empty the list. Thus we have to execute the Consumer thread only under a certain condition (here- when the list becomes empty, print items).</p><p>Solution: Use <strong>Condition Variables</strong></p><ul><li>Wait(mutex, condition)<ul><li>mutex is automatically released and reaquired on wait<li>The consumer applies <em>Wait</em> until the list is full</ul><li>Signal(condition)<ul><li>Notify only one thread waiting on condition<li>The Producer applies <em>Signal</em> to the Consumer thread when the list is full</ul><li>Broadcast(condition)<ul><li>Notify all waiting threads</ul></ul><p><a href="https://spcdn.pages.dev/blog/os/producerconsumer.png" class="popup img-link shimmer"><img src="https://spcdn.pages.dev/blog/os/producerconsumer.png" alt="producerconsumer" loading="lazy"></a></p><h2 id="readers--writer-problem"><span class="me-2">Readers / Writer problem</span><a href="#readers--writer-problem" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>0 or more readers can access a resource<li><p>0 or 1 writer can write the resource concurrently at the same time</p><li>One solution:<ul><li>lock on resource - good for writer - too restrictive for readers</ul><li>Better solution:</ul><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre>if ((read_count == 0) &amp; (read_count == 0))
	R okay, W okay
if (read_count &gt; 0)
	R okay    
if (read_count == 1)
	R not-okay, W not-okay    
</pre></table></code></div></div><p>State of shared resource:</p><ul><li>free : resource_counter = 0<li>reading : resource_counter &gt; 0<li>writing : resource_counter = -1</ul><p>Thus essentially we can apply mutex on the new proxy ‘resource_counter’ variable that represents the state of the shared resource.</p><h2 id="avoiding-common-mistakes"><span class="me-2">Avoiding common mistakes</span><a href="#avoiding-common-mistakes" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>keep track of mutex/lock variable used with a resource<ul><li>e.g. mutex_type m1; // mutex for file1</ul><li>check that you are always and correctly using lock and unlock - Compilers can be used as they generate errors/warnings to correct this type of mistake<li>Use a single mutex to access a single resource<li>check that you are signalling correct condition<li>check that you are not using signal when broadcast is needed<ul><li>signal : only 1 thread is will proceed, remaining threads will wait</ul><li>check thread execution order to be controlled by signals to condition variables</ul><h2 id="spuriousunnecessary-wake-ups"><span class="me-2">Spurious(Unnecessary) Wake ups</span><a href="#spuriousunnecessary-wake-ups" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>When we wake up threads knowing they may not be able to proceed.</p><h2 id="deadlocks"><span class="me-2">Deadlocks</span><a href="#deadlocks" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Two or more competing threads are said to be in a deadlock if they are waiting on each other to complete, but none of them ever do.</p><p><a href="https://spcdn.pages.dev/blog/os/deadlock.png" class="popup img-link shimmer"><img src="https://spcdn.pages.dev/blog/os/deadlock.png" alt="deadlock" loading="lazy"></a></p><p>Here T1 and T2 are in deadlock.</p><h3 id="how-to-avoid-this"><span class="me-2">How to avoid this?</span><a href="#how-to-avoid-this" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ol><li>Unlock T1 before locking T2<ul><li>Fine-grained locking but T1 nad T2 may both be required</ul><li>Use one mega lock, get all locks upfront, then release at end<ul><li>For some applications this may be ok. But generally its too restrictive and limits parallelism</ul><li>Maintain lock order<ul><li>first m_T1<li>then m_T2 - this will prevent cycles in wait graph</ul></ol><p>A cycle in wait graph is necessary and sufficient for deadlock to occur.<br /> (thread-waiting-on-resource —edge—&gt; thread-owning-resource)</p><ul><li><p>Deadlock prevention =&gt; Expensive<br /> Pre-check for cycles and then delay process or change code</p><li><p>Deadlock Detection and Recovery =&gt; Rollback</p></ul><h2 id="kernel-vs-user-level-threads"><span class="me-2">Kernel vs User level Threads</span><a href="#kernel-vs-user-level-threads" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><a href="https://spcdn.pages.dev/blog/os/kernelvuserthread.png" class="popup img-link shimmer"><img src="https://spcdn.pages.dev/blog/os/kernelvuserthread.png" alt="kernelvuserthread" loading="lazy"></a></p><p>Three types of models:</p><h4 id="1-one-to-one-model"><span class="me-2">1. <strong>One to One model</strong>:</span><a href="#1-one-to-one-model" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p><a href="https://spcdn.pages.dev/blog/os/onetoone.png" class="popup img-link shimmer"><img src="https://spcdn.pages.dev/blog/os/onetoone.png" alt="onetoone" loading="lazy"></a></p><p><strong>Advantages</strong>:</p><ul><li>OS sees threads<li>Synchronization<li>Blocking</ul><p><strong>Disadvantages</strong>:</p><ul><li>Must go to OS for all operations<li>OS may have limits on policies, threads<li>Portability</ul><h4 id="2-many-to-one-model"><span class="me-2">2. <strong>Many to One model</strong>:</span><a href="#2-many-to-one-model" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p><a href="https://spcdn.pages.dev/blog/os/manytoone.png" class="popup img-link shimmer"><img src="https://spcdn.pages.dev/blog/os/manytoone.png" alt="manytoone" loading="lazy"></a></p><p><strong>Advantages</strong>:</p><ul><li>Totally Portable<li>Doesn’t depend on OS limits and policies</ul><p><strong>Disadvantages</strong>:</p><ul><li>OS may block entire process if one user-level thread blocks on I/O</ul><h4 id="3-many-to-many-model"><span class="me-2">3. <strong>Many to Many model</strong>:</span><a href="#3-many-to-many-model" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p><a href="https://spcdn.pages.dev/blog/os/manytomany.png" class="popup img-link shimmer"><img src="https://spcdn.pages.dev/blog/os/manytomany.png" alt="manytomany" loading="lazy"></a></p><p><strong>Advantages</strong>:</p><ul><li>Best of both worlds<li>Can have bound or unbound threads</ul><p><strong>Disadvantages</strong>:</p><ul><li>Requires coordination between user and kernel level thread managers</ul><h2 id="multithreading-patterns"><span class="me-2">Multithreading patterns</span><a href="#multithreading-patterns" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><strong>1. Boss-Workers pattern</strong></p><ul><li>Boss- assigns work<li>Workers- perform entire task</ul><p>Throughput of system is limited by boss thread. Hence boss thread must be kept efficient.</p><p>Throughput = 1/boss-time-orders</p><p>Boss assigns works by:</p><ol><li>Directly signalling specific works<ul><li><strong>+</strong> workers don’t need to sync<li><strong>-</strong> boss must keep track of everyone</ul><li>Placing work in queue<ul><li><strong>+</strong> boss doesn’t neeed to know details about workers<li><strong>-</strong> queue synchronization</ul></ol><p>How many workers?</p><ul><li>on demand<li>pool of workers<li>static vs dynamic (i.e dynamically increasing size according to work)</ul><p><strong>Advantages</strong>:</p><ul><li>Simplicity</ul><p><strong>Disadvantages</strong>:</p><ul><li>Thread pool management<li>Locality</ul><p><strong>1B. Boss-Workers pattern variant</strong></p><ul><li>Here workers are specialized for certain tasks opposite to the previous equally created workers</ul><p><strong>Advantages</strong>:</p><ul><li>Better locality<li>Quality of Service management</ul><p><strong>Disadvantages</strong>:</p><ul><li>Load balancing</ul><p><strong>2. Pipeline pattern</strong></p><ul><li>Threads assigned one subtask in the system<li>Entire task = Pipeline of threads<li>Multiple tasks concurrently run in the system, in different pipeline stages<li>Throughput depends on weakest link<li>Shared buffer based communication between stages</ul><p><strong>3. Layered pattern</strong></p><ul><li>Layers of threads are assigned group of related subtasks<li>End to end task must pass up and down through all layers</ul><p><strong>Advantages</strong>:</p><ul><li>Specialization<li>Less fine-grained than pipeline</ul><p><strong>Disadvantages</strong>:</p><ul><li>Not suitable for all applications<li>Synchronization</ul><h3 id="example-1"><span class="me-2">Example:</span><a href="#example-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><strong>Q)</strong> For 6 step toy order application we have 2 solutions:</p><ol><li>Boss-workers solution<li>Pipeline solution</ol><p>Both have 6 threads. In the boss-workers solution, a worker produces a toy order in 120 ms. In the pipeline solution, each of 6 stages take 20 ms.</p><p>How long will it take for these solutions to complete 10 toy orders and 11 toy orders?</p><p><strong>A)</strong> 6 threads means for Boss-workers, 1 thread is for boss, 5 for workers. In pipeline 6 threads are equally used.</p><p>For 10 toy orders:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>Boss-workers(10) = 120 + 120 = 240 ms
Pipeline(10) = 120 + (9*20) = 300 ms
</pre></table></code></div></div><p>Here Boss-workers is better than Pipeline.</p><p>For 11 toy orders:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>Boss-workers(11) = 120 + 120 + 120 = 360 ms
Pipeline(11) = 120 + (10*20) = 320 ms
</pre></table></code></div></div><p>Here Pipeline is better than Boss-workers.</p><p>This proves that choosing a better pattern depends on the number of threads and the work required to be done.</p><h2 id="pthreads"><span class="me-2">PThreads</span><a href="#pthreads" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>PThreads == POSIX Threads</p><p>POSIX = Portable OS interface</p><h3 id="compiling-pthreads"><span class="me-2">Compiling PThreads</span><a href="#compiling-pthreads" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ol><li>#include<pthread.h> in main file</pthread.h><li>Compile source with -lpthread or -pthread<div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>gcc -o main main.c -lpthread
gcc -o main main.c -pthread
</pre></table></code></div></div><li>Check return values of common examples</ol><h3 id="pthread-mutexes"><span class="me-2">PThread mutexes</span><a href="#pthread-mutexes" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>to solve mutual exclusion problems among concurrent threads</ul><h3 id="safety-tips"><span class="me-2">Safety tips</span><a href="#safety-tips" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>Shared data should always be accessed through single mutex<li>Mutex scope must be visible to all<li>Globally order locks<ul><li>for all threads, lock mutexes in order</ul><li>Always unlock a mutex (correctly)</ul><h2 id="thread-design-considerations"><span class="me-2">Thread Design Considerations</span><a href="#thread-design-considerations" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="kernel-vs-user-level-threads-1"><span class="me-2">Kernel vs User Level Threads</span><a href="#kernel-vs-user-level-threads-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><a href="https://spcdn.pages.dev/blog/os/userlevelvkernellevel.png" class="popup img-link shimmer"><img src="https://spcdn.pages.dev/blog/os/userlevelvkernellevel.png" alt="userlevelvkernellevel" loading="lazy"></a></p><h3 id="thread-related-data-structures"><span class="me-2">Thread related data structures</span><a href="#thread-related-data-structures" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><a href="https://spcdn.pages.dev/blog/os/threadds.png" class="popup img-link shimmer"><img src="https://spcdn.pages.dev/blog/os/threadds.png" alt="threadds" loading="lazy"></a></p><h3 id="hard-vs-light-process-states"><span class="me-2">Hard vs Light Process states</span><a href="#hard-vs-light-process-states" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>PCB is divided into multiple data structures classified as follows:</p><ul><li>Light Process states<ul><li>Signal mask<li>System call args</ul><li>Heavy Process states<ul><li>virtual address mapping</ul></ul><h4 id="rationale-for-multiple-data-structures"><span class="me-2">Rationale for Multiple Data Structures:</span><a href="#rationale-for-multiple-data-structures" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><div class="table-wrapper"><table><thead><tr><th>Single PCB<th>Multiple DS<tbody><tr><td>Large continuos DS<td>Smaller DS<tr><td>Private for each entity<td>Easier to share<tr><td>Saved and restored on each context switch<td>Save and Restore only what needs to change on context switch<tr><td>Update for any changes<td>User lever library need to only update portion of the state</table></div><ul><li>Thus the following disadvantages for single PCB become advantages for Multiple DS :<ul><li>Scalability<li>Overheads<li>Performance<li>Flexibility</ul></ul><h2 id="comparison-of-interrupts-and-signals"><span class="me-2">Comparison of Interrupts and Signals</span><a href="#comparison-of-interrupts-and-signals" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>Handled in specific ways - interrupt and signal handlers<ul><li>Can be ignored<ul><li>interrupt and signal mask</ul><li>Expected or unexpected<ul><li>appear synchronously or asynchronously</ul></ul><li>Difference:</ul><div class="table-wrapper"><table><thead><tr><th>Interrupts<th>Signals<tbody><tr><td>Events generated externally by components other than CPU (I/O devices, timers, other CPUs)<td>Events triggered by CPU and software running on it<tr><td>Determined based on physical platform<td>Determined based on OS<tr><td>Appear asynchronously<td>Appear synchronously or asynchronously</table></div><ul><li>Similarities:<ul><li>Have a unique ID depending on h/w or OS<li>Can be masked and disabled/suspended via corresponding mask - per-CPU interrupt mask, preprocess signal mask<li>if enabled, trigger corresponding to handler <br /> - interrupt handler set for entire system by OS<ul><li>signal handler set on per process basis by process</ul></ul></ul><blockquote><p>An interrupt is like a snowstorm alarm<br /> A signal is like a low battery warning</p></blockquote><h3 id="interrupts"><span class="me-2">Interrupts</span><a href="#interrupts" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><a href="https://spcdn.pages.dev/blog/os/interrupts.png" class="popup img-link shimmer"><img src="https://spcdn.pages.dev/blog/os/interrupts.png" alt="interrupts" loading="lazy"></a></p><h3 id="signals"><span class="me-2">Signals</span><a href="#signals" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><a href="https://spcdn.pages.dev/blog/os/signals.png" class="popup img-link shimmer"><img src="https://spcdn.pages.dev/blog/os/signals.png" alt="signals" loading="lazy"></a></p><h4 id="handlers--actions"><span class="me-2">Handlers / Actions</span><a href="#handlers--actions" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>Default actions<ul><li>Terminate, ignore<li>Terminate and core dump<li>Stop or continue</ul><li>Process Installs Handler<ul><li>signal(), sigaction()<li>for most signals, some cannot be “caught”</ul><li><strong>Synchronous</strong><ul><li>SIGSEGV (access to protected memory)<li>SIGFPE (divided by zero)<li>SIGKILL (kill, id) - can be directed to a specific thread</ul><li><strong>Asynchronous</strong>*<ul><li>SIGKILL (kill)<li>SIGALARM<h3 id="why-disable-interrupts-or-signals"><span class="me-2">Why disable Interrupts or Signals</span><a href="#why-disable-interrupts-or-signals" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></ul></ul><p><a href="https://spcdn.pages.dev/blog/os/disableis.png" class="popup img-link shimmer"><img src="https://spcdn.pages.dev/blog/os/disableis.png" alt="disableis" loading="lazy"></a></p><p>Here PC: First instruction in handler<br /> SP : thread stack</p><p>To prevent deadlock,</p><ol><li>Keep handler code simple<ul><li>avoid mutex<li><strong>-</strong> too restrictive</ul><li>Control interruptions by handler code<ul><li>Use interrupt/signal masks<li>0011100110.. (0: disabled, 1: enabled)</ul></ol><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre>clear_field_in_mask(mask)
lock(mutex)
{

#disabled =&gt; remaining pending

}
unlock(mutex)
reset_field_in_mask(mask)

#enabled =&gt; execute handler code
</pre></table></code></div></div><ul><li>Interrupt masks are per CPU<ul><li>if mask disables interrupt, hardware interrupt rounting mechanism will not deliver interrupt</ul><li>Signal are per execution context (User-level thread on top of Kernel-level thread)<ul><li>if mask disables signal, kernel sees mask and will not interrupt corresponding thread</ul></ul><h3 id="types-of-signals"><span class="me-2">Types of Signals</span><a href="#types-of-signals" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ol><li>One-shot Signals<ul><li>“n signals pending == 1 signal pending” : atleast once<li>must be explicitly re-enabled</ul><li>Realtime Signals<ul><li>“if n signals raised, then handler is called n times”</ul></ol><h3 id="handling-interrupts-as-threads"><span class="me-2">Handling interrupts as threads</span><a href="#handling-interrupts-as-threads" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><a href="https://spcdn.pages.dev/blog/os/interruptsasthreads.png" class="popup img-link shimmer"><img src="https://spcdn.pages.dev/blog/os/interruptsasthreads.png" alt="interruptsasthreads" loading="lazy"></a></p><p>but dynamic thread creation is expensive!</p><ul><li>Dynamic decision<ul><li>if handler doesn’t lock - execute on interrupted threads stack<li>if handler can block - turn into real thread</ul><li>Optimization<ul><li>pre-create and pre-initialize thread structure for interrupt routines</ul></ul><h3 id="threads-and-signal-handling"><span class="me-2">Threads and Signal Handling</span><a href="#threads-and-signal-handling" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><a href="https://spcdn.pages.dev/blog/os/tshandling.png" class="popup img-link shimmer"><img src="https://spcdn.pages.dev/blog/os/tshandling.png" alt="tshandling" loading="lazy"></a></p><p><strong>Case 1 :</strong></p><ul><li>User-Level-Thread mask = 1<li>Kernel-Level-Thread mask = 1</ul><p><a href="https://spcdn.pages.dev/blog/os/case1.png" class="popup img-link shimmer"><img src="https://spcdn.pages.dev/blog/os/case1.png" alt="case1" loading="lazy"></a></p><p><strong>Case 2 :</strong></p><ul><li>User-Level-Thread mask = 0<li>Kernel-Level-Thread mask = 1<li>another User-Level-Thread mask = 1</ul><p><a href="https://spcdn.pages.dev/blog/os/case2.png" class="popup img-link shimmer"><img src="https://spcdn.pages.dev/blog/os/case2.png" alt="case2" loading="lazy"></a></p><p><strong>Case 3 :</strong></p><ul><li>User-Level-Thread mask = 0<li>Kernel-Level-Thread mask = 1<li>another User-Level-Thread mask = 1<li>another Kernel-Level-Thread mask = 1</ul><p><a href="https://spcdn.pages.dev/blog/os/case3.png" class="popup img-link shimmer"><img src="https://spcdn.pages.dev/blog/os/case3.png" alt="case3" loading="lazy"></a></p><p><strong>Case 4 :</strong></p><ul><li>User-Level-Thread mask = 0<li>Kernel-Level-Thread mask = 1<li>all User-Level-Thread mask = 0</ul><p><a href="https://spcdn.pages.dev/blog/os/case4.png" class="popup img-link shimmer"><img src="https://spcdn.pages.dev/blog/os/case4.png" alt="case4" loading="lazy"></a></p><p><strong>Optimize common case</strong></p><ul><li>signals less frequennt than signal mask updates<li>system calls avoided<ul><li>cheaper to update user-level mask</ul><li>signal handling more expensive</ul><h2 id="multi-processing-vs-multi-threading"><span class="me-2">Multi-processing vs Multi-threading</span><a href="#multi-processing-vs-multi-threading" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>How to best provide concurrency?</p><h3 id="multi-processing-mp"><span class="me-2">Multi-Processing (MP)</span><a href="#multi-processing-mp" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><strong>Advantages</strong><br /></p><ul><li>Simple programming</ul><p><strong>Disadvantages</strong><br /></p><ul><li>High memory usage<li>Costs context switch<li>costly to maintain shared state (tricky port setup)</ul><h3 id="multi-threading-mp"><span class="me-2">Multi-Threading (MP)</span><a href="#multi-threading-mp" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><strong>Advantages</strong><br /></p><ul><li>Shared address space<li>Shared state (no sys calls to other threads)<li>Cheap context switch</ul><p><strong>Disadvantages</strong><br /></p><ul><li>Complex implementation<li>Requires synchronization<li>Requires underlying support for threads</ul><h2 id="event-driven-model"><span class="me-2">Event Driven model</span><a href="#event-driven-model" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><a href="https://spcdn.pages.dev/blog/os/eventdrivenmodel.png" class="popup img-link shimmer"><img src="https://spcdn.pages.dev/blog/os/eventdrivenmodel.png" alt="eventdrivenmodel" loading="lazy"></a></p><p>Features:</p><ul><li>Single address space<li>Single process<li>Single thread of control</ul><p>Dispatcher : acts as a state machine and accepts any external events</p><p>When call handler =&gt; jump to code</p><p>The handler:</p><ul><li>Runs to completion<li>if they need to block<ul><li>initiate blocking operation and pass control to dispatch loop</ul></ul><h3 id="concurrent-execution-in-event-driven-models"><span class="me-2">Concurrent execution in Event-driven models</span><a href="#concurrent-execution-in-event-driven-models" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>MP &amp; MT : 1 request per execution context (process/thread)<li>Event Driven : Many requests interleaved in an execution context<li>Single thread switches among processing of different requests<li>Process requests until wait is necessary<ul><li>then switch to another request</ul></ul><p><strong>Advantages</strong><br /></p><ul><li>Single address space<li>Single flow of control<li>Smaller memory requirement<ul><li>Event Driven model requires less memory than Boss-workers/Pipeline model, where the extra memory is required for helper thread for concurrent blocking I/O not for all concurrent requests.</ul><li>No context switches<li>No synchronization</ul><p><strong>Disadvantages</strong><br /></p><ul><li>A blocking request/handler will block entire process</ul><h3 id="asynchronous-io-operations"><span class="me-2">Asynchronous I/O operations</span><a href="#asynchronous-io-operations" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Asynchronous I/O operations fit well with Event-driven models</p><p>Since asynchronous calls are not easily avalible, helpers can be used to implement the async call functionality:</p><ul><li>designated for blocking I/O operations only<li>pipe/socket based communication with event dispatcher<ul><li>select()/ poll() still okay</ul><li>helper blocks, but main event loop (&amp; process) will not</ul><h3 id="asymmetric-multi-process-event-driven-model-amped--amted"><span class="me-2">Asymmetric Multi-Process Event Driven model (AMPED &amp; AMTED)</span><a href="#asymmetric-multi-process-event-driven-model-amped--amted" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><strong>Advantages</strong><br /></p><ul><li>Resolve portability limitations of basic event driven model<li>Smaller footprint than regular worker thread</ul><p><strong>Disadvantages</strong><br /></p><ul><li>Applicability to certain classes of applications<li>Event routing on multi CPU systems</ul><p>Eg <a href="https://en.wikipedia.org/wiki/Apache_HTTP_Server">Apache Web Server</a></p><p><a href="https://spcdn.pages.dev/blog/os/apachewebserver.png" class="popup img-link shimmer"><img src="https://spcdn.pages.dev/blog/os/apachewebserver.png" alt="apachewebserver.png" loading="lazy"></a></p><ul><li>Core : basic server skeleton<li>Modules : per functionality<li>Flow of Control : Similar to Event Driven model<li>But its an combination of MP + MT,<ul><li>each process = boss/worker with dynamic thread pool<li>number of processes can also be dynamically adjusted</ul></ul><hr /><h1 id="scheduling">Scheduling</h1><p>Operating System perform scheduling in the following simple ways:</p><ul><li>Dispatch orders immediately<ul><li>scheduling is simple FIFO (First-Come-First-Serve)</ul><li>Dispatch simple orders first<ul><li>maximize number of orders processed over time<li>maximize throughput (SJF)</ul><li>Dispatch complex orders first<ul><li>maximize utilization of CPU, devices, memory</ul></ul><h2 id="cpu-scheduler"><span class="me-2">CPU Scheduler</span><a href="#cpu-scheduler" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>Decides how and when process (and their threads) access shared CPUs<li>Schedules tasks running at user level processes/threads as well as kernel level threads<li>Chooses one of the ready tasks to run on CPU<li>Runs when<ul><li>CPU becomes idle<li>new task becomes ready<li>timeslice expired timeout</ul></ul><p>Context switch, enter user mode, set PC and go! &lt;= Thread is dispatched on CPU.</p><ul><li>Which task should be selected?<ul><li>Scheduling policy/algorithm</ul><li>How is this done?<ul><li>Depends on runqueue data structure</ul></ul><h3 id="run-to-completion-scheduling"><span class="me-2">“Run-to-completion” Scheduling</span><a href="#run-to-completion-scheduling" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>Initial assumptions<ul><li>group of tasks/jobs<li>known execution time<li>no preemption<li>single CPU</ul><li>Metrics<ul><li>throughput<li>average job completion time<li>average job wait time<li>CPU utilization</ul></ul><h2 id="scheduling-algorithms"><span class="me-2">Scheduling algorithms:</span><a href="#scheduling-algorithms" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="1-first-come-first-serve-fcfs"><span class="me-2">1. First Come First Serve (FCFS)</span><a href="#1-first-come-first-serve-fcfs" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>Schedules tasks in order of arrival</ul><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>runqueue = queue(FIFO)
</pre></table></code></div></div><p>If T1, T2, T3 arrive in the given order and T1 has execution time 1s, T2 10s and T3 1s then :</p><ul><li>Throughput = 3/(1+10+1) = 3/12 = 0.25s<li>Average completion time = (1 + 11 + 12)/3 = 8s<li>Average wait time = (1+1+11)/3 = 4s<li>Starvation NOT possible</ul><h3 id="2-shortest-job-first-sjf"><span class="me-2">2. Shortest Job First (SJF)</span><a href="#2-shortest-job-first-sjf" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>Schedules tasks in order of execution time<li>Therefore for the above example, T1(1s) &gt; T3(1s) &gt; T2(10s)<li>Starvation possible</ul><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>runqueue = ordered(queue)

//or

runqueue = tree()
</pre></table></code></div></div><p>For SJF,</p><ul><li>Throughput = 3/(1+10+1) = 3/12 = 0.25s<li>Average completion time = (1 + 2 + 12)/3 = 5s<li>Average wait time = (0+1+2)/3 = 1s</ul><h3 id="preemptive-scheduling"><span class="me-2">Preemptive Scheduling</span><a href="#preemptive-scheduling" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>SJF + Preemption<li>Starvation is possible</ul><p>T2 arrives first.</p><p><a href="https://spcdn.pages.dev/blog/os/preemptive.png" class="popup img-link shimmer"><img src="https://spcdn.pages.dev/blog/os/preemptive.png" alt="preemptive" loading="lazy"></a></p><h3 id="priority-scheduling"><span class="me-2">Priority Scheduling</span><a href="#priority-scheduling" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>Tasks have different priority levels<li>Run highest priority task next (preemption)<li>Starvation is possible</ul><p><a href="https://spcdn.pages.dev/blog/os/priority.png" class="popup img-link shimmer"><img src="https://spcdn.pages.dev/blog/os/priority.png" alt="priority" loading="lazy"></a></p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>runqueue = per priority_queue()

//or 

runqueue = tree() ordered on priority
</pre></table></code></div></div><ul><li>low priority task stuck in runqueue =&gt; starvation<li>“priority aging”<ul><li>priority = f(actual priority, time spent in runqueue)<li>eventually tasks will run<li>prevents starvation</ul></ul><h3 id="3-round-robin-scheduling"><span class="me-2">3. Round-Robin Scheduling</span><a href="#3-round-robin-scheduling" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>Pick up the first task from queue (like FCFS)<li>Task may yield to wait on I/O (unlike FCFCS)<li>Starvation is NOT possible</ul><p><a href="https://spcdn.pages.dev/blog/os/rr1.png" class="popup img-link shimmer"><img src="https://spcdn.pages.dev/blog/os/rr1.png" alt="rr1" loading="lazy"></a></p><p><a href="https://spcdn.pages.dev/blog/os/rr2.png" class="popup img-link shimmer"><img src="https://spcdn.pages.dev/blog/os/rr2.png" alt="rr2" loading="lazy"></a></p><p><a href="https://spcdn.pages.dev/blog/os/rr3.png" class="popup img-link shimmer"><img src="https://spcdn.pages.dev/blog/os/rr3.png" alt="rr3" loading="lazy"></a></p><h3 id="4-shortest-remaining-time-first-srtf"><span class="me-2">4. Shortest Remaining Time First (SRTF)</span><a href="#4-shortest-remaining-time-first-srtf" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>Chooses the process with the shortest CPU burst remaining and executes that one. If processes come in during execution that have less remaining time, the current one is preempted and the new one executed. Therefore, it can lead to starvation.</ul><h4 id="timeslicing"><span class="me-2">Timeslicing</span><a href="#timeslicing" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>Timeslice = max amount of uninterrupted time given to a task<li>task may run less than timeslice<ul><li>has to wait on I/O sync - will be placed on queue<li>higher priority task becomes runnable</ul><li>using timeslice tasks are interleaved<ul><li>timesharing the CPU<li>CPU bound tasks =&gt; preemption after timeslice</ul></ul><p><a href="https://spcdn.pages.dev/blog/os/rr4.png" class="popup img-link shimmer"><img src="https://spcdn.pages.dev/blog/os/rr4.png" alt="rr4" loading="lazy"></a></p><p><strong>Advantages</strong><br /></p><ul><li>Short tasks finish sooner<li>More responsive<li>Lengthy I/O operations initiated sooner<ul><li>best to keep timeslice &gt; context-switch-time</ul></ul><p><strong>Disdvantages</strong><br /></p><ul><li>Overheads</ul><h4 id="how-long-should-a-timeslice-be-be"><span class="me-2">How long should a timeslice be be?</span><a href="#how-long-should-a-timeslice-be-be" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>should balance benefits and overheads</ul><h3 id="for-cpu-bound-tasks"><span class="me-2">For CPU bound tasks:</span><a href="#for-cpu-bound-tasks" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><a href="https://spcdn.pages.dev/blog/os/cputs.png" class="popup img-link shimmer"><img src="https://spcdn.pages.dev/blog/os/cputs.png" alt="cputs" loading="lazy"></a></p><ul><li>Hence, for CPU bound tasks, larger timeslice values are better</ul><h3 id="for-io-bound-tasks"><span class="me-2">For I/O bound tasks:</span><a href="#for-io-bound-tasks" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><a href="https://spcdn.pages.dev/blog/os/iots.png" class="popup img-link shimmer"><img src="https://spcdn.pages.dev/blog/os/iots.png" alt="iots" loading="lazy"></a></p><ul><li>Hence, for I/O bound tasks, smaller timeslice values are better<ul><li>Keeps CPU and I/P devices busy, I/O bound tasks run quickly, makes I/O requests responds to a user.</ul></ul><h3 id="summary"><span class="me-2">Summary</span><a href="#summary" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>CPU bound tasks prefer longer timeslices<ul><li>limits context switching overheads<li>keeps CPU utilization and throughput</ul><li>I/O bound tasks prefer smaller timeslices<ul><li>However, if all the tasks in contention are I/O bound, it may not make such a difference<li>If a portion of them are I/O smaller timeslices keeps CPU and device utilization high<li>Provides better user-perceived performance</ul></ul><hr /><h1 id="memory-management">Memory Management</h1><p>Operating systems:</p><ul><li>uses intelligently size containers<ul><li>memory pages of segments</ul><li>Not all parts are needed at once<ul><li>tasks operate on subset of memory</ul><li>Optimized for performance<ul><li>reduce time to access state in memory - leads to better performance!</ul></ul><h2 id="memory-management-goals"><span class="me-2">Memory Management Goals</span><a href="#memory-management-goals" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><a href="https://spcdn.pages.dev/blog/os/mmgoals.png" class="popup img-link shimmer"><img src="https://spcdn.pages.dev/blog/os/mmgoals.png" alt="mmgoals.png" loading="lazy"></a></p><h4 id="virtual-vs-physical-memory"><span class="me-2">Virtual vs Physical memory</span><a href="#virtual-vs-physical-memory" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>Allocate<ul><li>allocation, replacement</ul><li>Arbitrate<ul><li>address translation and validation</ul></ul><h4 id="page-based-memory-management"><span class="me-2">Page-based Memory Management</span><a href="#page-based-memory-management" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>Allocate =&gt; pages =&gt; page frames<li>Arbitrate =&gt; page tables</ul><h4 id="segment-based-memory-management"><span class="me-2">Segment-based Memory Management</span><a href="#segment-based-memory-management" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>Allocate =&gt; segments<li>Arbitrate =&gt; segment registers</ul><h2 id="hardware-support"><span class="me-2">Hardware Support</span><a href="#hardware-support" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><a href="https://spcdn.pages.dev/blog/os/hardwaresupport.png" class="popup img-link shimmer"><img src="https://spcdn.pages.dev/blog/os/hardwaresupport.png" alt="hardwaresupport.png" loading="lazy"></a></p><h3 id="memory-management-unit-mmu"><span class="me-2">Memory Management Unit (MMU)</span><a href="#memory-management-unit-mmu" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>translate virtual to physical address<li>reports faults (illegal access, permission, not present in memory)</ul><h3 id="registers"><span class="me-2">Registers</span><a href="#registers" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>pointers to page tables<li>base and limit size, number of segments</ul><h3 id="cache"><span class="me-2">Cache</span><a href="#cache" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>Translation lookaside buffer<li>Valid VA-PA translations using TLB</ul><h3 id="translation"><span class="me-2">Translation</span><a href="#translation" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>Actual PA generation done in hardware</ul><h2 id="page-tables"><span class="me-2">Page Tables</span><a href="#page-tables" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><a href="https://spcdn.pages.dev/blog/os/pagetables.png" class="popup img-link shimmer"><img src="https://spcdn.pages.dev/blog/os/pagetables.png" alt="pagetables.png" loading="lazy"></a></p><ul><li>OS creates page table per process<li>On context switch, switch to valid page table<li>Updates register that points to correct page table. E.g CR3 on x86 architecture</ul><h2 id="page-table-entry-pte"><span class="me-2">Page Table Entry (PTE)</span><a href="#page-table-entry-pte" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><a href="https://spcdn.pages.dev/blog/os/pfn.png" class="popup img-link shimmer"><img src="https://spcdn.pages.dev/blog/os/pfn.png" alt="pfn.png" loading="lazy"></a></p><h4 id="flags"><span class="me-2">Flags</span><a href="#flags" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>Present (valid/invalid)<li>Dirty (written to)<li>Accessed (for read or write)<li>Protection bits =&gt; RWX</ul><h2 id="page-table-entry-on-x86"><span class="me-2">Page Table Entry on x86</span><a href="#page-table-entry-on-x86" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><a href="https://spcdn.pages.dev/blog/os/pfnx86.png" class="popup img-link shimmer"><img src="https://spcdn.pages.dev/blog/os/pfnx86.png" alt="pfnx86.png" loading="lazy"></a></p><h4 id="flags-1"><span class="me-2">Flags</span><a href="#flags-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>Present<li>Dirty<li>Accessed<li>R/W permission bit 0: R only, 1: R/W<li>U/S permission bit 0: usermode, 1: superviser mode only<li>others: caching related info (write through, caching disabled)<li>unused: for future use</ul><h2 id="page-faults"><span class="me-2">Page faults</span><a href="#page-faults" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><a href="https://spcdn.pages.dev/blog/os/pagefaults.png" class="popup img-link shimmer"><img src="https://spcdn.pages.dev/blog/os/pagefaults.png" alt="pagefaults.png" loading="lazy"></a></p><h2 id="page-table-size"><span class="me-2">Page Table Size</span><a href="#page-table-size" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><a href="https://spcdn.pages.dev/blog/os/pts.png" class="popup img-link shimmer"><img src="https://spcdn.pages.dev/blog/os/pts.png" alt="pts.png" loading="lazy"></a></p><ul><li>32 bit architecture<ul><li>Page Table Entry (PTE) = 4 Bytes, including PFN + flags<li>Virtual Page Number (VPN) = 2^32/page_size<li>Page size = 4KB (…8KB, 2MB, 4MB, 1GB)</ul></ul><p>Therefore Page Table Size = (2^32 * 2^12)*4B = 4MB (per process)</p><ul><li>for 64 bit architecture<ul><li>Page Table Entry (PTE) = 8 Bytes<li>Page size = 4KB</ul></ul><p>Page Table Size = (2^64 * 2^12)*8B = 32PB (per process!)</p><ul><li>processes don’t use entire address space<li>even on 32 bit architecture, it will not always use all 4GB</ul><p>But Page Table assumes an entry per VPN regardless, of whether corresponding virtual memory is needed or not.</p><h2 id="hierarchical-page-tables"><span class="me-2">Hierarchical Page Tables</span><a href="#hierarchical-page-tables" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><a href="https://spcdn.pages.dev/blog/os/hierarchicalpt.png" class="popup img-link shimmer"><img src="https://spcdn.pages.dev/blog/os/hierarchicalpt.png" alt="hierarchicalpt.png" loading="lazy"></a></p><p>On malloc, a new internal page table may be allocated.</p><h4 id="address-split"><span class="me-2">Address split:</span><a href="#address-split" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><div class="table-wrapper"><table><tr><th colspan="2">Page Number<th>offset<tr><td>P1<td>P2<td>d<tr><td>12<td>10<td>10</table></div><ul><li>inner table addresses =&gt; 2^10 * page_size = 2^10*2^10 = 1MB<li>don’t need an inner table for each 1MB virtual memory gap</ul><p>Additional Layers</p><ul><li>page table directory pointer (3rd level)<li><p>page table directory map (4th level)</p><li>Important on 64 bit architectures<li>larger and more sparse =&gt; larger gaps would save more internal page table components</ul><p><a href="https://spcdn.pages.dev/blog/os/hierarchicalpt2.png" class="popup img-link shimmer"><img src="https://spcdn.pages.dev/blog/os/hierarchicalpt2.png" alt="hierarchicalpt2.png" loading="lazy"></a></p><h3 id="tradeoffs-of-multilevel-page-tables"><span class="me-2">Tradeoffs of Multilevel Page Tables</span><a href="#tradeoffs-of-multilevel-page-tables" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><strong>Advantages</strong><br /></p><ul><li>Smaller internal page tables/directories<li>Granularity of coverage<ul><li>Potentially reduced page table size</ul></ul><p><strong>Disadvantages</strong><br /></p><ul><li>More memory accesses required for translation<li>increased translation latency</ul><h2 id="overheads-of-address-translation"><span class="me-2">Overheads of Address Translation</span><a href="#overheads-of-address-translation" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>For each memory reference :</p><div class="table-wrapper"><table><thead><tr><th>Single level page table<th>Four level page table<tbody><tr><td>x1 access to PTE<td>x4 accesses to PTE<tr><td>x1 access to mem<td>x1 access to mem</table></div><p>which results in slowdown.</p><h2 id="page-table-cache"><span class="me-2">Page Table Cache</span><a href="#page-table-cache" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><a href="https://spcdn.pages.dev/blog/os/ptcache.png" class="popup img-link shimmer"><img src="https://spcdn.pages.dev/blog/os/ptcache.png" alt="ptcache.png" loading="lazy"></a></p><h4 id="translation-lookaside-buffer"><span class="me-2">Translation Lookaside Buffer</span><a href="#translation-lookaside-buffer" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>MMU level address translation cache<li>On TLB miss =&gt; page table access from memory<li>has protection/validity bits<li>small number of cached address =&gt; high TLB hit rate<ul><li>temporal and spatial locality</ul><li>Example<ul><li>x86 Core i7 - per core : 64-entry data TLB <br /> 128-entry instruction TLB<ul><li>512-entry shared second-level TLB</ul></ul></ul><h3 id="inverted-page-tables"><span class="me-2">Inverted Page Tables</span><a href="#inverted-page-tables" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><a href="https://spcdn.pages.dev/blog/os/invertedpt.png" class="popup img-link shimmer"><img src="https://spcdn.pages.dev/blog/os/invertedpt.png" alt="invertedpt.png" loading="lazy"></a></p><h3 id="hashing-page-tables"><span class="me-2">Hashing Page Tables</span><a href="#hashing-page-tables" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><a href="https://spcdn.pages.dev/blog/os/hashingpt.png" class="popup img-link shimmer"><img src="https://spcdn.pages.dev/blog/os/hashingpt.png" alt="hashingpt.png" loading="lazy"></a></p><h2 id="segmentation"><span class="me-2">Segmentation</span><a href="#segmentation" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Segmentation is the process of mapping virtual to physical memory using segments.</p><ul><li>Segments: arbitrary granularity (size)<ul><li>e.g. code, heap, data, stack..<li>address = segment - selector + offset</ul><li>Segment<ul><li>contiguous physical memory<li>segment size = segment base + limit registers</ul></ul><p><a href="https://spcdn.pages.dev/blog/os/segmentation.png" class="popup img-link shimmer"><img src="https://spcdn.pages.dev/blog/os/segmentation.png" alt="segmentation.png" loading="lazy"></a></p><h4 id="segmentation--paging"><span class="me-2">Segmentation + Paging</span><a href="#segmentation--paging" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p><a href="https://spcdn.pages.dev/blog/os/segmentationpaging.png" class="popup img-link shimmer"><img src="https://spcdn.pages.dev/blog/os/segmentationpaging.png" alt="segmentationpaging.png" loading="lazy"></a></p><h2 id="page-size"><span class="me-2">Page Size</span><a href="#page-size" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>10 bit offset =&gt; 1 KB page size [2^10]<li>12 bit offset =&gt; 4 KB page size [2^12]</ul><p>In real world examples,</p><ul><li>Linux/x86 : 4 KB, 2MB, 1GB<li>Solaris/Sparse: 8kB, 4MB, 2GB</ul><div class="table-wrapper"><table><thead><tr><th> <th>Large<th>Huge<tbody><tr><td>page size<td>2 MB<td>1 GB<tr><td>offset bits<td>21 bits<td>30 bits<tr><td>reduction factor on page table size<td>x512<td>x1024</table></div><p><strong>Advantages</strong><br /></p><ul><li>larger pages<ul><li>fewer page table entries, smaller page tables, more TLB hits</ul></ul><p><strong>Disadvantages</strong><br /></p><ul><li>internal fragmentation =&gt; wastes memory</ul><h2 id="memory-allocation"><span class="me-2">Memory Allocation</span><a href="#memory-allocation" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>Memory allocator<ul><li>determines VA to PA mapping<li>address translation, page tables =&gt; simply determine PA from VA and check validity/permsissions</ul><li>Kernel Level Allocators<ul><li>kernel state, static process state</ul><li>User Level Allocators<ul><li>dynamic process state (heap), malloc/free<li>e.g. d/malloc, jemalloc, Hoard, tcmalloc</ul></ul><h2 id="demand-paging"><span class="me-2">Demand Paging</span><a href="#demand-paging" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>Virtual Memory » Physical Memory<ul><li>virtual memory page is not always in physical memory<li>physical page frame saved and restored to/from secondary storage</ul></ul><h3 id="demand-paging-1"><span class="me-2">Demand paging:</span><a href="#demand-paging-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>pages swapped in/out of memory &amp; a swap partition (e.g. on a disk)</ul><p><a href="https://spcdn.pages.dev/blog/os/demandpaging.png" class="popup img-link shimmer"><img src="https://spcdn.pages.dev/blog/os/demandpaging.png" alt="demandpaging.png" loading="lazy"></a></p><ul><li>Original PA != PA after swapping<ul><li>if page is “pinned”, swapping is disabled</ul></ul><h4 id="when-pages-should-be-swapped"><span class="me-2">When pages should be swapped?</span><a href="#when-pages-should-be-swapped" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>page(out) daemon<li>when memory usage is above threshold<li>when CPU usage is below threshold</ul><h4 id="which-page-should-be-swapped-out"><span class="me-2">Which page should be swapped out?</span><a href="#which-page-should-be-swapped-out" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>pages that won’t be used<li>history based prediction<ul><li>Least Recently Used (LRU policy). Access bit tracks if page is referenced.</ul><li>page that don’t need to be written out<ul><li>Dirty bit to track if modified</ul><li>avoid non-swappable pages</ul><h2 id="checkpointing"><span class="me-2">Checkpointing</span><a href="#checkpointing" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>Failure and Recovery management technique<ul><li>periodically save process state<li>failure may be unavoidable but can restart from checkpoint, so recovery would be faster</ul></ul><h4 id="simple-approach"><span class="me-2">Simple Approach</span><a href="#simple-approach" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>pause and save</ul><h4 id="better-approach"><span class="me-2">Better Approach</span><a href="#better-approach" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>write-protect and copy everything at once<li>copy diffs of dirties pages for incremental checkpoints<ul><li>rebuild from multiple diffs, or in background</ul></ul><p>Checkpointing can also be used in other services:</p><ul><li>Debugging<ul><li>Rewind-Replay<li>rewind = restart from checkpoint<li>gradually go back to earlier checkpoints until error is found</ul><li>Migration<ul><li>continue on another machine<li>disaster recovery<li>consolidation<li>repeated checkpoints in a fast loop until pause and copy becomes acceptable (or unavoidable)</ul></ul><hr /><h1 id="inter-process-communication-1">Inter Process Communication</h1><ul><li>Processes share memory<ul><li>data in shared messages</ul><li>Processes exchange messages<ul><li>message passing via sockets</ul><li>Requires synchronization<ul><li>mutex, waiting</ul></ul><p><strong>Inter Process Communication</strong>(IPC) is an OS supported mechanism for interaction among processes (coordination and communication)</p><ul><li>Message Passing<ul><li>e.g. sockets, pips, msgs, queues</ul><li>Memory based IPC<ul><li>shared memory, memory mapped files</ul><li>Higher level semantics<ul><li>files, <a href="10-Remote-Procedure-Calls.md">RPC</a></ul><li>Synchronization primitives</ul><h2 id="message-passing"><span class="me-2">Message Passing</span><a href="#message-passing" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>Send/Receive messages<li>OS creates and maintains a channel<ul><li>buffer, FIFO queue</ul><li>OS provides interfaces to processes<ul><li>a port<li>processes send/write messages to this port<li>processes receive/read messages from this port</ul></ul><p><a href="https://spcdn.pages.dev/blog/os/messagepassingipc.png" class="popup img-link shimmer"><img src="https://spcdn.pages.dev/blog/os/messagepassingipc.png" alt="messagepassingipc.png" loading="lazy"></a></p><ul><li>Kernel required to<ul><li>establish communication<li>perform each IPC operation<li>send: system call + data copy<li>receive: system call + data copy</ul><li>Request-response: 4x user/ kernel crossings + <br /> 4x data copies</ul><p><strong>Advantages</strong><br /></p><ul><li>simplicity : kernel does channel management and synchronization</ul><p><strong>Disadvantages</strong><br /></p><ul><li>Overheads</ul><h3 id="forms-of-message-passing-ipc"><span class="me-2">Forms of Message Passing IPC</span><a href="#forms-of-message-passing-ipc" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h4 id="1-pipes"><span class="me-2">1. Pipes</span><a href="#1-pipes" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>Carry byte stream between 2 process<li>e.g connect output from 1 process to input of another</ul><p><a href="https://spcdn.pages.dev/blog/os/pipes.png" class="popup img-link shimmer"><img src="https://spcdn.pages.dev/blog/os/pipes.png" alt="pipes.png" loading="lazy"></a></p><h4 id="2-message-queues"><span class="me-2">2. Message queues</span><a href="#2-message-queues" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>Carry “messages” among processes<li>OS management includes priorities, scheduling of message delivery<li>APIs : Sys-V and POSIX</ul><p><a href="https://spcdn.pages.dev/blog/os/msgq.png" class="popup img-link shimmer"><img src="https://spcdn.pages.dev/blog/os/msgq.png" alt="msgq.png" loading="lazy"></a></p><h4 id="3-sockets"><span class="me-2">3. Sockets</span><a href="#3-sockets" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>send() and recv() : pass message buffers<li>socket() : create kernel level socket buffer<li>associated neccessary kernel processing (TCP-IP,..)<li>If different machines, channel between processes and network devices<li>If same machine, bypass full protocol stack</ul><p><a href="https://spcdn.pages.dev/blog/os/sockets.png" class="popup img-link shimmer"><img src="https://spcdn.pages.dev/blog/os/sockets.png" alt="sockets.png" loading="lazy"></a></p><h2 id="shared-memory-ipc"><span class="me-2">Shared Memory IPC</span><a href="#shared-memory-ipc" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>read and write to shared memory region<li>OS establishes shared channel between the processes<ol><li>physical pages mapped into virtual address space<li>VA(P1) and VA(P2) map to same physical address<li>VA(P1) != VA(P2)<li>physical mempry doesn’t need to be contiguous</ol><li>APIs : SysV, POSIX, memory mapped files, Android ashmem</ul><p><a href="https://spcdn.pages.dev/blog/os/sharedmemoryipc.png" class="popup img-link shimmer"><img src="https://spcdn.pages.dev/blog/os/sharedmemoryipc.png" alt="sharedmemoryipc.png" loading="lazy"></a></p><p><strong>Advantages</strong><br /></p><ul><li>System calls only for setup data copies potentially reduced (but not eliminated)</ul><p><strong>Disdvantages</strong><br /></p><ul><li>explicit synchronization<li>communication protocol, shared buffer management<ul><li>programmer’s responsibility</ul></ul><h2 id="which-is-better"><span class="me-2">Which is better?</span><a href="#which-is-better" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><strong>Overheads for</strong></p><ol><li>Message Passing : must perform multiple copies<li>Shared Memory : must establish all mappings among processes’ address space and shared memory pages</ol><p>Thus, it depends.</p><h2 id="copy-vs-map"><span class="me-2">Copy vs Map</span><a href="#copy-vs-map" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Goal for both is to transfer data from one into target saddress space</p><div class="table-wrapper"><table><thead><tr><th>Copy (Message Passing)<th>Map (Shared Memory)<tbody><tr><td>CPU cycles to copy data to/from port<td>CPU cycles to map memory into address space<tr><td> <td>CPU to copy data to channel<tr><td> <td>If channel setup once, use many times (good payoff)<tr><td> <td>Can perform well for 1 time use</table></div><ul><li>Large Data: t(Copy) » t(Map)<ul><li>e.g. tradeoff exercised in Window “Local” Procedure Calls (LPC)</ul></ul><h2 id="shared-memory-and-synchronization"><span class="me-2">Shared Memory and Synchronization</span><a href="#shared-memory-and-synchronization" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Use threads accessing shared state in a single addressing space, but for process</p><p>Synchronization method:</p><ol><li>mechanism supported by processing threading library (pthreads)<li>OS supported IPC for sync</ol><p>Either method must coordinate</p><ul><li>no of concurrent access to shared segment<li>when data is available and ready for consumption</ul><h3 id="ipc-synchronization"><span class="me-2">IPC Synchronization</span><a href="#ipc-synchronization" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="table-wrapper"><table><thead><tr><th>Message Queues<th>Semaphores<tbody><tr><td>Implement “mutual exclusion” via send/receive<td>OS supported synchronization construct<tr><td> <td>binary construct (either allow process or not)<tr><td> <td>Like mutex, if value = 0, stop; if value = 1, decrement(lock) and proceed</table></div><hr /><h1 id="synchronization">Synchronization</h1><p>Waiting for other processes, so that they can continue working together</p><ul><li>may repeatedly check to continue<ul><li>sync using spinlocks</ul><li>may wait for a signal to continue<ul><li>sync using mutexes and condition vatiables</ul><li>waiting hurts performance<ul><li>CPUs wste cycles for checking; cache effects</ul></ul><h2 id="limitation-of-mutextes-and-condition-variables"><span class="me-2">Limitation of mutextes and condition variables</span><a href="#limitation-of-mutextes-and-condition-variables" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>Error prone/correctness/ease of use<ul><li>unlock wrong mutex, signal wrong condition variable</ul><li>Lack of expressive power<ul><li>helper variables for access or priority control</ul></ul><p>Low-level support: hardware atmoic instructions</p><h2 id="synchronization-constructs"><span class="me-2">Synchronization constructs</span><a href="#synchronization-constructs" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ol><li>Spinlocks (basic sync construct)<ul><li>Spinlock is like a mutex - mutual exclusion<ul><li>lock and unlock(free)<li>but, lock == busy =&gt; spinning</ul></ul><li>Semaphores<ul><li>common sync construct in OS kernels<li>like a traffic light: Stop and Go<li>like mutex, but more general</ul></ol><p>Semaphore == integer value</p><ul><li>on init<ul><li>assigned a max value (positive int) =&gt; max count</ul><li>on try(wait)<ul><li>if non-zero, decrement and proceed =&gt; counting semaphore</ul><li>if initialized with 1<ul><li>semaphore == mutex(binary semaphore)</ul><li>on exit(post)<ul><li>increment</ul></ul><h2 id="syncing-different-types-of-accesses"><span class="me-2">Syncing different types of accesses</span><a href="#syncing-different-types-of-accesses" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="readerwriter-locks"><span class="me-2">Reader/Writer locks</span><a href="#readerwriter-locks" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="table-wrapper"><table><tr><td>read (don't modify)<td>write (always modify)<tr><td>shared access<td>exclusive access</table></div><ul><li>RW locks<ul><li>specify type of access, then lock behaves accordingly</ul></ul><h3 id="monitors-highlevel-construct"><span class="me-2">Monitors (highlevel construct)</span><a href="#monitors-highlevel-construct" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>shared resource<li>entry resource<li>possible condition variables<li>On entry:<ul><li>lock, check</ul><li>On exit:<ul><li>unlock, check, signal</ul></ul><h3 id="more-synchroniaztion-constructs"><span class="me-2">More synchroniaztion constructs</span><a href="#more-synchroniaztion-constructs" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>serializers<li>path expressions<li>barriers<li>rendezvous points<li>optimistic wait-free sync (RCU) [Read Copy Update]</ul><p>All need hardware support.</p><h2 id="need-for-hardware-support"><span class="me-2">Need for hardware support</span><a href="#need-for-hardware-support" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>Problem<ul><li>concurrent check/update on different CPUs can overlap</ul></ul><h3 id="atomic-instructions"><span class="me-2">Atomic instructions</span><a href="#atomic-instructions" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Critical section with hardware supported synchronization</p><h4 id="hardware-specific"><span class="me-2">Hardware specific</span><a href="#hardware-specific" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>test-and-set<ul><li>returns(tests) original values and sets new-value!= 1 (busy) automatically<li>first thread: test-and-set(lock) =&gt; 0 : free<li>next ones: test-and-set(lock) =&gt; 1 busy - reset lock to 1, but that’s okay<li><strong>+</strong> : Latency<li><strong>+</strong> : minimal (Atomic)<li><strong>+</strong> : Delay potentially min<li><strong>-</strong> : Contention processors go to memory on each spin - To reduce contention, introduce delay - Static(based on a fixed value) or Dynamic(backoff based, random delay)</ul><li>read-and-increment<li>compare-and-swap</ul><h4 id="guarantees"><span class="me-2">Guarantees</span><a href="#guarantees" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>atomicity<li>mutual exclusion<li>queue all concurrent instructions but one</ul><h3 id="shared-memory-multiprocessors"><span class="me-2">Shared Memory Multiprocessors</span><a href="#shared-memory-multiprocessors" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Also called symmetric multiprocessors (SMP)</p><p><a href="https://spcdn.pages.dev/blog/os/sharedmmmp.png" class="popup img-link shimmer"><img src="https://spcdn.pages.dev/blog/os/sharedmmmp.png" alt="sharedmmmp" loading="lazy"></a></p><ul><li>Caches<ul><li>hide memory latency, “memory” further away due to contention<li>no-write, write-through, write-back</ul></ul><h3 id="cache-coherence"><span class="me-2">Cache Coherence</span><a href="#cache-coherence" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><a href="https://spcdn.pages.dev/blog/os/cachecoherence.png" class="popup img-link shimmer"><img src="https://spcdn.pages.dev/blog/os/cachecoherence.png" alt="cachecoherence" loading="lazy"></a></p><p><a href="https://spcdn.pages.dev/blog/os/cachecoherence2.png" class="popup img-link shimmer"><img src="https://spcdn.pages.dev/blog/os/cachecoherence2.png" alt="cachecoherence2" loading="lazy"></a></p><hr /><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre># I/O Management
</pre></table></code></div></div><p>Operating system</p><ul><li>Has protocols<ul><li>Interfaces for device I/O</ul><li>Has dedicated handlers<ul><li>Device drivers, interrupt handlers</ul><li>Decouple I/O details from core processing<ul><li>abstract I/O device detail from applications</ul></ul><h2 id="io-device-features"><span class="me-2">I/O Device Features</span><a href="#io-device-features" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>Control registers (accessed by CPU)<ul><li>Command<li>Data Transfers<li>Status</ul><li>Microcontroller : device’s CPU<li>On device memory<li>Other logic<ul><li>e.g. analog to digital</ul></ul><h2 id="device-drivers"><span class="me-2">Device drivers</span><a href="#device-drivers" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>per each device type<li>responsible for device access management and control<li>provided by device manufacturers per OS /version<li>each OS standardizes interfaces<ul><li>device independence<li>device diversity</ul></ul><h2 id="types-of-devices"><span class="me-2">Types of devices</span><a href="#types-of-devices" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>Block<ul><li>e.g. disk<li>read/write blocks of data<li>direct access to arbitrary block</ul><li>Character<ul><li>e.g. keyboard<li>get/put character</ul><li>Network devices</ul><p>OS representation of a device : special device file</p><p>UNIX like systems:</p><ul><li>/dev<li>tmpfs<li>devfs</ul><p>Linux supports a number of pseudo “virtual” devices that provide special functionality to a system.</p><h2 id="cpu-device-interactions"><span class="me-2">CPU device interactions</span><a href="#cpu-device-interactions" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><a href="https://spcdn.pages.dev/blog/os/iointeractions.png" class="popup img-link shimmer"><img src="https://spcdn.pages.dev/blog/os/iointeractions.png" alt="iointeractions.png" loading="lazy"></a></p><p>access device registers : memory load/store</p><ol><li>Memory mapped I/0<ul><li>part of ‘host’ physical memory dedicated for device interactions<li>Base Address Registers (BAR)</ul><li>I/O Port<ul><li>dedicated in low instructions for device access<li>target device (I/0 port) and value in register</ul></ol><h2 id="path-from-device-to-cpu"><span class="me-2">Path from Device to CPU</span><a href="#path-from-device-to-cpu" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ol><li>Interrupt<ul><li>Overhead: Interrupt handling steps<li>+: Can be generated as soon as possible</ul><li>Polling<ul><li>Overhead: Delay or CPU overhead<li>when convenient for OS</ul></ol><h2 id="device-access--programmed-io-pio"><span class="me-2">Device access : Programmed I/O (PIO)</span><a href="#device-access--programmed-io-pio" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>No additional hardware support<li>CPU “programs” the device<ul><li>via command registers<li>data movement</ul><li>E.g. NIC(Network Interface Card)<ul><li>data = network packet</ul><li>Write command to request packet information<li>Copy packet to data registers<li>Repeat until packet sent</ul><p>E.g. 1500B packet; 8 byte registers or bus =&gt; 1(for bus command) + 188(for data) = 189 CPU store instructions</p><h2 id="direct-memory-access-dma"><span class="me-2">Direct Memory Access (DMA)</span><a href="#direct-memory-access-dma" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>Relies on DMA controller<li>CPU “programs” the device<ul><li>via command registers<li>via DMA controls</ul><li>E.g. NIC (data = network packet)<li>Write command to request packet information<li>Configure DMA controller with in memory address and size of packet buffer</ul><p>E.g. 1500B packet; 8 byte registers or bus =&gt; 1(for bus command) + 1(for DMA configuration) = total 2 CPU store instructions. Less steps, but DMA configuration is more complex.</p><p>For DMAs</p><ul><li>data buffer must be in physical memory until transfer completes<li>pinning regions (non-swappable)</ul><h2 id="typical-device-access"><span class="me-2">Typical Device Access</span><a href="#typical-device-access" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><a href="https://spcdn.pages.dev/blog/os/typicaldeviceaccess.png" class="popup img-link shimmer"><img src="https://spcdn.pages.dev/blog/os/typicaldeviceaccess.png" alt="typicaldeviceaccess.png" loading="lazy"></a></p><ul><li>System call<li>In-kernel stack<li>Driver Invocation<li>Device request configuration<li>Device performs request</ul><h3 id="os-bypass"><span class="me-2">OS bypass</span><a href="#os-bypass" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><a href="https://spcdn.pages.dev/blog/os/osbypass.png" class="popup img-link shimmer"><img src="https://spcdn.pages.dev/blog/os/osbypass.png" alt="osbypass.png" loading="lazy"></a></p><ul><li>device registers/data<ul><li>directly available</ul><li>OS configures<ul><li>then gets out of the way</ul><li>“user level driver”<ul><li>in library</ul><li>OS retains coarse-grain control<li>relies on device features<ul><li>sufficient registers<li>demux capability</ul></ul><h2 id="what-happens-to-a-calling-thread"><span class="me-2">What happens to a calling thread?</span><a href="#what-happens-to-a-calling-thread" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><a href="https://spcdn.pages.dev/blog/os/access.png" class="popup img-link shimmer"><img src="https://spcdn.pages.dev/blog/os/access.png" alt="access.png" loading="lazy"></a></p><ul><li>Synchronous I/O operations<ul><li>process blocks</ul><li>Asynchronous I/O operations<ul><li>process continues<li>Later, process checks and retrieves result<li>OR<li>process is notified that operation is completed and results are ready</ul></ul><h2 id="block-device-stack"><span class="me-2">Block Device Stack</span><a href="#block-device-stack" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Block device typical storage for files:</p><p><a href="https://spcdn.pages.dev/blog/os/blockdevicestack.png" class="popup img-link shimmer"><img src="https://spcdn.pages.dev/blog/os/blockdevicestack.png" alt="blockdevicestack.png" loading="lazy"></a></p><ul><li>processes use files =&gt; logical storage unit<li>kernel file system (KFS)<ul><li>where how to find and access file<li>OS specifies interface</ul><li>generic block layer<ul><li>OS standardized block interface</ul><li>Device driver</ul><h2 id="virtual-file-system"><span class="me-2">Virtual File System</span><a href="#virtual-file-system" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><a href="https://spcdn.pages.dev/blog/os/vfs.png" class="popup img-link shimmer"><img src="https://spcdn.pages.dev/blog/os/vfs.png" alt="vfs.png" loading="lazy"></a></p><h3 id="virtual-file-system-abstractions"><span class="me-2">Virtual File System Abstractions</span><a href="#virtual-file-system-abstractions" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>File : Elements on which the VFS operates<li>File Descriptor : OS representation of file<ul><li>open, read, write, send file , lock, close</ul><li>inode : Persistent representation of file “index”<ul><li>list of all data blocks<li>device, permissions, size</ul><li>dentry : Directory entry, corresponding to the single path component,<ul><li>dentry cache</ul><li>super block : file system specific information regarding the File System layout</ul><h3 id="vfs-on-disk"><span class="me-2">VFS on disk</span><a href="#vfs-on-disk" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>File : data blocks on disk<li>inode : track file blocks<ul><li>also resides on disk in some block</ul><li>super block : overall map of disk blocks<ul><li>inode blocks<li>data blocks<li>free blocks</ul></ul><h3 id="inodes"><span class="me-2">Inodes</span><a href="#inodes" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Index of all disk blocks corresponding to a file</p><ul><li>File : identified by inode<li>inode : list of all blocks + other metadata</ul><p><strong>+</strong>: Easy to perform sequential or random access<br /> <strong>-</strong>: Limit on file size</p><h3 id="inodes-with-indirect-pointers"><span class="me-2">Inodes with indirect pointers</span><a href="#inodes-with-indirect-pointers" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>Index of all disk blocks corresponding to a file<li>Index contain:<ul><li>metadata<li>pointers to blocks</ul><li>Direct pointer : Points to data block<ul><li>1 KB per entry</ul><li>Indirect pointer : Points to block of pointers<ul><li>256 KB per entry</ul><li>Double Indirect pointer : Points to block of block of pointers<ul><li>64 MB per entry</ul></ul><p><strong>+</strong>: Small inode =&gt; large file size<br /> <strong>-</strong>: File access slowdown</p><h2 id="disk-access-optimizations"><span class="me-2">Disk access optimizations</span><a href="#disk-access-optimizations" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Reducing file access overheads</p><ol><li>Caching/buffering : reducenumber of disk accesses<ul><li>buffer cache in main menu<li>read/write from cache<li>periodically flush to disk - fsync()</ul><li>I/O scheduling : reduce disk head movement<ul><li>maximize sequential vs random access</ul><li>Prefetching : increases cache hits<ul><li>leverages locality</ul><li>Journaling/logging: reduce random access (ext3, ext4)<ul><li>“describe” write in log : block, offset, value..<li>periodically apply updates to proper disk locations</ul></ol><hr /><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre># Virtualization
</pre></table></code></div></div><p>Virtualization allows concurrent execution of multiple OSs and their applications on the same physical machine.</p><p><a href="https://spcdn.pages.dev/blog/os/virtualization.png" class="popup img-link shimmer"><img src="https://spcdn.pages.dev/blog/os/virtualization.png" alt="virtualization.png" loading="lazy"></a></p><ul><li>Virtual resources : each OS thinks that ot “owns” hardware resources<li>Virtual machine (VM) : OS + applications + virtual resources (guest domain)<li>Virtualization layer : management of physical hardware (virtual machine monitor, hypervisor)</ul><h2 id="defining-virtual-machine"><span class="me-2">Defining Virtual Machine</span><a href="#defining-virtual-machine" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>A Virtual Machine is an efficient, isolated duplicate of the real machine.</p><ul><li>Supported by a Virtual Machine Monitor (VMM):<ol><li>provides environment essentially identical with the original machine<li>programs show only minor decrease in speed at worst<li>VMM is in complete control of the system resources</ol></ul><h2 id="vmm-goals"><span class="me-2">VMM goals</span><a href="#vmm-goals" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>Fidelity<li>Performance<li>Safety and Isolation</ul><h2 id="virtualization-advantages"><span class="me-2">Virtualization advantages</span><a href="#virtualization-advantages" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>consolidation<ul><li>decrease cost, improve manageability</ul><li>migration<ul><li>availibility, reliability</ul><li>security, debugging, support for legacy OS</ul><h2 id="two-main-virtualization-models"><span class="me-2">Two main Virtualization Models:</span><a href="#two-main-virtualization-models" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="1-bare-metal-or-hypervisor-based-type-1"><span class="me-2">1. Bare-metal or Hypervisor based (Type 1)</span><a href="#1-bare-metal-or-hypervisor-based-type-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><a href="https://spcdn.pages.dev/blog/os/hypervisor.png" class="popup img-link shimmer"><img src="https://spcdn.pages.dev/blog/os/hypervisor.png" alt="hypervisor.png" loading="lazy"></a></p><ul><li>VMM (hypervisor) manages all hardware resources abd supports execution of VMs<li>privileged, secure VM to deal with devices (and other configuration and management tasks)<li>Adopted by Xen(Opensource or Citriol Xen Server) and ESX (VMware)</ul><h3 id="1-hosted-type-2"><span class="me-2">1. Hosted (Type 2)</span><a href="#1-hosted-type-2" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><a href="https://spcdn.pages.dev/blog/os/hosted.png" class="popup img-link shimmer"><img src="https://spcdn.pages.dev/blog/os/hosted.png" alt="hosted.png" loading="lazy"></a></p><ul><li>Host owns all hardware<li>Special VMM modle provides hardware interfaces to VMs and deals with VM context switching</ul><h2 id="virtualization-requirements"><span class="me-2">Virtualization requirements</span><a href="#virtualization-requirements" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>Present virtual platform interface to VMs<ul><li>virtualize CPU, memory, devices</ul><li>Provide isolation across VMs<ul><li>preemption, MMU for address translation and validation</ul><li>Protect guest OS from applications<ul><li>can’t run guest OS and applications at same protection level</ul><li>Protect VMs from guest OS<ul><li>can’t run guest OS and VMMs at same protection level</ul></ul><h2 id="hardware-protection-levels"><span class="me-2">Hardware protection levels</span><a href="#hardware-protection-levels" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Commodity hardware has more than two protection levels</p><p><a href="https://spcdn.pages.dev/blog/os/hwprotectionlevels.png" class="popup img-link shimmer"><img src="https://spcdn.pages.dev/blog/os/hwprotectionlevels.png" alt="hwprotectionlevels" loading="lazy"></a></p><ul><li>x86 has 4 protection levels (rings)<ul><li>ring 3 : lowest privilege (applications)<li>ring 1 : OS<li>ring 0 : highest privilege (hypervisor)</ul><li>and 2 protection modes<ul><li>non root : VMs - ring 3 : apps<ul><li>ring 0 : OS</ul><li>root : - ring 0 : hypervisor</ul></ul><h2 id="process-virtualization-trap-and-emulate"><span class="me-2">Process Virtualization (Trap-and-Emulate)</span><a href="#process-virtualization-trap-and-emulate" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>Guest instruments<ul><li>executed directly by hardware<li>for non-privileged operations : hardware speeds =&gt; efficiency<li>for privileged operations : trap to hypervisor</ul><li>Hypervisor determines what needs to be done:<ul><li>if illegal operation : terminate VM<li>if legal operation : emulate the behaviour the guest OS was expecting from the hardware</ul></ul><h2 id="problems-with-trap-and-emulate"><span class="me-2">Problems with Trap-and-Emulate</span><a href="#problems-with-trap-and-emulate" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>17 privileged information do not trao but fail silently<li>Hypervisor doesn’t know, so it doesn’t try to change settings<li>OS doesn’t know, so assumes change was successful</ul><h2 id="binary-translation"><span class="me-2">Binary Translation</span><a href="#binary-translation" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><strong>Goal</strong> : Full Virtualization i.e. guest OS is not modified</p><p><strong>Approach</strong> : Dynamic Binary Translation</p><ol><li>Inspect code blocks to be executed<li>If needed, translate to alternate instruction sequence<ul><li>e.g. to emulate desired behaviour, possibly avoid traps</ul><li>Otherwise run at hardware speeds<ul><li>cache translated blocks to ammortize translation costs</ul></ol><h2 id="paravirtualization"><span class="me-2">Paravirtualization</span><a href="#paravirtualization" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><strong>Goal</strong> : Performance; give up on modified guest OSs</p><p><strong>Approach</strong> : Paravirtualization : modify guest OSs so that</p><ul><li>it knows it is running virtualized<li>it makes explicit calls to hyperisor (hypercalls)<li>hypercalls (~ system calls)<ul><li>package context information<li>specify desired hypercall<li>trap to VMM</ul><li>Xen : opensource hypervisor</ul><h2 id="memory-virtualization"><span class="me-2">Memory virtualization</span><a href="#memory-virtualization" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>Full virtualization<ul><li>all guests expect contiguous physical memory starting at 0<li>virtual vs physical vs machine addresses and page frame numbers<li>still leverages hardware (MMU, TLB..)</ul><li>Option 1<ul><li>guest page table : VA =&gt; PA<li>hypervisor : PA =&gt; MA<li>too expensive!</ul><li>Option 2<ul><li>guest page tables : VA =&gt; PA<li>hypervisor shadow PT : VA =&gt; MA<li>hypervisor maintains consistence - e.g. invalidate on context switch, write protect guest PT to track new mappings</ul><li>Paravirtualized<ul><li>guest aware of virtualization<li>no longer strict requirement on contiguous physical memory starting at 0<li>explicitly registers page tables with hypervisor<li>can “batch” page tables updates to reduce VM exits<li>other optimazations</ul></ul><p>Overheads eliminated or reduced on newer platforms</p><h2 id="device-virtualization"><span class="me-2">Device Virtualization</span><a href="#device-virtualization" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>For CPUs and Memory<ul><li>less diversity, Intruction-Set-Architecture(ISA) level<li>Standardization of interface</ul><li>For Devices<ul><li>high diversity<li>lack of standard specification of device interface and behaviour</ul></ul><h4 id="3-key-models-for-device-virtualization"><span class="me-2">3 key models for Device Virtualization:</span><a href="#3-key-models-for-device-virtualization" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><h3 id="1-pass-through-model"><span class="me-2">1. Pass through model</span><a href="#1-pass-through-model" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Approach: VMM-level-driver configures device access permissions</p><p><a href="https://spcdn.pages.dev/blog/os/passthrough.png" class="popup img-link shimmer"><img src="https://spcdn.pages.dev/blog/os/passthrough.png" alt="passthrough.png" loading="lazy"></a></p><p><strong>Advantages</strong><br /></p><ul><li>VM provided with exclusive and direct (VMM bypass) access to the device</ul><p><strong>Disadvantages</strong><br /></p><ul><li>Device sharing difficult<li>VMM must have exact type of device as what VM expects<li>VM migration tricky</ul><h3 id="2-hypervisor---direct-model"><span class="me-2">2. Hypervisor - Direct model</span><a href="#2-hypervisor---direct-model" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Approach:</p><ul><li>VMM interrupts all device accesses<li>Emulate device operations<ul><li>translate to generic I/O operations<li>traverse VMM-resident I/O stack<li>invoke VMM-resident driver</ul></ul><p><a href="https://spcdn.pages.dev/blog/os/hypervisordirect.png" class="popup img-link shimmer"><img src="https://spcdn.pages.dev/blog/os/hypervisordirect.png" alt="hypervisordirect.png" loading="lazy"></a></p><p><strong>Advantages</strong><br /></p><ul><li>VM decoupled from physical device<li>Sharing, migration, dealing with device specifics</ul><p><strong>Disadvantages</strong><br /></p><ul><li>Latency of device operations<li>Device driver ecosystem complexities in Hypervisor</ul><h3 id="3-split-device-driver-model"><span class="me-2">3. Split Device-Driver model</span><a href="#3-split-device-driver-model" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Approach:</p><ul><li>Device access control split between<li>Emulate device operations<ul><li>front-end driver in guest VM (device API)<li>back-end driver in service VM (or Host)<li>modified guest drivers - i.e. limited to paravirtualized guests</ul></ul><p><a href="https://spcdn.pages.dev/blog/os/splitdevicedriver.png" class="popup img-link shimmer"><img src="https://spcdn.pages.dev/blog/os/splitdevicedriver.png" alt="splitdevicedriver.png" loading="lazy"></a></p><p><strong>Advantages</strong><br /></p><ul><li>Eliminate emulation overhead<li>Allow for better management of shared devices</ul><hr /><h1 id="remote-procedure-calls">Remote Procedure Calls</h1><p>Example : GetFile App</p><ul><li>Client Server<li>Create and init sockets<li>Allocate and populate buffers<li>Include ‘protocol’ info<ul><li>GetFile, size</ul><li>Copy data into buffers<ul><li>filename, file</ul><li>common steps related to remote IPC</ul><h4 id="remote-procedure-calls-rpc"><span class="me-2">Remote Procedure Calls (RPC)</span><a href="#remote-procedure-calls-rpc" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>Intended to simplify the development of cross address space and cross machine interactions</ul><p><strong>+</strong> Higher-level interface for data movement and communication<br /> <strong>+</strong> Error handling<br /> <strong>+</strong> Hiding complexities of cross machine interactions</p><h2 id="rpc-requirements"><span class="me-2">RPC requirements</span><a href="#rpc-requirements" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><a href="https://spcdn.pages.dev/blog/os/rpcrequirements.png" class="popup img-link shimmer"><img src="https://spcdn.pages.dev/blog/os/rpcrequirements.png" alt="rpcrequirements" loading="lazy"></a></p><ol><li>Client/Server interactions<li>Procedure Call Interface =&gt; RPC<ul><li>sync call semantics</ul><li>Type checking<ul><li>error handling<li>packet bytes interpretation</ul><li>Cross machine conversion<ul><li>e.g. big/little endian</ul><li>Higher level protocol<ul><li>access control, fault tolerance, different transport protocols</ul></ol><h2 id="structure-of-rpc"><span class="me-2">Structure of RPC</span><a href="#structure-of-rpc" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><a href="https://spcdn.pages.dev/blog/os/rpcstructure.png" class="popup img-link shimmer"><img src="https://spcdn.pages.dev/blog/os/rpcstructure.png" alt="rpcstructure" loading="lazy"></a></p><h2 id="rpc-steps"><span class="me-2">RPC Steps:</span><a href="#rpc-steps" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>(-1.) register : server registers procedure, arg types, location<br /> (0.) bind : client finds and binds to desired server</p><ol><li>call : client make RPC call; control passed to stub, client code blocks<li>marshal : client stub “marshals” args (serialize args into buffer)<li>send : client sends message to server<li>receive : server receives message; passes message to server stub; access control<li>unmarshal : server stub “unmarshals” args (extract args from buffer)<li>actual call : server stub calls local procedure implementation<li>result : server performs operation and computes result of RPC operation</ol><p>(same on return &lt;=)</p><h2 id="interface-definition-language-idl"><span class="me-2">Interface definition Language (IDL)</span><a href="#interface-definition-language-idl" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>Used to describe the interface the server expects<ul><li>procedure name, args, 2 result types<li>version number</ul></ul><p>RPC can use IDL that is</p><ol><li>Language agnostic<ul><li>XDR in SunRPC</ul><li>Language specific<ul><li>Java in JavaRMI</ul></ol><h2 id="marshalling"><span class="me-2">Marshalling</span><a href="#marshalling" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><a href="https://spcdn.pages.dev/blog/os/marshalling.png" class="popup img-link shimmer"><img src="https://spcdn.pages.dev/blog/os/marshalling.png" alt="Marshalling" loading="lazy"></a></p><h2 id="unmarshalling"><span class="me-2">Unmarshalling</span><a href="#unmarshalling" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><a href="https://spcdn.pages.dev/blog/os/unmarshalling.png" class="popup img-link shimmer"><img src="https://spcdn.pages.dev/blog/os/unmarshalling.png" alt="Unmarshalling" loading="lazy"></a></p><p>Marshalling/Unmarshalling routines are provided by RPC system compiler.</p><h2 id="binding-and-registry"><span class="me-2">Binding and Registry</span><a href="#binding-and-registry" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>Client determines<ul><li><strong>which</strong> server to connect to? - service name. version number<li><strong>how</strong> to connect to that server? - IP address, network protocol</ul><li>Registry : database of available services<ul><li>search for service name to find server(which) and contact details(how)<li>distributed - any RPC service can register<li>machine-specific - for services running on same machine<ul><li>clients must know machine addresses<li>registry provides port number needed for connection</ul></ul><li>Who can provide a service?<ul><li>lookup registry for image processing</ul><li>What services do they provide?<ul><li>compress/filter.. version number =&gt; IDL</ul><li>How will they ship package?<ul><li>TCP / UDP -&gt; registry</ul></ul><h2 id="pointers"><span class="me-2">Pointers</span><a href="#pointers" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>Procedure interface : foo(int,int)<li>in Local Calls : foo(x,y) =&gt; okay<li>in Remote Calls : foo(x,y) =&gt; ?</ul><p>here, y points to location in caller address space</p><ul><li>Solutions:<ul><li>No pointers<li>Serialize pointers; copy referenced (“points to”) data structure to send buffer</ul></ul><h2 id="handling-partial-failures"><span class="me-2">Handling Partial Failures</span><a href="#handling-partial-failures" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>Special RPC error notification (signal, exception..)<ul><li>Catch all possible ways in which RPC can (partially) fail</ul></ul><h2 id="rpc-design-choice"><span class="me-2">RPC Design choice</span><a href="#rpc-design-choice" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>Binding =&gt; How to find the server<li>IDL =&gt; How to talk to server; how to package data<li>Pointers as args =&gt; Disallow or serialize pointer data<li>Partial failures =&gt; Special error notifications</ul><hr /><h1 id="distributed-file-systems">Distributed File Systems</h1><ul><li>Accessed via well defined interface<ul><li>access via Virtual File Systems</ul><li>Focus on consistent state<ul><li>tracking state, file update, cache coherence</ul><li>Mixed distribution models possible<ul><li>replicates vs partitioned, peer-like systems</ul></ul><h2 id="dfs-models"><span class="me-2">DFS models</span><a href="#dfs-models" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>Client Server on different machines<li>File server distributed on multiple machines<ul><li>replicated (each server : all files)<li>partitioned (each server : parts of files)<li>both (files partitioned, each partition replicates)</ul><li>Files stored on and served from all machines (peers)<ul><li>blurred distinction between clients and servers</ul></ul><h2 id="remote-file-service--extremes"><span class="me-2">Remote File Service : Extremes</span><a href="#remote-file-service--extremes" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><a href="https://spcdn.pages.dev/blog/os/extremes.png" class="popup img-link shimmer"><img src="https://spcdn.pages.dev/blog/os/extremes.png" alt="extremes" loading="lazy"></a></p><p><a href="https://spcdn.pages.dev/blog/os/extremes2.png" class="popup img-link shimmer"><img src="https://spcdn.pages.dev/blog/os/extremes2.png" alt="extremes2" loading="lazy"></a></p><ol><li>Extreme1 : Upload/Download<ul><li>like FTP, SVN<li><strong>+</strong> local read/writes at client<li><strong>-</strong> entire file download/upload evn for small accesses<li><strong>-</strong> server gives up contro;</ul><li>Extreme2 : True Remote File Access<ul><li>Every access to remote file, nothing done locally<li><strong>+</strong> file access centralized, easy to reason about consistency<li><strong>-</strong> every file operation pays network cost, limits server scalablity</ul></ol><h2 id="remote-file-service--a-compromise"><span class="me-2">Remote File Service : A compromise</span><a href="#remote-file-service--a-compromise" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>A more practical Remote File access (with Caching)</p><ol><li>Allow clients to store parts of files locally (blocks)<ul><li><strong>+</strong> low latency on file operations<li><strong>+</strong> server load reduces =&gt; more scalable</ul><li>Force clients to interact with server (frequently)<ul><li><strong>+</strong> server has insights into what clients are doing<li><strong>+</strong> server has control into which accesses can be permitted =&gt; easier to maintain consistency<li><strong>-</strong> server more complex, requires different file sharing semantics</ul></ol><h2 id="stateless-vs-stateful-file-server"><span class="me-2">Stateless vs Stateful File server</span><a href="#stateless-vs-stateful-file-server" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><div class="table-wrapper"><table><thead><tr><th>Stateless<th>Stateful<tbody><tr><td>Keeps no state; Okay with extreme models, but can’t support ‘practical’ model<td>Keeps client state needed for ‘practical’ model to track what is cached/accessed<tr><td><strong>-</strong> Can’t support caching and consistency management<td><strong>+</strong> Can support locking, caching, incremental operations<tr><td><strong>-</strong> Every request self-contained. =&gt; more bits transferred<td><strong>-</strong> Overheads to maintain state and consistency. Depends on caching mechanism and consistency protocol.<tr><td><strong>+</strong> No resources are used on server side (CPU, MM). On failure just restart<td><strong>-</strong> On failure, need checkpoining and recovery mechanisms</table></div><h2 id="caching-state-in-a-dfs"><span class="me-2">Caching state in a DFS</span><a href="#caching-state-in-a-dfs" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>Locally clients maintain portion of state (e.g. file blocks)<li>Locally clients perform operations on cached state (e.g. open/read/write)<li>requires coherent mechanisms</ul><p><a href="https://spcdn.pages.dev/blog/os/cachingstate.png" class="popup img-link shimmer"><img src="https://spcdn.pages.dev/blog/os/cachingstate.png" alt="cachingstate.png" loading="lazy"></a></p><div class="table-wrapper"><table><thead><tr><th>System<th>How<th>When<tbody><tr><td>SMP<td>Write-update/Write-invalidate<td>On write<tr><td>DFS<td>Client/Server-driven<td>On demand, periodically, on open..</table></div><ul><li>Files or File blocks can be (with 1 server and multiple clients) cached in:<ul><li>in client memory<li>on client storage device (HDD/SDD)<li>in buffer cache in memory on server - (usefulness will depend on client load, request interleaving)</ul><li><p>File Sharing Semantics in DFS</p><li>Session semantics (between open-close =&gt; Session)<ul><li>write-back on close(), update on open()<li>easy to reason, but may be insufficient</ul><li>Periodic updates<ul><li>client writes-back periodically - clients have a “lease” on cached data (not exclusively necessary)<li>servers invalidates periodically =&gt; provides biunds on “inconsistency”<li>augment with flush()/sync() API</ul><li>Immutable files =&gt; never modify, new files created<li>Transactions =&gt; all changes atomic</ul><h1 id="replication-vs-partitioning">Replication vs Partitioning</h1><div class="table-wrapper"><table><tr><th><th>Replication<th>Partitioning<tr><td><td>Each machine holds all files<td>Each machine has subset of files<tr><td>Advantages<td>Load balancing, availibility, fault tolerance<td>Availibility vs single server DFS;<br />Scalability with file system size;<br />single file writes simpler<tr><td>Disadvantages<td>Write becomes more complex<br />- Synchronous to all<br />- or, write to one, then propagate to others<br />replicas must be reconciled e.g. Voting<td>On failure, lose portion of data<br />load balancing harder, if not balanced, then hot-spots possible</table></div><ul><li>Can combine both techniques<ul><li>Replicate each partition!</ul></ul><hr /><h1 id="distributed-shared-memory">Distributed Shared Memory</h1><ul><li>Must decide placement<ul><li>place memory (pages) close to relevant processes</ul><li>Must decide migration<ul><li>when to copy memory (pages) from remote to local</ul><li>Must decide sharing rules<ul><li>ensure memory generations are properly ordered</ul></ul><h2 id="peer-distribution-applications"><span class="me-2">“Peer” Distribution Applications</span><a href="#peer-distribution-applications" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>Each node<ul><li>“owns” state<li>provide service</ul><li>all nodes are “peers”.</ul><p>Examples: Big-data analytics, web searches, context sharing or distributed shared memory (DSM)</p><h2 id="distributed-shared-memory-dsm"><span class="me-2">Distributed Shared Memory (DSM)</span><a href="#distributed-shared-memory-dsm" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>DSM is a service that manages memory accross multiple nodes so that applications that are running on top will have an illusion that they are running on a shared memory.</p><ul><li>Each node<ul><li>“owns” state =&gt; memory<li>provide service - memory read/writes from any nodes<ul><li>consistency protocols</ul><li>permits scaling beyond single machine memory limits - more “shared” memory at lower cost<ul><li>slower overall memory access<li>commodity interconnect technologies support this RDMA(Remote Direct Memory Access)</ul></ul></ul><h2 id="hardware-vs-software-dsm"><span class="me-2">Hardware vs Software DSM</span><a href="#hardware-vs-software-dsm" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>Hardware-supported (expensive!)<ul><li>relies on interconnect<li>OS manages larger physical memory<li>NIC(Network Interface Cards) translate remote memory accesses to messages<li>NICs involved in all aspects of memory management; support atomics..</ul><li>Software supported<ul><li>everything done by software<li>OS,or language runtime</ul><li>Hybrid (Software tasks in Hardware) DSM implementations<ul><li>prefetch pages<li>address translation (easier done in hardware)<li>triggering invalidations (easier done in hardware)</ul></ul><h2 id="dsm-design--sharing-granularity"><span class="me-2">DSM Design : Sharing Granularity</span><a href="#dsm-design--sharing-granularity" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>cache line granularity?<ul><li>overheads too high for DSM</ul><li>variable granularity [N]<li>page granularity [Y] (OS level)<li>object granularity [Y] (Language runtime)<ul><li>beware of false sharing E.g. x and y shared on same page</ul></ul><h2 id="what-types-of-applications-use-dsm"><span class="me-2">What types of applications use DSM?</span><a href="#what-types-of-applications-use-dsm" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Application access algorithm</p><ul><li>Single reader/ single writer (SRSW)<li>Multiple readers/ single writer (MRSW)<li>Multiple reader/ Multiple writers (MRMW)</ul><h2 id="performance-considerations"><span class="me-2">Performance considerations</span><a href="#performance-considerations" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>DSM performance metric == access latency<li>Achieving low latency through<ul><li>Migration - makes sense for SRSW<ul><li>requires data movement</ul><li>Replication (caching) <br /> - more general<ul><li>requires consistency management</ul></ul><li>Hence, migration is okay for SRSW but not for all.<li>Caching and Replication<ul><li>Copies of data to incerease data access<li>for many concurrent writes, overheads too high but stil generally better than Migration</ul></ul><h2 id="consistency-management"><span class="me-2">Consistency Management</span><a href="#consistency-management" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>In SMP<ul><li>write invalidate<li>write update</ul><li>coherence operations triggered in each write<ul><li>overhead too high</ul><li>Push invalidations when data is written to<ol><li>Proactive<li>Eager<li>Pessimistic</ol><li>Pull modifications information periodically<ol><li>on demand (reactive)<li>lazy<li>optimistic</ol><li>when these methods get triggered depends on the consistency model for the shared state</ul><h2 id="dsm-architecture-page-based-os-supported"><span class="me-2">DSM architecture (page-based, OS-supported)</span><a href="#dsm-architecture-page-based-os-supported" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>Page-based DSM architecture<ul><li>distributed nodes, each with own local memory contribution<li>pool of pages from all nodes<li>each page has IO (“home” node), page frame number</ul><li>if MRMW<ul><li>need local caches for performances (latency)<li>“home” or “manager” node drives coherence operations<li>all nodes responsible for part if distributed memory (state) management</ul><li>Home node<ul><li>keeps state: page accessed, modifications, caching enabled/disabled, locked..</ul><li>Current owner<ul><li>owner may not be equal to home node</ul><li>Explicit replicas<ul><li>for load balancing, performance, or reliability home, manager node controls memory</ul></ul><h2 id="dsm-metadata"><span class="me-2">DSM metadata</span><a href="#dsm-metadata" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><a href="https://spcdn.pages.dev/blog/os/metadata.png" class="popup img-link shimmer"><img src="https://spcdn.pages.dev/blog/os/metadata.png" alt="metadata.png" loading="lazy"></a></p><h2 id="implementing-dsms"><span class="me-2">Implementing DSMs</span><a href="#implementing-dsms" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>Problem : DSM must intercept access to DSM state<ul><li>to send remote messages requesting access<li>to trigger coherence messages</ul><li>overheads should be avoided for local non-shared state (pages)<li>dynamically engage and disengage DSM when necessary<li>Solution : Use hardware MMU support!<ul><li>trap in OS if mapping invalid or access denied<li>remote address mapping -&gt; trap and pass to DSM to send message<li>cached content -&gt; trap and pass to DSM to perform memory coherence operations<li>other MMU information useful (e.g. Dirty page)</ul></ul><h2 id="consistency-model"><span class="me-2">Consistency model</span><a href="#consistency-model" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>Agreement between memory (state) and upper software layers<li>Memory behaves correctly if and only if software follows specific rules<li>Memory (state) guarantees to behave correctly<ul><li>access ordering<li>propagation/ visibility of updates</ul></ul><h3 id="our-notation"><span class="me-2">Our notation</span><a href="#our-notation" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><a href="https://spcdn.pages.dev/blog/os/notation.png" class="popup img-link shimmer"><img src="https://spcdn.pages.dev/blog/os/notation.png" alt="notation.png" loading="lazy"></a></p><ul><li>R_m1(X) =&gt; X was read from memory location m1<li>W_m1(Y) =&gt; Y was written to memory location m1</ul><h3 id="strict-consistency"><span class="me-2">Strict Consistency</span><a href="#strict-consistency" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Strict Consistency =&gt; updates visible everywhere immediately</p><p><a href="https://spcdn.pages.dev/blog/os/strict.png" class="popup img-link shimmer"><img src="https://spcdn.pages.dev/blog/os/strict.png" alt="strict.png" loading="lazy"></a></p><ul><li>In practice<ul><li>Even on single SMP no guarantees on order without extra locking and synchronization<li>in DS, latency and message reorder make this even harder<li>Hence almost impossible to guarantee strict consistency</ul></ul><h3 id="sequential-consistency"><span class="me-2">Sequential Consistency</span><a href="#sequential-consistency" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><a href="https://spcdn.pages.dev/blog/os/seq.png" class="popup img-link shimmer"><img src="https://spcdn.pages.dev/blog/os/seq.png" alt="seq.png" loading="lazy"></a></p><p>Sequential consistency =&gt;</p><ul><li>memory updates from different processors may be arbitrarily interleaved<li>All processes will see the same interleaving<li>Operations from the same process always appearin order they were issued</ul><h3 id="causal-consistency"><span class="me-2">Causal Consistency</span><a href="#causal-consistency" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><a href="https://spcdn.pages.dev/blog/os/causal.png" class="popup img-link shimmer"><img src="https://spcdn.pages.dev/blog/os/causal.png" alt="causal.png" loading="lazy"></a></p><ul><li>For writes not causally related, “concurrent” writes doesnt gurantee.<li>Don’t permit arbitrary ordering from same process writer</ul><h3 id="weak-consistency"><span class="me-2">Weak Consistency</span><a href="#weak-consistency" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><a href="https://spcdn.pages.dev/blog/os/weak.png" class="popup img-link shimmer"><img src="https://spcdn.pages.dev/blog/os/weak.png" alt="weak.png" loading="lazy"></a></p><ul><li>Use of synchronization<ul><li>Synchronization point =&gt; operations that are available (R,W,Sync)<li>all updates prior to a sync point will be visible<li>no guarantee what happens in between</ul></ul><p><strong>+</strong> limit data movement of coherence operations</p><p><strong>-</strong> maintain extra state for additional operations</p><ul><li>Variations:<ul><li>Single sync operation (sync)<li>Seperate sync per surface of state (page)<li>Seperate “entry/acquire” vs “exit/release” operations</ul></ul><hr /></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw me-1"></i> <a href="/categories/computer-science/">Computer Science</a>, <a href="/categories/operating-system/">Operating System</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw me-1"></i> <a href="/tags/computer-science/" class="post-tag no-text-decoration" >computer-science</a> <a href="/tags/operating-system/" class="post-tag no-text-decoration" >Operating System</a></div><div class=" post-tail-bottom d-flex justify-content-between align-items-center mt-5 pb-2 " ><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper d-flex align-items-center"> <span class="share-label text-muted me-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Operating%20System%20Notes%20For%20Placement%20-%20Samir%20Paul&url=https%3A%2F%2Fsamir.pages.dev%2Fposts%2Foperating-system-notes-for-placement%2F" data-bs-toggle="tooltip" data-bs-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter" > <i class="fa-fw fa-brands fa-square-x-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Operating%20System%20Notes%20For%20Placement%20-%20Samir%20Paul&u=https%3A%2F%2Fsamir.pages.dev%2Fposts%2Foperating-system-notes-for-placement%2F" data-bs-toggle="tooltip" data-bs-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook" > <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https%3A%2F%2Fsamir.pages.dev%2Fposts%2Foperating-system-notes-for-placement%2F&text=Operating%20System%20Notes%20For%20Placement%20-%20Samir%20Paul" data-bs-toggle="tooltip" data-bs-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram" > <i class="fa-fw fab fa-telegram"></i> </a> <button id="copy-link" aria-label="Copy link" class="btn small" data-bs-toggle="tooltip" data-bs-placement="top" title="Copy link" data-title-succeed="Link copied successfully!" > <i class="fa-fw fas fa-link pe-none"></i> </button> </span></div></div></div></article></main><aside aria-label="Panel" id="panel-wrapper" class="col-xl-3 ps-2 mb-5 text-muted"><div class="access"><section><h2 class="panel-heading">Trending Tags</h2><div class="d-flex flex-wrap mt-3 mb-1 me-3"> <a class="post-tag btn btn-outline-primary" href="/tags/blog/">blog</a> <a class="post-tag btn btn-outline-primary" href="/tags/computer-science/">computer-science</a> <a class="post-tag btn btn-outline-primary" href="/tags/coding/">coding</a> <a class="post-tag btn btn-outline-primary" href="/tags/system-design/">system-design</a> <a class="post-tag btn btn-outline-primary" href="/tags/design-interview/">design-interview</a> <a class="post-tag btn btn-outline-primary" href="/tags/preparation/">preparation</a> <a class="post-tag btn btn-outline-primary" href="/tags/leetcode/">LeetCode</a> <a class="post-tag btn btn-outline-primary" href="/tags/project/">project</a> <a class="post-tag btn btn-outline-primary" href="/tags/projects/">projects</a> <a class="post-tag btn btn-outline-primary" href="/tags/python/">python</a></div></section></div><section id="toc-wrapper" class="ps-0 pe-4"><h2 class="panel-heading ps-3 pt-2 mb-2">Contents</h2><nav id="toc"></nav></section></aside></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 px-md-4"><aside id="related-posts" aria-labelledby="related-label"><h3 class="mb-4" id="related-label">Further Reading</h3><nav class="row row-cols-1 row-cols-md-2 row-cols-xl-3 g-4 mb-4"><article class="col"> <a href="/posts/databases-implemented-in-python/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1675967400" data-df="ll" > Feb 10, 2023 </time><h4 class="pt-0 my-2">Databases implemented in Python</h4><div class="text-muted"><p> There are several databases that have been implemented in Python, including: SQLite: SQLite is a lightweight, file-based database that is well-suited for small to medium-sized projects. It provide...</p></div></div></a></article><article class="col"> <a href="/posts/gaming-library-in-python/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1675967400" data-df="ll" > Feb 10, 2023 </time><h4 class="pt-0 my-2">gaming library in python</h4><div class="text-muted"><p> There are several libraries in Python that can be used for game development, including: Pygame: This is a popular library for game development in Python. It provides a simple and easy-to-use set o...</p></div></div></a></article><article class="col"> <a href="/posts/how-does-sso-work/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1675967400" data-df="ll" > Feb 10, 2023 </time><h4 class="pt-0 my-2">How does SSO work?</h4><div class="text-muted"><p> Single Sign-On (SSO) works by creating a central authentication service that is responsible for verifying the identity of a user. When a user attempts to access an application or service that is pa...</p></div></div></a></article></nav></aside><nav class="post-navigation d-flex justify-content-between" aria-label="Post Navigation"> <a href="/posts/sql-joins-inner-left-right-and-full-joins/" class="btn btn-outline-primary" aria-label="Older" ><p>SQL Joins - Inner, Left, Right and Full Joins</p></a><div class="btn btn-outline-primary disabled" aria-label="Newer"><p>-</p></div></nav><div id="disqus_thread"><p class="text-center text-muted small">Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script type="text/javascript"> var disqus_config = function () { this.page.url = 'https://samir.pages.dev/posts/operating-system-notes-for-placement/'; this.page.identifier = '/posts/operating-system-notes-for-placement/'; }; /* Lazy loading */ var disqus_observer = new IntersectionObserver( function (entries) { if (entries[0].isIntersecting) { (function () { var d = document, s = d.createElement('script'); s.src = 'https://samirpaul.disqus.com/embed.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); })(); disqus_observer.disconnect(); } }, { threshold: [0] } ); disqus_observer.observe(document.querySelector('#disqus_thread')); /* Auto switch theme */ function reloadDisqus() { if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { /* Disqus hasn't been loaded */ if (typeof DISQUS === 'undefined') { return; } if (document.readyState == 'complete') { DISQUS.reset({ reload: true, config: disqus_config }); } } } if (document.querySelector('.mode-toggle')) { window.addEventListener('message', reloadDisqus); } </script><footer aria-label="Site Info" class=" d-flex flex-column justify-content-center text-muted flex-lg-row justify-content-lg-between align-items-lg-center pb-lg-3 " ><p> © <time>2023</time> <a href="https://twitter.com/SamirPaulb">Samir Paul</a>. <span data-bs-toggle="tooltip" data-bs-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author." >Some rights reserved.</span></p><p>Using the <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme for <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a></p></footer></div></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-11 content"><div id="search-hints"><section><h2 class="panel-heading">Trending Tags</h2><div class="d-flex flex-wrap mt-3 mb-1 me-3"> <a class="post-tag btn btn-outline-primary" href="/tags/blog/">blog</a> <a class="post-tag btn btn-outline-primary" href="/tags/computer-science/">computer-science</a> <a class="post-tag btn btn-outline-primary" href="/tags/coding/">coding</a> <a class="post-tag btn btn-outline-primary" href="/tags/system-design/">system-design</a> <a class="post-tag btn btn-outline-primary" href="/tags/design-interview/">design-interview</a> <a class="post-tag btn btn-outline-primary" href="/tags/preparation/">preparation</a> <a class="post-tag btn btn-outline-primary" href="/tags/leetcode/">LeetCode</a> <a class="post-tag btn btn-outline-primary" href="/tags/project/">project</a> <a class="post-tag btn btn-outline-primary" href="/tags/projects/">projects</a> <a class="post-tag btn btn-outline-primary" href="/tags/python/">python</a></div></section></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><aside aria-label="Scroll to Top"> <button id="back-to-top" type="button" class="btn btn-lg btn-box-shadow"> <i class="fas fa-angle-up"></i> </button></aside></div><div id="mask"></div><aside id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-bs-animation="true" data-bs-autohide="false" ><div class="toast-header"> <button type="button" class="btn-close ms-auto" data-bs-dismiss="toast" aria-label="Close" ></button></div><div class="toast-body text-center pt-0"><p class="px-2 mb-3">A new version of content is available.</p><button type="button" class="btn btn-primary" aria-label="Update"> Update </button></div></aside><script src="https://cdn.jsdelivr.net/combine/npm/jquery@3.7.1/dist/jquery.min.js,npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js,npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js,npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.umd.min.js,npm/magnific-popup@1.1.0/dist/jquery.magnific-popup.min.js,npm/clipboard@2.0.11/dist/clipboard.min.js,npm/dayjs@1.11.10/dayjs.min.js,npm/dayjs@1.11.10/locale/en.min.js,npm/dayjs@1.11.10/plugin/relativeTime.min.js,npm/dayjs@1.11.10/plugin/localizedFormat.min.js,npm/tocbot@4.21.2/dist/tocbot.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-CP4QE6ZEV0"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-CP4QE6ZEV0'); }); </script> <script> /* Note: dependent library will be loaded in `js-selector.html` */ SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<article class="px-1 px-sm-2 px-lg-4 px-xl-0"><header><h2><a href="{url}">{title}</a></h2><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div></header><p>{snippet}</p></article>', noResultsText: '<p class="mt-5"></p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="me-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
