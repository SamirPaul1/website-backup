<!doctype html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover" ><meta name="generator" content="Jekyll v4.3.2" /><meta property="og:title" content="Leetcode Solutions Cheatsheet" /><meta name="author" content="Samir Paul" /><meta property="og:locale" content="en" /><meta name="description" content="Leetcode Solutions Cheatsheet" /><meta property="og:description" content="Leetcode Solutions Cheatsheet" /><link rel="canonical" href="https://samir.pages.dev/posts/leetcode-solutions-cheatsheet/" /><meta property="og:url" content="https://samir.pages.dev/posts/leetcode-solutions-cheatsheet/" /><meta property="og:site_name" content="Samir Paul" /><meta property="og:image" content="https://github.com/github/docs/assets/132539454/688e4b34-2055-4c63-9c22-9f71d4437350" /><meta property="og:image:alt" content="Leetcode Solutions Cheatsheet" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-10-26T00:00:00+05:30" /><meta name="twitter:card" content="summary_large_image" /><meta property="twitter:image" content="https://github.com/github/docs/assets/132539454/688e4b34-2055-4c63-9c22-9f71d4437350" /><meta name="twitter:image:alt" content="Leetcode Solutions Cheatsheet" /><meta property="twitter:title" content="Leetcode Solutions Cheatsheet" /><meta name="twitter:site" content="@SamirPaulb" /><meta name="twitter:creator" content="@Samir Paul" /><meta property="fb:app_id" content="6800281970014175" /><meta name="google-site-verification" content="vJAOBxbJTCK2vXG-hLFeGsoC9hXgFlCpuJJ8AcJLROQ" /><meta name="msvalidate.01" content="1A92FC2EC113F8616A21D76DA684A133" /><meta name="yandex-verification" content="fe6a06c57be84984" /><meta name="facebook-domain-verification" content="3pkgruuk3kzlsn3jdfehgbd4sem1qb" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Samir Paul"},"dateModified":"2022-10-26T00:00:00+05:30","datePublished":"2022-10-26T00:00:00+05:30","description":"Leetcode Solutions Cheatsheet","headline":"Leetcode Solutions Cheatsheet","image":{"alt":"Leetcode Solutions Cheatsheet","url":"https://github.com/github/docs/assets/132539454/688e4b34-2055-4c63-9c22-9f71d4437350","@type":"imageObject"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://samir.pages.dev/posts/leetcode-solutions-cheatsheet/"},"url":"https://samir.pages.dev/posts/leetcode-solutions-cheatsheet/"}</script><title>Leetcode Solutions Cheatsheet | Samir Paul</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Samir Paul"><meta name="application-name" content="Samir Paul"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/jekyll-theme-chirpy.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.21.2/dist/tocbot.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return 'mode'; } static get MODE_ATTR() { return 'data-mode'; } static get DARK_MODE() { return 'dark'; } static get LIGHT_MODE() { return 'light'; } static get ID() { return 'mode-toggle'; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener('change', () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia('(prefers-color-scheme: dark)'); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { document.documentElement.setAttribute(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { document.documentElement.setAttribute(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { document.documentElement.removeAttribute(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage( { direction: ModeToggle.ID, message: this.modeStatus }, '*' ); } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.notify(); } /* flipMode() */ } /* ModeToggle */ const modeToggle = new ModeToggle(); </script><body><aside aria-label="Sidebar" id="sidebar" class="d-flex flex-column align-items-end"><header class="profile-wrapper"> <a href="/" id="avatar" class="rounded-circle"> <img src="/assets/img/avatar.webp" width="112" height="112" alt="avatar" onerror="this.style.display='none'"> </a><h1 class="site-title"> <a href="/">Samir Paul</a></h1><p class="site-subtitle fst-italic mb-0">Software Engineer</p></header><nav class="flex-column flex-grow-1 w-100 ps-0"><ul class="nav"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle"></i> <span>ABOUT</span> </a><li class="nav-item"> <a href="/posts/" class="nav-link"> <i class="fa-fw fas fa-archive"></i> <span>ALL POSTS</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream"></i> <span>CATEGORIES</span> </a></ul></nav><div class="sidebar-bottom d-flex flex-wrap align-items-center w-100"> <button type="button" class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/SamirPaul1" aria-label="github" target="_blank" rel="noopener noreferrer" > <i class="fab fa-github"></i> </a> <a href="https://twitter.com/SamirPaulb" aria-label="twitter" target="_blank" rel="noopener noreferrer" > <i class="fa-brands fa-x-twitter"></i> </a> <a href="javascript:location.href = 'mailto:' + ['',''].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></aside><div id="main-wrapper" class="d-flex justify-content-center"><div class="container d-flex flex-column px-xxl-5"><header id="topbar-wrapper" aria-label="Top Bar"><div id="topbar" class="d-flex align-items-center justify-content-between px-lg-3 h-100" ><nav id="breadcrumb" aria-label="Breadcrumb"> <span> <a href="/"> Home </a> </span> <span>Leetcode Solutions Cheatsheet</span></nav><button type="button" id="sidebar-trigger" class="btn btn-link"> <i class="fas fa-bars fa-fw"></i> </button><div id="topbar-title"> Post</div><button type="button" id="search-trigger" class="btn btn-link"> <i class="fas fa-search fa-fw"></i> </button> <search class="align-items-center ms-3 ms-lg-0"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..." > </search> <button type="button" class="btn btn-link text-decoration-none" id="search-cancel">Cancel</button></div></header><div class="row flex-grow-1"><main aria-label="Main Content" class="col-12 col-lg-11 col-xl-9 px-md-4"><article class="px-1"><header><h1 data-toc-skip>Leetcode Solutions Cheatsheet</h1><div class="post-meta text-muted"> <span> Posted <time data-ts="1666722600" data-df="ll" data-bs-toggle="tooltip" data-bs-placement="bottom" > Oct 26, 2022 </time> </span><div class="mt-3 mb-3"> <a href="https://github.com/github/docs/assets/132539454/688e4b34-2055-4c63-9c22-9f71d4437350" class="popup img-link preview-img shimmer"><img src="https://github.com/github/docs/assets/132539454/688e4b34-2055-4c63-9c22-9f71d4437350" alt="Leetcode Solutions Cheatsheet" width="1200" height="630" loading="lazy"></a><figcaption class="text-center pt-2 pb-2">Leetcode Solutions Cheatsheet</figcaption></div><div class="d-flex justify-content-between"> <span> By <em> <a href="https://twitter.com/SamirPaulb">Samir Paul</a> </em> </span> <span class="readtime" data-bs-toggle="tooltip" data-bs-placement="bottom" title="43706 words" > <em>242 min</em> read</span></div></div></header><div class="content"><h2 id="quick-access-links"><span class="me-2">Quick Access Links</span><a href="#quick-access-links" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="leetcode"><span class="me-2">LeetCode</span><a href="#leetcode" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>LeetCode - CheatSheet<ul><li>Getting Started<ul><li>Prerequisites</ul><li>Built With<li>Authors<li>Acknowledgments<li><a href="#quick-access-links">Quick Access Links</a><ul><li><a href="#leetcode">LeetCode</a></ul></ul><li><a href="#1-two-sum">1-Two Sum</a><ul><li><a href="#brute-force">Brute Force</a><li><a href="#one-pass-hash-table">One Pass Hash Table</a></ul><li><a href="#2-add-two-numbers">2-Add Two Numbers</a><ul><li><a href="#elementary-math-solution">Elementary Math Solution</a></ul><li><a href="#3-substring-no-repeat">3-Substring No Repeat</a><ul><li><a href="#brute-force-1">Brute Force</a><li><a href="#sliding-window">Sliding Window</a><li><a href="#sliding-window-optimized">Sliding Window Optimized</a></ul><li><a href="#4-median-of-two-sorted-arrays">4-Median of Two Sorted Arrays</a><ul><li><a href="#recursive-approach">Recursive Approach</a></ul><li><a href="#5-longest-palindromic-substring">5-Longest Palindromic Substring</a><ul><li><a href="#longest-common-substring">Longest Common Substring</a><li><a href="#brute-force-2">Brute Force</a><li><a href="#dynamic-programming">Dynamic Programming</a><li><a href="#expand-around-center">Expand Around Center</a><li><a href="#manachers-algorithm">Manacher’s Algorithm</a></ul><li><a href="#6-zigzag-conversion">6-ZigZag Conversion</a><ul><li><a href="#sort-by-row">Sort by Row</a><li><a href="#visit-by-row">Visit by Row</a></ul><li><a href="#7-reverse-integer">7-Reverse Integer</a><ul><li><a href="#pop-and-push-digits-and-check-before-overflow">Pop and Push Digits and Check Before Overflow</a></ul><li><a href="#8-string-to-integer-atoi">8-String to Integer (atoi)</a><ul><li><a href="#ascii-conversion">ASCII Conversion</a></ul><li><a href="#9-palindrome-number">9-Palindrome Number</a><ul><li><a href="#revert-half-of-the-number">Revert Half of the Number</a></ul><li><a href="#10-regular-expression-matching">10-Regular Expression Matching</a><ul><li><a href="#recursion">Recursion</a><li><a href="#dynamic-programming-1">Dynamic Programming</a><li><a href="#non-recursive">Non-Recursive</a></ul><li><a href="#11-container-with-the-most-water">11-Container with the Most Water</a><ul><li><a href="#brute-force-3">Brute Force</a><li><a href="#two-pointer-approach">Two Pointer Approach</a></ul><li><a href="#12-integer-to-roman">12-Integer To Roman</a><ul><li><a href="#string-array">String Array</a></ul><li><a href="#13-roman-to-integer">13-Roman to Integer</a><ul><li><a href="#character-array">Character Array</a></ul><li><a href="#14-longest-common-prefix">14-Longest Common Prefix</a><ul><li><a href="#horizontal-scanning">Horizontal Scanning</a><li><a href="#vertical-scanning">Vertical Scanning</a><li><a href="#divide-and-conquer">Divide and Conquer</a><li><a href="#binary-search">Binary Search</a><li><a href="#further-thoughts">Further Thoughts</a></ul><li><a href="#15-3sum">15-3Sum</a><ul><li><a href="#sorted-array">Sorted Array</a></ul><li><a href="#16-3sum-closest">16-3Sum Closest</a><ul><li><a href="#3-pointers">3 Pointers</a></ul><li><a href="#17-letter-combinations-of-a-phone-number">17-Letter Combinations of a Phone Number</a><ul><li><a href="#backtracking">Backtracking</a><li><a href="#first-in-first-out-fifo-queue">First In First Out (FIFO) Queue</a></ul><li><a href="#18-4sum">18-4Sum</a><ul><li><a href="#sorted-array-1">Sorted Array</a></ul><li><a href="#19-remove-nth-node-from-end-of-list">19-Remove Nth Node From End of List</a><ul><li><a href="#two-pass-algorithm">Two Pass Algorithm</a><li><a href="#one-pass-algorithm">One Pass Algorithm</a></ul><li><a href="#20-valid-parentheses">20-Valid Parentheses</a><ul><li><a href="#counting-method">Counting method</a><li><a href="#stacks">Stacks</a></ul><li><a href="#21-merge-two-sorted-lists">21-Merge Two Sorted Lists</a><ul><li><a href="#recursive">Recursive</a><li><a href="#non-recursive-1">Non-Recursive</a></ul><li><a href="#22-generate-parentheses">22-Generate Parentheses</a><ul><li><a href="#brute-force-4">Brute Force</a><li><a href="#backtracking-1">Backtracking</a><li><a href="#closure-number">Closure Number</a></ul><li><a href="#23-merge-k-sorted-lists">23-Merge k Sorted Lists</a><ul><li><a href="#brute-force-5">Brute Force</a></ul><li><a href="#146-lru-cache">146-LRU Cache</a></ul><p><a name="twoSum"></a></p><h1 id="1-two-sum">1-Two Sum</h1><p>Given an array of integers, return <strong>indices</strong> of the two numbers such that they add up to a specific target. You may assume that each input would have <strong>exactly one solution</strong>, and you may not use the same element twice.</p><p>Example:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>Given nums = [2, 7, 11, 15], target = 9,

Because nums[0] + nums[1] = 2 + 7 = 9,
return [0, 1].
</pre></table></code></div></div><p><br /><br /> <a name="twoSumBruteForce"></a></p><h2 id="brute-force"><span class="me-2">Brute Force</span><a href="#brute-force" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">twoSum</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
	<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">nums</span><span class="o">.</span><span class="na">size</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
		<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span><span class="n">j</span><span class="o">++){</span>
			<span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">]==</span><span class="n">target</span><span class="o">-</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]){</span>
				<span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]</span> <span class="o">{</span><span class="n">i</span><span class="o">,</span><span class="n">j</span><span class="o">};</span>
			<span class="o">}</span>
		<span class="o">}</span>
	<span class="o">}</span>
	<span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">(</span><span class="s">"No two sum solution"</span><span class="o">);</span>
<span class="o">}</span> 
</pre></table></code></div></div><p><strong>Complexity Analysis</strong></p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>* Time complexity:   O(n^2)       we have a nested loop 
* Space complexity:  O(1) 	  we do not allocate any additional memory
</pre></table></code></div></div><p><a name="twoSumOnePassHashTable"></a></p><h2 id="one-pass-hash-table"><span class="me-2">One Pass Hash Table</span><a href="#one-pass-hash-table" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">twoSum</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
	<span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
	<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
		<span class="kt">int</span> <span class="n">complement</span><span class="o">=</span><span class="n">target</span><span class="o">-</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">complement</span><span class="o">)){</span>
			<span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]</span> <span class="o">{</span><span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">complement</span><span class="o">),</span><span class="n">i</span><span class="o">};</span>
		<span class="o">}</span>
		<span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">],</span><span class="n">i</span><span class="o">);</span>
	<span class="o">}</span>
	<span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">(</span><span class="s">"No two sum solution"</span><span class="o">);</span> 
<span class="o">}</span>
</pre></table></code></div></div><p><strong>Complexity Analysis</strong></p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>* Time complexity:   O(n)		each lookup in the hash table only requires O(1) time
* Space complexity:  O(n)		we require additional space for the hash table which stores at most n
</pre></table></code></div></div><p><br /><br /><br /> *** <a name="addTwoNumbers"></a></p><h1 id="2-add-two-numbers">2-Add Two Numbers</h1><p>Given two non-empty linked lists representing two non-negative integers with the digits stored in reverse order and each node containing a single digit, add the two numbers and return as a linked list</p><p>Example:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>Input (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4) 
Output 7 -&gt; 0 -&gt; 8 

342 + 465 = 807
</pre></table></code></div></div><p><br /><br /> <a name="addTwoNumbersElementaryMath"></a></p><h2 id="elementary-math-solution"><span class="me-2">Elementary Math Solution</span><a href="#elementary-math-solution" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre><td class="rouge-code"><pre><span class="cm">/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */</span>



<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">ListNode</span> <span class="nf">addTwoNumbers</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">l1</span><span class="o">,</span> <span class="nc">ListNode</span> <span class="n">l2</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">ListNode</span> <span class="n">dummyHead</span><span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span> 
        <span class="nc">ListNode</span> <span class="n">p</span><span class="o">=</span><span class="n">l1</span><span class="o">,</span> <span class="n">q</span><span class="o">=</span><span class="n">l2</span><span class="o">,</span> <span class="n">curr</span><span class="o">=</span><span class="n">dummyHead</span><span class="o">;</span> 
        <span class="kt">int</span> <span class="n">carry</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> 
        <span class="k">while</span> <span class="o">(</span><span class="n">p</span><span class="o">!=</span><span class="kc">null</span><span class="o">||</span><span class="n">q</span><span class="o">!=</span><span class="kc">null</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">x</span><span class="o">=</span> <span class="o">(</span><span class="n">p</span><span class="o">!=</span><span class="kc">null</span><span class="o">)</span> <span class="o">?</span> <span class="n">p</span><span class="o">.</span><span class="na">val</span> <span class="o">:</span><span class="mi">0</span><span class="o">;</span> <span class="c1">//if (p!=null) then x contains p.val</span>
            <span class="kt">int</span> <span class="n">y</span><span class="o">=</span> <span class="o">(</span><span class="n">q</span><span class="o">!=</span><span class="kc">null</span><span class="o">)</span> <span class="o">?</span> <span class="n">q</span><span class="o">.</span><span class="na">val</span> <span class="o">:</span><span class="mi">0</span><span class="o">;</span>
            <span class="kt">int</span> <span class="n">sum</span><span class="o">=</span><span class="n">carry</span><span class="o">+</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="o">;</span>
            <span class="n">carry</span><span class="o">=</span><span class="n">sum</span><span class="o">/</span><span class="mi">10</span><span class="o">;</span>
            <span class="n">curr</span><span class="o">.</span><span class="na">next</span><span class="o">=</span><span class="k">new</span> <span class="nc">ListNode</span><span class="o">(</span><span class="n">sum</span><span class="o">%</span><span class="mi">10</span><span class="o">);</span>
            <span class="n">curr</span><span class="o">=</span><span class="n">curr</span><span class="o">.</span><span class="na">next</span><span class="o">;</span> 
            <span class="k">if</span> <span class="o">(</span><span class="n">p</span><span class="o">!=</span><span class="kc">null</span><span class="o">)</span> <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="na">next</span><span class="o">;</span> 
            <span class="k">if</span> <span class="o">(</span><span class="n">q</span><span class="o">!=</span><span class="kc">null</span><span class="o">)</span> <span class="n">q</span><span class="o">=</span><span class="n">q</span><span class="o">.</span><span class="na">next</span><span class="o">;</span> 
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">carry</span><span class="o">&gt;</span><span class="mi">0</span><span class="o">){</span>
            <span class="n">curr</span><span class="o">.</span><span class="na">next</span><span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(</span><span class="n">carry</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">dummyHead</span><span class="o">.</span><span class="na">next</span><span class="o">;</span> 
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><strong>Complexity analysis</strong></p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>* Time Complexity:  O(max(m,n))         depends on the lengths of the two linked lists 
* Space Complexity: O(max(m,n))		the maximum length of the new list is max(m,n)+1
</pre></table></code></div></div><p><br /><br /><br /> *** <a name="substringNoRepeat"></a></p><h1 id="3-substring-no-repeat">3-Substring No Repeat</h1><p>Longest Substring Without Repeating Characters</p><p>Given a string find the length of the longest substring without repeating characters.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>Example
Input: 		"abcabcbb"
Output:		3
Explanation:	The answer is "abc", with the length of 3
</pre></table></code></div></div><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>Example 2
Input:		"bbbbb"
Output:		1
Explanation:	The answer is "b", with the length of 1
</pre></table></code></div></div><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>Example 3
Input:		"pwwkew"
Output:		3
Explanation: 	The answer is "wke", with the length of 3. Note that the answer must be a substring
		"pwke" is a subsequence and not a substring 
</pre></table></code></div></div><p><br /><br /> <a name="substringNoRepeatBruteForce"></a></p><h2 id="brute-force-1"><span class="me-2">Brute Force</span><a href="#brute-force-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><em>Algorithm</em></p><p>Suppose we have a function “boolean allUnique(String substring)” which returns true if all the characters in the substring are unique and false otherwise. We can iterate through all the possible substrings of the given string s and call the function allUnique. If it turns out to be true, then we update our answer of the maximum length of substring without duplicate characters.</p><p>To enumerate all substrings of a given string we enumerate the start and end indices of them. Suppose the start and end indices are i and j respectively. Then we have 0 &lt;= i &lt;= j &lt;= n. Thus using two nested loops with i from 0 to n-1 and j from i+1 to n, we can enumerate all the substrings of s</p><p>To check if one string has duplicate characters we can use a set. We iterate through all the characters in the string and put them into the set one by one. Before putting one character, we check if the set already contains it. If so we return false and after the loop we return true.</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">lengthOfLongestSubstring</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">allUnique</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">))</span> <span class="n">ans</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">ans</span><span class="o">,</span> <span class="n">j</span> <span class="o">-</span> <span class="n">i</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">allUnique</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="kt">int</span> <span class="n">start</span><span class="o">,</span> <span class="kt">int</span> <span class="n">end</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">&gt;</span> <span class="n">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">start</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">end</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="nc">Character</span> <span class="n">ch</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">set</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">ch</span><span class="o">))</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">ch</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><strong>Complexity Analysis</strong></p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre>* Time Complexity:   O(n^3)		Verifying if characters in   [i,j) are unique requires us to scan all of
					them which would cost O(j-i) time. 

					For a given i, the sum of time costed by each j -&gt; [i+1,n] is 
					"Summation from i+1 to n O(j-1)"

					Thus, the sum of all the time consumption is: 
					O(summation from 0 to n-1(summation from j=i+1 to n (j-1))) 
					O(summation from i=0 to n-1(1+n-i)(n-i)/2)) = O(n^3)


					*Note that the sum of all numbers up to n 1+2+3+...+n = n(n+1)/2


* Space Complexity:  O(min(n,m))	We require O(k) space for checking a substring has no duplicate 
					characters, where k is the size of the set. The size of the Set is 
					upper bounded by the size of the string n amd the size of the charset
					or alphabet m 
				
				
</pre></table></code></div></div><p><br /><br /> <a name="substringNoRepeatSlidingWindow"></a></p><h2 id="sliding-window"><span class="me-2">Sliding Window</span><a href="#sliding-window" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>A sliding window is an abstract concept commonly used in array/string problems. A window is a range of elements in the array/string which usually defined by the start and end indices</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>Ex. [i,j) left-closed, right-open
</pre></table></code></div></div><p>A sliding window is a window that slides its two boundaries in a certain direction, for example if we slide [i,j) to the right by 1 element, then it becomes [i+1, j+1) - left closed, right open.</p><p>Sliding Window approach, whenever we are looking at a section on an array usual to perform calculations we don’t need to completely recalculate everything for every section of the array. Usually we can use the value obtained from another section of the array to determine something about this section of the array. For example if we are calculating the sum of sections of an array we can use the previously calculated value of a section to determine the sum of an adjacent section in the array.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>Ex. 1 2 3 4 5 6 7 8 
</pre></table></code></div></div><p>If we calculate the first section of four values we get 1+2+3+4 = 10 , then to calculate the next section 2+3+4+5 we can just take our first section (window_sum) and perform the operation:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>window_sum-first entry + last entry = 10-1+5= 14
</pre></table></code></div></div><p>So essentially for the window sliding technique we use what we know about an existing window to determine properties for another window.</p><p><br /><br /> <em>Algorithm</em></p><p>In the brute force approach, we repeatedly check a substring to see if it has duplicate characters but this is unnecessary. If a substring from index i to j-1 is already checked to have no duplicate characters we only need to check if s[j] is already in the substring.</p><p>To check if a character is already in the substring we can scan the substring which leads to an O(n^2) algorithm but we can improve on this runtime using a HashSet as a sliding window to check if a character exists in the current set O(1).</p><p>We use a HashSet to store the characters in the current window [i,j) and then we slide the index j to the right, if it is not in the HashSet, we slide j further until s[j] is already in the HashSet. At this point we found the maximum size of substrings without duplicate characters starting with index i. If we do this for all i, then we obtain our answer.</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">lengthOfLongestSubstring</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">&gt;</span> <span class="n">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>
        <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// try to extend the range [i, j]</span>
            <span class="k">if</span> <span class="o">(!</span><span class="n">set</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">))){</span>
                <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">++));</span>
                <span class="n">ans</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">ans</span><span class="o">,</span> <span class="n">j</span> <span class="o">-</span> <span class="n">i</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="k">else</span> <span class="o">{</span>
                <span class="n">set</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">++));</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><strong>Complexity Analysis</strong></p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre>Time complexity:	O(2n)=O(n)	Worst case each character will be visited twice by i and j

Space complexity: 	O(min(m,n))	Same as the brute force method, we need O(k) space for the 
					sliding window where k is the size of the set. The size of the
					set is bounded by the size of the string n and the size of the
					charset/alphabet m
</pre></table></code></div></div><p><br /><br /> <a name="substringNoRepeatOptimized"></a></p><h2 id="sliding-window-optimized"><span class="me-2">Sliding Window Optimized</span><a href="#sliding-window-optimized" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>The previously discussed sliding window approach requires at most 2n steps and this could in fact be optimized even further to require only n steps. Instead of using a set to tell if a character exists or not, we could define a mapping of the characters to its index. Then we can skip the characters immediately when we found a repeated character</p><p>If s[j] has a duplicate in the range [i , j) with index j’, we don’t need to increase i little be little we can just skip all the elements in the range [i , j’] and let i be j’+1 directly</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">lengthOfLongestSubstring</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">(),</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span> <span class="c1">// current index of character</span>
        <span class="c1">// try to extend the range [i, j]</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">)))</span> <span class="o">{</span>
                <span class="n">i</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">)),</span> <span class="n">i</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="n">ans</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">ans</span><span class="o">,</span> <span class="n">j</span> <span class="o">-</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
            <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">),</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><br /><br /><br /> *** <a name="medianofTwoSortedArrays"></a></p><h1 id="4-median-of-two-sorted-arrays">4-Median of Two Sorted Arrays</h1><p>There are two sorted arrays num1 and num2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). You may assume nums1 and nums2 cannot be both empty.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre>Example 

nums1 = [1, 3] 
nums2 = [2]

The median is 2.0
</pre></table></code></div></div><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre>Example 2

nums1= [1, 2] 
nums2= [3, 4] 

The median is (2+3)/2 = 2.5
</pre></table></code></div></div><p><br /><br /> <a name="medianofTwoSortedArraysRecursiveApproach"></a></p><h2 id="recursive-approach"><span class="me-2">Recursive Approach</span><a href="#recursive-approach" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>In statistics the median is used for dividing a set into two equal length subsets with one set being always greater than the other set. To approach this problem first we cut A into two parts at a random position i:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>         left_A                |           right_A 

  A[0], A[1], ... , A[i-1]         A[i], A[i+1], ... , A[m-1]
</pre></table></code></div></div><p>Since A has m elements, there are m+1 kinds of cutting as i can range from 0-m. We can also see that left_A is empty when i is zero and right_A is empty when i=m</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>len(left_A) = i and len(right_A)= m-i
</pre></table></code></div></div><p>We can similarly cut B into two parts at a random position j:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>	left_B			|	right_B

  B[0], B[1], ... , B[j-1]	   B[j], B[j+1], ... , B[n-1]
</pre></table></code></div></div><p>Now if we put left_A and left_B into one set and put right_A and right_B into another set and name them left_part and right_part, then we get</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>	left_part		|	right_part
  A[0], A[1], ... , A[i-1]	  A[i], A[i+1], ... , A[m-1]
  B[0], B[1], ... , B[j-1]	  B[j], B[j+1], ... , B[n-1]
</pre></table></code></div></div><p>If we can ensure that</p><ol><li>the len(left_part) = len(right_part)<li>max(left_part) &lt;= min(right_part)</ol><p>then we divide all the elements in {A,B} into two parts with equal length and one part is always greater than the other. Then</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>median= (max(left_part)+min(right_part))/2
</pre></table></code></div></div><p>To ensure these two conditions, we need to ensure:</p><ol><li>i+j= m-i+n-j (or: m-i+n-j+1) if n&gt;m, we just need to set i=0~m, j= (m+n+1)/2 - i<li>B[j-1]&lt;=A[i] and A[i-1]&lt;=B[j]</ol><p>So, all we need to do is search for i in [0,m] to find an object i such that B[j-1]&lt;=A[i] and A[i-1]&lt;=B[j] where j=(m+n+1)/2 -i</p><p>Then we perform a binary search following the steps described below:</p><p>1) Set imin=0, imax=0, then start searching in [imin, imax] 2) Set i=(imin+imax)/2 , j=(m+n+1)/2 - i 3) Now we have len(left_part) = len(right_part) and there are only 3 more situations which we may encounter:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre>   - B[j-1] &lt;= A[i] and A[i-1]&lt;=B[j] 
     This means that we have found the object i, so we can stop searching

   - B[j-1] &gt; A[i]
     Means A[i] is too small, we must adjust i to get B[j-1]&lt;=A[i] so we increase i because this will
     cuase j to be decreased. We cannot decrease i because when i is decreased, j will be increased
     so B[j-1] is increased and A[i] is decreased (B[j-1]&lt;= A[i] will never be satisfied)

   - A[i-1] &gt; B[j] 
     Means A[i-1] is too big and thus we must decrease i to get A[i-1]&lt;=B[j]. In order to do that we 
     must adjust the searching range to [imin, i-1] so we set imax=i-1 and go back to step 2
</pre></table></code></div></div><p>When the object i is found, then the media is:</p><p>max(A[i-1],B[j-1]), when m+n is odd (max(A[i-1],B[j-1])+min(A[i],B[j]))/2, when m+n is even</p><p>Next is to consider the edge values i=0, i=m, j=0, j=n where A[i-1], B[j-1], A[i], B[j] may not exist</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="kt">double</span> <span class="nf">findMedianSortedArrays</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="no">A</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="no">B</span><span class="o">)</span> <span class="o">{</span>
		<span class="kt">int</span> <span class="n">m</span><span class="o">=</span><span class="no">A</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
		<span class="kt">int</span> <span class="n">n</span><span class="o">=</span><span class="no">B</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">m</span><span class="o">&gt;</span><span class="n">n</span><span class="o">)</span> <span class="o">{</span>   	<span class="c1">//ensuring that m&lt;=n</span>
			<span class="kt">int</span><span class="o">[]</span> <span class="n">temp</span><span class="o">=</span><span class="no">A</span><span class="o">;</span> <span class="no">A</span><span class="o">=</span><span class="no">B</span><span class="o">;</span> <span class="no">B</span><span class="o">=</span><span class="n">temp</span><span class="o">;</span>
			<span class="kt">int</span> <span class="n">tmp</span><span class="o">=</span><span class="n">m</span><span class="o">;</span> <span class="n">m</span><span class="o">=</span><span class="n">n</span><span class="o">;</span> <span class="n">n</span><span class="o">=</span><span class="n">tmp</span><span class="o">;</span>
		<span class="o">}</span>
		<span class="kt">int</span> <span class="n">iMin</span><span class="o">=</span><span class="mi">0</span><span class="o">,</span> <span class="n">iMax</span><span class="o">=</span><span class="n">m</span><span class="o">,</span> <span class="n">halfLen</span><span class="o">=(</span><span class="n">m</span><span class="o">+</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="o">)/</span><span class="mi">2</span><span class="o">;</span>
		<span class="k">while</span> <span class="o">(</span><span class="n">iMin</span><span class="o">&lt;=</span><span class="n">iMax</span><span class="o">)</span> <span class="o">{</span>
			<span class="kt">int</span> <span class="n">i</span><span class="o">=(</span><span class="n">iMin</span><span class="o">+</span><span class="n">iMax</span><span class="o">)/</span><span class="mi">2</span>
			<span class="kt">int</span> <span class="n">j</span><span class="o">=</span> <span class="n">halfLen</span> <span class="o">-</span> <span class="n">i</span><span class="o">;</span>
			<span class="k">if</span> <span class="o">(</span><span class="n">i</span><span class="o">&lt;</span><span class="n">iMax</span> <span class="o">&amp;&amp;</span> <span class="no">B</span><span class="o">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">&gt;</span> <span class="no">A</span><span class="o">[</span><span class="n">i</span><span class="o">]){</span>
				<span class="n">iMin</span><span class="o">=</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span> <span class="c1">//i is too small</span>
			<span class="o">}</span>
			<span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">i</span><span class="o">&gt;</span><span class="n">iMin</span> <span class="o">&amp;&amp;</span> <span class="no">A</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">]&gt;</span><span class="no">B</span><span class="o">[</span><span class="n">j</span><span class="o">])</span> <span class="o">{</span>
				<span class="n">iMax</span><span class="o">=</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span> <span class="c1">//i is too big</span>
			<span class="o">}</span>
			<span class="k">else</span><span class="o">{</span> <span class="c1">//we have found the object i </span>
				<span class="kt">int</span> <span class="n">maxLeft</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> 
				<span class="k">if</span> <span class="o">(</span><span class="n">i</span><span class="o">==</span><span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
					<span class="n">maxLeft</span><span class="o">=</span><span class="no">B</span><span class="o">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">];</span>
				<span class="o">}</span>
				<span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">j</span><span class="o">==</span><span class="mi">0</span><span class="o">){</span>
					<span class="n">maxLeft</span><span class="o">=</span><span class="no">A</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">];</span>
				<span class="o">}</span>
				<span class="k">else</span><span class="o">{</span>
					<span class="n">maxLeft</span><span class="o">=</span><span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="no">A</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">],</span> <span class="no">B</span><span class="o">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">]);</span>
				<span class="o">}</span>

				<span class="k">if</span> <span class="o">((</span><span class="n">m</span><span class="o">+</span><span class="n">n</span><span class="o">)%</span><span class="mi">2</span> <span class="o">==</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
					<span class="k">return</span> <span class="n">maxLeft</span><span class="o">;</span>
				<span class="o">}</span>

				<span class="kt">int</span> <span class="n">minRIght</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
				<span class="k">if</span> <span class="o">(</span><span class="n">i</span><span class="o">==</span><span class="n">m</span><span class="o">)</span> <span class="o">{</span>
					<span class="n">minRight</span><span class="o">=</span><span class="no">B</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
				<span class="o">}</span>
				<span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">j</span><span class="o">==</span><span class="n">n</span><span class="o">)</span> <span class="o">{</span>
					<span class="n">minRight</span><span class="o">=</span><span class="no">A</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
				<span class="o">}</span>
				<span class="k">else</span> <span class="o">{</span>
					<span class="n">minRight</span><span class="o">=</span><span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="no">B</span><span class="o">[</span><span class="n">j</span><span class="o">],</span> <span class="no">A</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
				<span class="o">}</span>

				<span class="k">return</span> <span class="o">(</span><span class="n">maxLeft</span><span class="o">+</span><span class="n">minRight</span><span class="o">)/</span><span class="mf">2.0</span><span class="o">;</span>
			<span class="o">}</span>
		<span class="o">}</span>
		<span class="k">return</span> <span class="mf">0.0</span><span class="o">;</span>
	<span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><strong>Complexity Analysis</strong></p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre>Time Complexity: O(log(min(m,n)))	At first the searching range is [0,m] and the length of this 
					searching range will be reduced by half after each loop so we
					only need log(m) loops. Since we do constant operations in 
					each loop the time complexity is O(log(m) and since m&lt;=n the
					time complexity is O(log(min(m,n))

Space Complexity: O(1)			We only need constant memory to store 9 local variables so the
					space complexity is O(1)
</pre></table></code></div></div><p><br /><br /><br /> *** <a name="longestPalindromicSubstring"></a></p><h1 id="5-longest-palindromic-substring">5-Longest Palindromic Substring</h1><p>Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre>Example 1: 

Input: "babad" 
Output: "bab" 

Note: "aba" is also a valid answer 
</pre></table></code></div></div><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>Example 2: 

Input: "cbbd"
Output: "bb" 
</pre></table></code></div></div><p><br /><br /> <a name="longestPalindromicSubstringLongestCommonSubstring"></a></p><h2 id="longest-common-substring"><span class="me-2">Longest Common Substring</span><a href="#longest-common-substring" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Some people will be tempted to come up with this quick solution which is unforunately flawed, “reverse S and become S’. Find the longest common substring between S and S’ and that will be the longest palindromic substring.” This will work with some examples but there are some cases where the longest common substring is not a valid palindrome.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>Ex. S="abacdfgdcaba", S'="abacdgfdcaba" 	
</pre></table></code></div></div><p>The longest common substring between S and S’ is “abacd” and clearly this is not a valid palindrome</p><p>We can solve this problem however by checking if the substring’s indices are the same as the reversed substring’s original indices each time we find a longest common substring. If it is, then we attempt to update the longest palindrome found so far, if not we skip this and find the next candidate</p><p><strong>Complexity Analysis</strong></p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>Time Complexity: O(n^2) 
Space Complexity: O(n^2) 
</pre></table></code></div></div><p><br /><br /> <a name="longestPalindromicSubstringBruteForce"></a></p><h2 id="brute-force-2"><span class="me-2">Brute Force</span><a href="#brute-force-2" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>The obvious brute force solution is to pick all possible starting and ending position for a substring and verify if it is a palindrome</p><p><strong>Complexity Analysis</strong></p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>Time Complexity: O(n^3)		If n is the length of the input string, there are a total of 
				(n 2) = n(n-1)/2 substrings and since verifying each substring takes 
				O(n) time, the run time complexity is O(n^3)

Space Complexity: O(1) 
</pre></table></code></div></div><p><br /><br /> <a name="longestPalindromicSubstringDynamicProgramming"></a></p><h2 id="dynamic-programming"><span class="me-2">Dynamic Programming</span><a href="#dynamic-programming" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>We can improve on the brute force solution by avoid some unnecessary re-computation while validating palidromes. Consider the word “ababa”, if we already know that “bab” is a palindrome then we can determine that ababa is a palindrome by noticing that the two left and right letters connected to bab are the same.</p><p>This yields a straight forward dynamic programming solution where we initialize the one and two letters palindromes and then work our way up finding all three letters palindromes and so on.</p><p><strong>Complexity Analysis</strong></p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>Time Complexity: 	O(n^2)	

Space Complexity: 	O(n^2)	Using O(n^2) space to store the table 
</pre></table></code></div></div><p><br /><br /> <a name="longestPalindromicSubstringExpandAroundCenter"></a></p><h2 id="expand-around-center"><span class="me-2">Expand Around Center</span><a href="#expand-around-center" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>This approach allows us to solve this problem in O(n^2) time using only constant space complexity. We observe that a palindrome mirrors around its enter and therefore a palindrome can be expanded from its center and there are only 2n-1 such centers (for palindromes with an even number of letters like “abba” its center is in between two letters).</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="nc">String</span> <span class="nf">longestPalindrome</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
	<span class="k">if</span> <span class="o">(</span><span class="n">s</span><span class="o">==</span><span class="kc">null</span> <span class="o">||</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="o">)</span> <span class="k">return</span> <span class="s">""</span><span class="o">;</span>     <span class="c1">//edge case </span>
	<span class="kt">int</span> <span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="o">,</span> <span class="n">end</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
	<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
		<span class="kt">int</span> <span class="n">len1</span><span class="o">=</span><span class="n">expandAroundCenter</span><span class="o">(</span><span class="n">s</span><span class="o">,</span><span class="n">i</span><span class="o">,</span><span class="n">i</span><span class="o">);</span>
		<span class="kt">int</span> <span class="n">len2</span><span class="o">=</span><span class="n">expandAroundCenter</span><span class="o">(</span><span class="n">s</span><span class="o">,</span><span class="n">i</span><span class="o">,</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">);</span>
		<span class="kt">int</span> <span class="n">len</span><span class="o">=</span><span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">len1</span><span class="o">,</span><span class="n">len2</span><span class="o">);</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">len</span><span class="o">&gt;</span><span class="n">end</span><span class="o">-</span><span class="n">start</span><span class="o">)</span> <span class="o">{</span>
			<span class="n">start</span><span class="o">=</span> <span class="n">i</span><span class="o">-(</span><span class="n">len</span><span class="o">-</span><span class="mi">1</span><span class="o">)/</span><span class="mi">2</span><span class="o">;</span>
			<span class="n">end</span><span class="o">=</span><span class="n">i</span><span class="o">+</span><span class="n">len</span><span class="o">/</span><span class="mi">2</span>
		<span class="o">}</span>
	<span class="o">}</span>
	<span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="n">start</span><span class="o">,</span><span class="n">end</span><span class="o">+</span><span class="mi">1</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kt">int</span> <span class="nf">expandAroundCenter</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="kt">int</span> <span class="n">left</span><span class="o">,</span> <span class="kt">int</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
	<span class="kt">int</span> <span class="no">L</span><span class="o">=</span><span class="n">left</span><span class="o">,</span> <span class="no">R</span><span class="o">=</span><span class="n">right</span><span class="o">;</span>
	<span class="k">while</span><span class="o">(</span><span class="no">L</span><span class="o">&gt;=</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="no">R</span><span class="o">&lt;</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="no">L</span><span class="o">)==</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="no">R</span><span class="o">))</span> <span class="o">{</span>
		<span class="no">L</span><span class="o">--;</span>
		<span class="no">R</span><span class="o">++;</span>
	<span class="o">}</span>
	<span class="k">return</span> <span class="no">R</span><span class="o">-</span><span class="no">L</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><p><br /><br /> <a name="longestPalindromicSubstringManacherAlgorithm"></a></p><h2 id="manachers-algorithm"><span class="me-2">Manacher’s Algorithm</span><a href="#manachers-algorithm" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>There is an O(n) algorithm called Manacher’s algorithm, however, it is a non-trivial algorithm and no one would expect you to come up with this algorithm in a 45 minute coding session</p><p><br /><br /><br /> *** <a name="zigZagConversion"></a></p><h1 id="6-zigzag-conversion">6-ZigZag Conversion</h1><p>The string “PAYPALISHIRING” is written in a zigzag pattern on a given number of rows like this:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>P   A   H   N
A P L S I I G
Y   I   R
</pre></table></code></div></div><p>And then read line by line: “PAHNAPLSIIGYIR”. Write a code that will take a string and make this conversion given a number of rows:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>string convert(string s, int numRows);
</pre></table></code></div></div><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>Example 1: 

Input: s="PAYPALISHIRING", numRows=3
Output: "PAHNAPLSIIGYIR"
</pre></table></code></div></div><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre>Example 2:

Input: s="PAYPALISHIRING", numRows=4
Output: "PINALSIGYAHRPI"

Explanation:

P           I          N
A       L   S      I   G
Y   A       H   R
P           I
</pre></table></code></div></div><p><br /><br /> <a name="zigZagConversionSortbyRow"></a></p><h2 id="sort-by-row"><span class="me-2">Sort by Row</span><a href="#sort-by-row" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>By iterating through the string from left to right we can easily determine which row in the Zig-Zag pattern that a character belongs to</p><p><br /><br /> <em>Algorithm</em></p><p>We can use min(numRows,len(s)) lists to represent the non-empty rows of the Zig-Zag Pattern. Iterate through s from left to right appending each character to the appropriate row. The appropriate row can be tracked using two variables: the current row and the current direction.</p><p>The current direction only changes when we moved to the topmost row or moved down to the bottommost row</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="nc">String</span> <span class="nf">convert</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="kt">int</span> <span class="n">numRows</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">numRows</span><span class="o">==</span><span class="mi">1</span><span class="o">)</span> <span class="k">return</span> <span class="n">s</span><span class="o">;</span>		<span class="c1">//if there is only one row return string</span>

		<span class="nc">List</span><span class="o">&lt;</span><span class="nc">StringBuilder</span><span class="o">&gt;</span> <span class="n">rows</span><span class="o">=</span><span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
		<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">numRows</span><span class="o">,</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">());</span> <span class="n">i</span><span class="o">++){</span>
			<span class="n">rows</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">());</span>
		<span class="o">}</span>
		<span class="kt">int</span> <span class="n">curRow</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
		<span class="kt">boolean</span> <span class="n">goingDown</span><span class="o">=</span><span class="kc">false</span><span class="o">;</span>

		<span class="k">for</span><span class="o">(</span><span class="kt">char</span> <span class="nl">c:</span> <span class="n">s</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">())</span> <span class="o">{</span>
			<span class="n">rows</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">curRow</span><span class="o">).</span><span class="na">append</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>
			<span class="k">if</span> <span class="o">(</span><span class="n">curRow</span><span class="o">==</span><span class="mi">0</span> <span class="o">||</span> <span class="n">curRow</span><span class="o">==</span><span class="n">numRows</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
				<span class="n">goingDown</span><span class="o">=!</span><span class="n">goingDown</span><span class="o">;</span>
			<span class="o">}</span>
			<span class="n">curRow</span><span class="o">+=</span><span class="n">goingDown</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
		<span class="o">}</span>	

		<span class="nc">StringBuilder</span> <span class="n">ret</span><span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>
		<span class="k">for</span><span class="o">(</span><span class="nc">StringBuilder</span> <span class="nl">row:</span><span class="n">rows</span><span class="o">)</span> <span class="o">{</span>
			<span class="n">ret</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">row</span><span class="o">);</span>
		<span class="o">}</span>
		<span class="k">return</span> <span class="n">ret</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
	<span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><strong>Complexity Analysis</strong></p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>Time Complexity:  O(n)	where n==len(s)
Space Complexity: O(n)
</pre></table></code></div></div><p><br /><br /> <a name="zigZagConversionVisitbyRow"></a></p><h2 id="visit-by-row"><span class="me-2">Visit by Row</span><a href="#visit-by-row" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Visit the characters in the same order as reading the Zig-Zag pattern line by line</p><p><br /><br /> <em>Algorithm</em></p><p>Visit all characters in row 0 first, then row 1, then row 2, and so on. For all whole numbers k, * characters in row 0 are located at indexes k*(2*numRows-2) * characters in row numRows -1 are located at indexes k*(2*numRows-2)+ numRows -1 * characters in inner row i are located at indexes k*(2*numRows-2)+i and (k+1)(2*numRows-2)-i</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="nc">String</span> <span class="nf">convert</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="kt">int</span> <span class="n">numRows</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">numRows</span><span class="o">==</span><span class="mi">1</span><span class="o">)</span> <span class="k">return</span> <span class="n">s</span><span class="o">;</span> 

		<span class="nc">StringBuilder</span> <span class="n">ret</span><span class="o">=</span><span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>
		<span class="kt">int</span> <span class="n">n</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
		<span class="kt">int</span> <span class="n">cycleLen</span><span class="o">=</span> <span class="mi">2</span><span class="o">*</span> <span class="n">numRows</span> <span class="o">-</span><span class="mi">2</span><span class="o">;</span>

		<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">numRows</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
			<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="o">&lt;</span><span class="n">n</span><span class="o">;</span> <span class="n">j</span><span class="o">+=</span> <span class="n">cycleLen</span><span class="o">)</span> <span class="o">{</span>
				<span class="n">ret</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">+</span><span class="n">i</span><span class="o">));</span>
				<span class="k">if</span> <span class="o">(</span><span class="n">i</span><span class="o">!=</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">i</span><span class="o">!=</span><span class="n">numROws</span><span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">j</span><span class="o">+</span><span class="n">cycleLen</span><span class="o">-</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="o">)</span> <span class="o">{</span>
					<span class="n">ret</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">+</span><span class="n">cycleLen</span><span class="o">-</span><span class="n">i</span><span class="o">));</span>
				<span class="o">}</span>
			<span class="o">}</span>
			<span class="k">return</span> <span class="n">ret</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
		<span class="o">}</span>
	<span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><strong>Complexity Analysis</strong></p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>Time Complexity: O(n)	where n==len(s) Each index is visited once

Space Complexity: O(n) 	C++ implementation can achieve O(1) if the return string is not considered 
			extra space
</pre></table></code></div></div><p><br /><br /><br /> *** <a name="reverseInteger"></a></p><h1 id="7-reverse-integer">7-Reverse Integer</h1><p>Given a 32- bit signed integer, reverse digits of an integer.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>Example 1: 

Input: 123
Output: 321
</pre></table></code></div></div><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>Example 2: 

Input: -123
Output: -321
</pre></table></code></div></div><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>Example 3: 

Input: 120 
Output: 21
</pre></table></code></div></div><p>For the purpose of this problem assume that your function returns 0 when the reversed integer overflows</p><p><br /><br /> <a name="reverseIntegerPopandPush"></a></p><h2 id="pop-and-push-digits-and-check-before-overflow"><span class="me-2">Pop and Push Digits and Check Before Overflow</span><a href="#pop-and-push-digits-and-check-before-overflow" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>We can build up the reverse integer one digit at and time and before doing so we can check whether or not appedning another digit would cause overflow</p><p><br /><br /> <em>Algorithm</em></p><p>Reversing an integer can be done similarly to reversing a string. We want to repeatedly “pop” the last digit off of x and push it to the back of the rev so that in the end rev is the reverse of x.</p><p>To push and pop digits without the help of some auxiliar stack/array we can use math</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre>//pop operation: 
pop = x%10; 
x/=10;

//push operation:
temp=rev*10+pop;
rev =temp;
</pre></table></code></div></div><p>This statement is dangerous however as the statement temp=rev*10+pop may cause an overflow and luckily it is easy to check beforehand whether or not this statement would cause an overflow.</p><ol><li>If temp=rev*10+pop causes an overflow, then rev&gt;=INTMAX/10<li>If rev&gt; INTMAX/10, then temp=rev*10+pop is guaranteed to overflow<li>if rev==INTMAX/10, then temp=rev*10 + pop will overflow if an only if pop&gt;7</ol><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="kt">int</span> <span class="nf">reverse</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
		<span class="kt">int</span> <span class="n">rev</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> 
		<span class="k">while</span> <span class="o">(</span><span class="n">x</span><span class="o">!=</span><span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
			<span class="kt">int</span> <span class="n">pop</span><span class="o">=</span><span class="n">x</span><span class="o">%</span><span class="mi">10</span><span class="o">;</span>
			<span class="n">x</span><span class="o">/=</span><span class="mi">10</span><span class="o">;</span>
			<span class="k">if</span> <span class="o">(</span><span class="n">rev</span><span class="o">&gt;</span><span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">/</span><span class="mi">10</span><span class="o">||(</span><span class="n">rev</span><span class="o">==</span><span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">/</span><span class="mi">10</span> <span class="o">&amp;&amp;</span> <span class="n">pop</span><span class="o">&gt;</span><span class="mi">7</span><span class="o">))</span> <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
			<span class="k">if</span> <span class="o">(</span><span class="n">rev</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">.</span><span class="na">MIN_VALUE</span><span class="o">/</span><span class="mi">10</span><span class="o">||(</span><span class="n">rev</span><span class="o">==</span><span class="nc">Integer</span><span class="o">.</span><span class="na">MIN_VALUE</span><span class="o">/</span><span class="mi">10</span> <span class="o">&amp;&amp;</span> <span class="n">pop</span><span class="o">&lt;-</span><span class="mi">8</span><span class="o">))</span> <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
			<span class="n">rev</span><span class="o">=</span><span class="n">rev</span><span class="o">*</span><span class="mi">10</span> <span class="o">+</span><span class="n">pop</span><span class="o">;</span>
		<span class="o">}</span>
		<span class="k">return</span> <span class="n">rev</span><span class="o">;</span>
	<span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><strong>Complexity Analysis</strong></p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>Time Complexity:  O(log(x))	There are roughly log10(x) digits in x 
Space Complexity: O(1)
</pre></table></code></div></div><p><br /><br /><br /> *** <a name="stringtoInteger"></a></p><h1 id="8-string-to-integer-atoi">8-String to Integer (atoi)</h1><p>Implement atoi which converts a string to an integer</p><p>The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible and interprets them as a numerical value.</p><p>The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function.</p><p>If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exits because either str is empty or it contains only whitespace characters, no conversion is performed.</p><p>If no valid conversion could be performed a zero value is returned</p><p>Note:</p><ul><li>only the space character ‘ ‘ is considered as whitespace character<li>assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [-2^31, 2^31-1]. If the numerical value is out of the range of representable values, INT_MAX (2^31-1) or INT_MIN (-2^31) is returned</ul><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>	Example 1: 

	Input: "42"
	Output: 42
</pre></table></code></div></div><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>	Example 2: 

	Input: "      -42" 
	Output: -42
</pre></table></code></div></div><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>	Example 3:

	Input: "4193 with words "
	Output: 4193
</pre></table></code></div></div><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>	Example 4: 
	
	Input: "words and 987"
	Output: 0
</pre></table></code></div></div><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>	Example 5:
	
	Input: "-91283472332"
	Output: -2147483648 	//out of the range of a 32-bit signed integer so INT_MIN is returned
</pre></table></code></div></div><p><br /><br /> <a name="stringtoIntegerASCII"></a></p><h2 id="ascii-conversion"><span class="me-2">ASCII Conversion</span><a href="#ascii-conversion" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Recognize that ASCII characters are actually numbers and 0-9 digits are numbers starting from decimal 48 (0x30 hexadecimal)</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>	'0' is 48
	'1' is 49
	...
	'9' is 57
</pre></table></code></div></div><p>So to get the value of any character digit you can just remove the ‘0’</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>	'1' - '0' =&gt; 1
	49  -  48 =&gt; 1
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">int</span> <span class="nf">myAtoi</span><span class="o">(</span><span class="nc">String</span> <span class="n">str</span><span class="o">)</span> <span class="o">{</span>
	<span class="kt">int</span> <span class="n">index</span><span class="o">=</span><span class="mi">0</span><span class="o">,</span> <span class="n">sign</span><span class="o">=</span><span class="mi">1</span><span class="o">,</span> <span class="n">total</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
	
	<span class="c1">//1. Empty string </span>
	<span class="k">if</span> <span class="o">(</span><span class="n">str</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">==</span><span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>

	<span class="c1">//2. Remove Spaces </span>
	<span class="k">while</span><span class="o">(</span><span class="n">str</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">index</span><span class="o">)==</span><span class="sc">' '</span> <span class="o">&amp;&amp;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">str</span><span class="o">.</span><span class="na">length</span><span class="o">())</span>
		<span class="n">index</span><span class="o">++;</span>
	
	<span class="c1">//3. Handle signs </span>
	<span class="k">if</span> <span class="o">(</span><span class="n">str</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">index</span><span class="o">)==</span><span class="sc">'+'</span> <span class="o">||</span> <span class="n">str</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">index</span><span class="o">)==</span><span class="sc">'-'</span><span class="o">){</span>
		<span class="n">sign</span><span class="o">=</span> <span class="n">str</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">index</span><span class="o">)</span> <span class="o">==</span> <span class="sc">'+'</span> <span class="o">?</span> <span class="mi">1</span><span class="o">:-</span><span class="mi">1</span><span class="o">;</span>
		<span class="n">index</span><span class="o">++;</span>
	<span class="o">}</span>

	<span class="c1">//4. COnvert number and avoid overflow</span>
	<span class="k">while</span><span class="o">(</span><span class="n">index</span><span class="o">&lt;</span><span class="n">str</span><span class="o">.</span><span class="na">length</span><span class="o">()){</span>
		<span class="kt">int</span> <span class="n">digit</span><span class="o">=</span> <span class="n">str</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">index</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'0'</span><span class="o">;</span> 
		<span class="k">if</span> <span class="o">(</span><span class="n">digit</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">||</span><span class="n">digit</span><span class="o">&gt;</span><span class="mi">9</span><span class="o">)</span> <span class="k">break</span><span class="o">;</span>

		<span class="c1">//check if total will overflow after 10 times and add digit</span>
		<span class="k">if</span> <span class="o">(</span><span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">/</span><span class="mi">10</span> <span class="o">&lt;</span> <span class="n">total</span> <span class="o">||</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">/</span><span class="mi">10</span> <span class="o">==</span> <span class="n">total</span> 
		    <span class="o">&amp;&amp;</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">%</span><span class="mi">10</span><span class="o">&lt;</span><span class="n">digit</span><span class="o">)</span> <span class="o">{</span>    
		    <span class="k">return</span> <span class="n">sign</span><span class="o">==</span><span class="mi">1</span> <span class="o">?</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span> <span class="o">:</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MIN_VALUE</span><span class="o">;</span>
		<span class="o">}</span>
		<span class="n">total</span><span class="o">=</span> <span class="mi">10</span><span class="o">*</span> <span class="n">total</span><span class="o">+</span><span class="n">digit</span><span class="o">;</span>
		<span class="n">index</span><span class="o">++;</span>
	<span class="o">}</span>
	<span class="k">return</span> <span class="n">total</span><span class="o">*</span><span class="n">sign</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><p><br /><br /><br /> *** <a name="palindromeNumber"></a></p><h1 id="9-palindrome-number">9-Palindrome Number</h1><p>Determines whether an interger is a palindrome. An integer is a palindrome when it reads the same backward as forward.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>Example 1: 

Input: 121
Output: true
</pre></table></code></div></div><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre>Example 2: 

Input: -121
Output: false 
Explanation: 	From left to right, it reads -121, meanwhile from right to left it becomes 121- . 
		Therefore it is not a palindrome
</pre></table></code></div></div><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>Example 3: 

Input: 10 
Output: false 
Explanation: 	Reads 01 from right to left. Therefore it is not a palindrome
</pre></table></code></div></div><p><br /><br /> <a name="palindromeNumberRevertHalf"></a></p><h2 id="revert-half-of-the-number"><span class="me-2">Revert Half of the Number</span><a href="#revert-half-of-the-number" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>A first idea which may come to mind is to convert the number into a string and check if the string is a palindrome but this would require extra non-constant space for creating the string not allowed by the problem description</p><p>Second idea would be reverting the number itself and comparing the number with the original number, if they are the same then the number is a palindrome, however if the reversed number is larger than int.MAX we will hit integer overflow problem.</p><p>To avoid the overflow issue of the reverted number, what if we only revert half of the int number? The reverse of the last half of the palindrome should be the same as the first half of the number if the number is a palindrome.</p><p>If the input is 1221, if we can revert the last part of the number “1221” from “21” to “12” and compare it with the first half of the number “12”, since 12 is the same as 12, we know that the number is a palindrome.</p><p><br /><br /> <em>Algorithm</em></p><p>At the very beginning we can deal with some edge cases. All negative numbers are not palindrome and numbers ending in zero can only be a palindrome if the first digit is also 0 (only 0 satisfies this property)</p><p>Now let’s think about how to revert the last half of the number. For the number 1221 if we do 1221%10 we get the last digit 1. To get the second last digit we divide the number by 10 1221/10=122 and then we can get the last digit again by doing a modulus by 10, 122%10=2. If we multiply the last digit by 10 and add the second last digit 1*10+2=12 which gives us the reverted number we want. COntinuing this process would give us the reverted number with more digits.</p><p>Next is how do we know that we’ve reached the half of the number? Since we divided the number by 10 and multiplied the reversed number by 10 when the original number is less than the reversed number, it means we’ve gone through half of the number digits.</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isPalindrome</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">x</span><span class="o">&lt;</span><span class="mi">0</span> <span class="o">||</span> <span class="o">(</span><span class="n">x</span><span class="o">%</span><span class="mi">10</span><span class="o">==</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">x</span><span class="o">!=</span><span class="mi">0</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>
        
        <span class="kt">int</span> <span class="n">revertedNumber</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">x</span><span class="o">&gt;</span><span class="n">revertedNumber</span><span class="o">){</span>
            <span class="n">revertedNumber</span><span class="o">=</span><span class="n">x</span><span class="o">%</span><span class="mi">10</span><span class="o">+</span><span class="n">revertedNumber</span><span class="o">*</span><span class="mi">10</span><span class="o">;</span>
            <span class="n">x</span><span class="o">/=</span><span class="mi">10</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">//when the length is an odd number, we can get rid of the middle digit by </span>
        <span class="c1">//revertedNumber/10</span>
        
        <span class="c1">//For example when the input is 12321, at the end of the while loop we get x=12, </span>
        <span class="c1">//revertedNumber=123, since the middle digit doesn't matter in a palindrome we can</span>
        <span class="c1">//simply get rid of it </span>
        
        <span class="k">return</span> <span class="n">x</span><span class="o">==</span><span class="n">revertedNumber</span><span class="o">||</span><span class="n">x</span><span class="o">==</span><span class="n">revertedNumber</span><span class="o">/</span><span class="mi">10</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><br /><br /><br /> *** <a name="regularExpressionMatching"></a></p><h1 id="10-regular-expression-matching">10-Regular Expression Matching</h1><p>Given an input string (s) and a pattern (p), implement regular expression matching with support for ‘.’ and ‘*’</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>	'.' Matches any single character
	'*' Matches zero or more of the preceding element 
</pre></table></code></div></div><p>The matching should cover the entire input string (not partial)</p><p>Note:</p><ul><li>s could be empty and contains only lower case letters a-z<li>p could be empty and contains only lower case letters a-z and characters like . or *</ul><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre>Example 1: 

Input:
	s="aa" 
	p="a" 
	Output: false 
	Explanation: 	"a" does not match the entire string "aa" 
</pre></table></code></div></div><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre>Example 2: 

Input: 
	s="aa"
	p="a*" 
	Output: true 
	Explanation: 	'*' means zero of more of the preceding element, 'a'. Therefore, by repeating
			'a' once it becomes "aa"
</pre></table></code></div></div><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre>Example 3: 

Input: 
	s="ab" 
	p=".*" 
	Output: true 
	Explanation: 	'.*' means "zero or more (*) of any character (.)"
</pre></table></code></div></div><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre>Example 4: 

Input: 
	s="aab" 
	p="c*a*b" 
	Output: true
	Explanation: 	c can be repeated 0 times, a can be repeated 1 time. Therefore it matches 
			"aab" 
</pre></table></code></div></div><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre>Example 5: 

Input: 
	s="mississippi" 
	p="mis*is*p*."
	Output: false 
</pre></table></code></div></div><p><br /><br /> <a name="regularExpressionMatchingRecursion"></a></p><h2 id="recursion"><span class="me-2">Recursion</span><a href="#recursion" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>If there were no Kleene stars (the * wildcard characters for regular expressions), the problem would be easier- we simply check from left to right if each character of the text matches the pattern. When a star is present we may need to check for may different suffixes of the text and see if they match the rest of the pattern. A recursive solution is a straightforward way to represent this relationship</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isMatch</span><span class="o">(</span><span class="nc">String</span> <span class="n">text</span><span class="o">,</span> <span class="nc">String</span> <span class="n">pattern</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">pattern</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="k">return</span> <span class="n">text</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">();</span> 
		
		<span class="kt">boolean</span> <span class="n">first_match</span><span class="o">=(!</span><span class="n">text</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">&amp;&amp;</span> 
				    <span class="o">(</span><span class="n">pattern</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="mi">0</span><span class="o">)==</span><span class="n">text</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="o">||</span> <span class="n">pattern</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="mi">0</span><span class="o">)==</span><span class="sc">'.'</span><span class="o">));</span>

		<span class="k">if</span> <span class="o">(</span><span class="n">pattern</span><span class="o">.</span><span class="na">length</span><span class="o">()&gt;=</span><span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="n">pattern</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span> <span class="o">==</span><span class="sc">'*'</span><span class="o">){</span>
			<span class="k">return</span> <span class="o">(</span><span class="n">isMatch</span><span class="o">(</span><span class="n">text</span><span class="o">,</span><span class="n">pattern</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="mi">2</span><span class="o">))||</span>
			       <span class="o">(</span><span class="n">first_match</span> <span class="o">&amp;&amp;</span> <span class="n">isMatch</span><span class="o">(</span><span class="n">text</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="mi">1</span><span class="o">),</span><span class="n">pattern</span><span class="o">)));</span>
		
		<span class="c1">//note: pattern.substring(2) returns all of the characters after index 2 of pattern</span>
		<span class="o">}</span>
		<span class="k">else</span> <span class="o">{</span>
			<span class="k">return</span> <span class="n">first_match</span> <span class="o">&amp;&amp;</span> <span class="n">isMatch</span><span class="o">(</span><span class="n">text</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="mi">1</span><span class="o">),</span> <span class="n">pattern</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="mi">1</span><span class="o">));</span>
		<span class="o">}</span>
		
	<span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><strong>Complexity Analysis</strong></p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre>Time Complexity: 	Let T, P be the lengths of the text and the pattern respectively. In the worst
			case, a call to match(text[i:],pattern[2j:]) will be made (i+j i) times, and 
			strings of the order O(T-i) and O(P-2*j) will be made. Thus the complexity has
			the order: 

			summation from i=0 to T * summation from j=0 to P/2 * (i+j i) O(T+P-i-2j).

			We can show that this is bounded by O((T+P)2^(T+P/2))

Space Complexity:	For every call to match, we will create those strings as described above 
			possibly creating duplicates. If memory is not freed, this will also take a
			total of O((T+P)2^(T+P/2)) space even though there are only order O(T^2+P^2) 
			unique suffixes of P and T that are actually required 
</pre></table></code></div></div><p><br /><br /> <a name="regularExpressionMatchingDynamicProgramming"></a></p><h2 id="dynamic-programming-1"><span class="me-2">Dynamic Programming</span><a href="#dynamic-programming-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>As the problem has an optimal substructure, it is natural to cache intermediate results. We ask the question dp(i,j): does text[i:] and pattern[j:] match? We can describe our answer in terms of answers to questions involving smaller strings</p><p><br /><br /> <em>Algorithm</em></p><p>We proceed with the same recursion as in Approach 1, except because calls will only ever be made to match(text[i:], pattern[j:]), we use dp(i,j) to handle those calls instead, saving us expensive string-building operations and allowing us to cache the intermediate results</p><p><strong>Java Top-Down Variation</strong></p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
</pre><td class="rouge-code"><pre><span class="kd">enum</span> <span class="nc">Result</span> <span class="o">{</span>
	<span class="no">TRUE</span><span class="o">,</span> <span class="no">FALSE</span>
	
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
	<span class="nc">Result</span><span class="o">[][]</span> <span class="n">memo</span><span class="o">;</span> 

	<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isMatch</span><span class="o">(</span><span class="nc">String</span> <span class="n">text</span><span class="o">,</span> <span class="nc">String</span> <span class="n">pattern</span><span class="o">)</span> <span class="o">{</span> 
		<span class="n">memo</span><span class="o">=</span><span class="k">new</span> <span class="nc">Result</span><span class="o">[</span><span class="n">text</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">+</span><span class="mi">1</span><span class="o">][</span><span class="n">pattern</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">+</span><span class="mi">1</span><span class="o">];</span>
		<span class="k">return</span> <span class="nf">dp</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="n">text</span><span class="o">,</span><span class="n">pattern</span><span class="o">);</span>
	<span class="o">}</span>

	<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">dp</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">j</span><span class="o">,</span> <span class="nc">String</span> <span class="n">text</span><span class="o">,</span> <span class="nc">String</span> <span class="n">pattern</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">memo</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]!=</span><span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
			<span class="k">return</span> <span class="n">memo</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]==</span><span class="nc">Result</span><span class="o">.</span><span class="na">TRUE</span><span class="o">;</span>
		<span class="o">}</span>
		<span class="kt">boolean</span> <span class="n">ans</span><span class="o">;</span> 
		<span class="k">if</span> <span class="o">(</span><span class="n">j</span><span class="o">==</span><span class="n">pattern</span><span class="o">.</span><span class="na">length</span><span class="o">()){</span>
			<span class="n">ans</span><span class="o">=</span><span class="n">i</span><span class="o">==</span><span class="n">text</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
		<span class="o">}</span>
		<span class="k">else</span> <span class="o">{</span>
			<span class="kt">boolean</span> <span class="n">first_match</span><span class="o">=(</span><span class="n">i</span><span class="o">&lt;</span><span class="n">text</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">pattern</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">)</span> <span class="o">==</span> <span class="n">text</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">||</span>
					     <span class="n">patter</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">)</span> <span class="o">==</span> <span class="sc">'.'</span><span class="o">));</span>

			<span class="k">if</span> <span class="o">(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="o">&lt;</span><span class="n">pattern</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">pattern</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="o">)==</span><span class="sc">'*'</span><span class="o">){</span>
				<span class="n">ans</span><span class="o">=(</span><span class="n">dp</span><span class="o">(</span><span class="n">i</span><span class="o">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span><span class="n">text</span><span class="o">,</span><span class="n">pattern</span><span class="o">)||</span><span class="n">first_match</span><span class="o">&amp;&amp;</span> <span class="n">dp</span><span class="o">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span><span class="n">j</span><span class="o">,</span><span class="n">text</span><span class="o">,</span><span class="n">pattern</span><span class="o">));</span>
			<span class="o">}</span>
			<span class="k">else</span> <span class="o">{</span>
				<span class="n">ans</span><span class="o">=</span><span class="n">first_match</span> <span class="o">&amp;&amp;</span> <span class="n">dp</span><span class="o">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">text</span><span class="o">,</span> <span class="n">pattern</span><span class="o">);</span> 
			<span class="o">}</span>
		<span class="o">}</span>
		<span class="n">memo</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]=</span><span class="n">ans</span><span class="o">?</span> <span class="nc">Result</span><span class="o">.</span><span class="na">TRUE</span><span class="o">:</span> <span class="nc">Result</span><span class="o">.</span><span class="na">FALSE</span><span class="o">;</span> 
		<span class="k">return</span> <span class="n">ans</span><span class="o">;</span> 
	<span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><strong>Complexity Analysis</strong></p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>Time Complexity: 	Let T, P be the lengths of the text and the pattern respectively. The work 
			for every call to dp(i,j) for i=0,...,T; j=0,...,P is done once and it is O(1) 				work. Hence the time complexity is O(TP)

Space Complexity:	The only memory we use is the O(TP) boolean entries in our cache. Hence, the 
			space complexity is O(TP) 
</pre></table></code></div></div><p><br /><br /> <a name="regularExpressionMatchingNonRecursive"></a></p><h2 id="non-recursive"><span class="me-2">Non-Recursive</span><a href="#non-recursive" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>The recursive programming solutions are pretty confusing so this implementation uses 2D arrays and Dynamic Programming</p><p>The logic works as follows:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre>1. If p.charAt(j) == s.charAt(i) : dp[i][j] = dp[i-1][j-1]; 
2. If p.charAt(j) == '.' : dp[i][j] = dp[i-1][j-1]; 
3. If p.charAt(j) == '*': 
	
	Subconditions
	1. If p.charAt(j-1)!= s.charAt(i):dp[i][j]=dp[i][j-2]  	//in this case a* only counts as empty
	2. If p.charAt(i-1)== s.charAt(i) or p.charAt(i-1) == '.': 
		
		dp[i][j] = dp[i-1][j]	//in this case a* counts as multiple a 
	     or dp[i][j] = dp[i][j-1]	//in this case a* counts as single a 
	     or dp[i][j] = dp[i][j-2]	//in this case a* counts as empty 
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isMatch</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="nc">String</span> <span class="n">p</span><span class="o">)</span> <span class="o">{</span>
	<span class="k">if</span> <span class="o">(</span><span class="n">s</span><span class="o">==</span><span class="kc">null</span> <span class="o">||</span> <span class="n">p</span><span class="o">==</span><span class="kc">null</span><span class="o">){</span>
		<span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
	<span class="o">}</span>
	<span class="kt">boolean</span><span class="o">[][]</span> <span class="n">dp</span><span class="o">=</span><span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()+</span><span class="mi">1</span><span class="o">][</span><span class="n">p</span><span class="o">.</span><span class="na">length</span><span class="o">()+</span><span class="mi">1</span><span class="o">];</span>
	<span class="n">dp</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="mi">0</span><span class="o">]=</span><span class="kc">true</span><span class="o">;</span> 
	<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">p</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span><span class="o">++){</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)==</span><span class="sc">'*'</span> <span class="o">&amp;&amp;</span> <span class="n">dp</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">]){</span>
			<span class="n">dp</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">]=</span><span class="kc">true</span><span class="o">;</span> 
		<span class="o">}</span>
	<span class="o">}</span>
	<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span><span class="n">i</span><span class="o">++){</span>
		<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">p</span><span class="o">.</span><span class="na">length</span><span class="o">();</span><span class="n">j</span><span class="o">++){</span>
			<span class="k">if</span> <span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">)==</span><span class="sc">'.'</span><span class="o">){</span>
				<span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="o">]=</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">];</span>
			<span class="o">}</span>
			<span class="k">if</span> <span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">)==</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)){</span>
				<span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="o">]=</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">];</span>
			<span class="o">}</span>
			<span class="k">if</span> <span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">)==</span><span class="sc">'*'</span><span class="o">){</span>
				<span class="k">if</span> <span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">)!=</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">!=</span><span class="sc">'.'</span><span class="o">){</span>
					<span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="o">]=</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">];</span>
				<span class="o">}</span>
				<span class="k">else</span><span class="o">{</span>
					<span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="o">]=(</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">||</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="o">]</span> <span class="o">||</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">]);</span>
				<span class="o">}</span>
			<span class="o">}</span>
		<span class="o">}</span>
	<span class="o">}</span>
	<span class="k">return</span> <span class="n">dp</span><span class="o">[</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()][</span><span class="n">p</span><span class="o">.</span><span class="na">length</span><span class="o">()];</span>
<span class="o">}</span>
</pre></table></code></div></div><p><br /><br /><br /> *** <a name="containerwiththeMostWater"></a></p><h1 id="11-container-with-the-most-water">11-Container with the Most Water</h1><p>Given n non negative integers a1,a2, … , an where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forns a container such that the container contains the most water.</p><p>```Example: The array [1,8,6,2,5,4,8,3,7] would have a max area of water which is 49.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>	      ^		    ^
 These two values form the container which could hold water at a max height of 7, these values
 are also 7 array indexes apart from each other so it could hold water at a max width of 7. The
 area of water which could be held is thus 7 x 7 = 49 ```
</pre></table></code></div></div><p><a name="containerwiththeMostWaterBruteForce"></a></p><h2 id="brute-force-3"><span class="me-2">Brute Force</span><a href="#brute-force-3" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>In this case we simply consider the area for every possible pair of the lines and find out the maximum area out of those.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre>public class Solution {
	public int maxArea(int[] height) {
		int maxarea=0; 
		for (int i=0; i&lt;height.length; i++){
			for (int j=i+1;j&lt;height.length;j++){
				maxarea=Math.max(maxarea, Math.min(height[i],height[j])*(j-i));
			}
		}
		return maxarea;
	}
}
</pre></table></code></div></div><p><strong>Complexity Analysis</strong></p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>Time complexity: 	O(n^2) 	Calculating the area for all n(n-1)/2 height pairs 
Space complexity: 	O(1) 	Constant extra space is used 
</pre></table></code></div></div><p><br /><br /> <a name="containerwiththeMostWaterTwoPointer"></a></p><h2 id="two-pointer-approach"><span class="me-2">Two Pointer Approach</span><a href="#two-pointer-approach" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>The intuition behind this approach is that the area formed between the lines will always be limited by the height of the shorter line. Further, the farther the lines, the more will be the area obtained.</p><p>We take two pointers, one at the beginning and one at the end of the array constituting the length of the lines. Further, we maintain a variable maxarea to store the maximum area obtained till now. At every step, we find out the area formed between them, update maxarea and move the pointer pointing to the shorter line towards the other end by one step.</p><p>Initially we consider the area constituting the exterior most lines. Now to maximize the area we need to consider the area between the lines of larger lengths. If we try to move the pointer at the longer line inwards, we won’t gain any increase in area, since it is limited by the shorter line. But moving the shorter line’s pointer could turn out to be benefical, as per the same argument, despite the reduction in width. This is done since a relatively longer line obtained by moving the shorter line’s pointer might overcome the reduction in area caused by the width reduction.</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="kt">int</span> <span class="nf">maxArea</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">height</span><span class="o">)</span> <span class="o">{</span>
		<span class="kt">int</span> <span class="n">maxarea</span><span class="o">=</span><span class="mi">0</span><span class="o">,</span> <span class="n">l</span><span class="o">=</span><span class="mi">0</span><span class="o">,</span> <span class="n">r</span><span class="o">=</span><span class="n">height</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span> 
		<span class="k">while</span> <span class="o">(</span><span class="n">l</span><span class="o">&lt;</span><span class="n">r</span><span class="o">){</span>
			<span class="n">maxarea</span><span class="o">=</span><span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">maxarea</span><span class="o">,</span><span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">height</span><span class="o">[</span><span class="n">l</span><span class="o">],</span><span class="n">height</span><span class="o">[</span><span class="n">r</span><span class="o">])*(</span><span class="n">r</span><span class="o">-</span><span class="n">l</span><span class="o">));</span>
			<span class="k">if</span> <span class="o">(</span><span class="n">height</span><span class="o">[</span><span class="n">l</span><span class="o">]&lt;</span><span class="n">height</span><span class="o">[</span><span class="n">r</span><span class="o">]){</span>
				<span class="n">l</span><span class="o">++;</span>
			<span class="o">}</span>
			<span class="k">else</span><span class="o">{</span>
				<span class="n">r</span><span class="o">--;</span>
			<span class="o">}</span>
		<span class="o">}</span>
		<span class="k">return</span> <span class="n">maxarea</span><span class="o">;</span> 
	<span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><strong>Complexity Analysis</strong></p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>Time complexity: 	O(n) 	Single pass
Space complexity: 	O(1) 	Constant space is used 
</pre></table></code></div></div><p><br /><br /><br /> *** <a name="integertoRoman"></a></p><h1 id="12-integer-to-roman">12-Integer To Roman</h1><p>Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre>Symbol		Value 
I		1
V		5
X		10
L		50
C		100
D		500
M		1000
</pre></table></code></div></div><p>For example, two is written as II in Roman numeral, just two one’s added together. Twelve is written as XII which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.</p><p>Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine which is written as IX. There are six instances where subtraction is used:</p><ul><li>I can be placed before V (5) and X (10) to make 4 and 9<li>X can be placed before L (50) and C(100) to make 40 and 90<li>C can be placed before D (500) and M(1000) to make 400 and 900</ul><p>Given an integer, convert it to a roman numeral, input is guaranteed to be within the range from 1 to 3999</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>Example 1: 

Input: 3 
Output: "III" 
</pre></table></code></div></div><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>Example 2: 

Input: 4
Output: "IV" 
</pre></table></code></div></div><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>Example 3: 

Input: 9 
Output: "IX" 
</pre></table></code></div></div><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>Example 4: 

Input: 58 
Output: "LVIII" 
Explanation: L=50, V=5, III=3
</pre></table></code></div></div><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>Example 5: 

Input: 1994
Output: "MCMXCIV"
Explanation: M=1000, CM=900, XC=90 and IV=4 
</pre></table></code></div></div><p><a name="integertoRomanStringArray"></a></p><h2 id="string-array"><span class="me-2">String Array</span><a href="#string-array" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">static</span> <span class="nc">String</span> <span class="nf">intToRoman</span><span class="o">(</span><span class="kt">int</span> <span class="n">num</span><span class="o">)</span> <span class="o">{</span> 
	
	<span class="nc">String</span> <span class="no">M</span><span class="o">[]={</span><span class="s">""</span><span class="o">,</span> <span class="s">"M"</span><span class="o">,</span> <span class="s">"MM"</span><span class="o">,</span> <span class="s">"MMM"</span><span class="o">};</span>
	<span class="c1">//represents 1000, 2000, and 3000 since we know the number is in the range 1 to 3999</span>
	
	<span class="nc">String</span> <span class="no">C</span><span class="o">[]={</span><span class="s">""</span><span class="o">,</span> <span class="s">"C"</span><span class="o">,</span> <span class="s">"CC"</span><span class="o">,</span> <span class="s">"CCC"</span><span class="o">,</span> <span class="s">"CD"</span><span class="o">,</span> <span class="s">"D"</span><span class="o">,</span> <span class="s">"DC"</span><span class="o">,</span> <span class="s">"DCC"</span><span class="o">,</span> <span class="s">"DCCC"</span><span class="o">,</span> <span class="s">"CM"</span><span class="o">};</span>
	<span class="c1">//represents 0, 100,  200,   300,  400, 500,  600,   700,    800,  900</span>

	<span class="nc">String</span> <span class="no">X</span><span class="o">[]={</span><span class="s">""</span><span class="o">,</span> <span class="s">"X"</span><span class="o">,</span> <span class="s">"XX"</span><span class="o">,</span> <span class="s">"XXX"</span><span class="o">,</span> <span class="s">"XL"</span><span class="o">,</span> <span class="s">"L"</span><span class="o">,</span> <span class="s">"LX"</span><span class="o">,</span> <span class="s">"LXX"</span><span class="o">,</span> <span class="s">"LXXX"</span><span class="o">,</span> <span class="s">"XC"</span><span class="o">};</span>
	<span class="c1">//represents 0,  10,   20,    30,   40,  50,   60,    70,     80,   90</span>

	<span class="nc">String</span> <span class="no">I</span><span class="o">[]={</span><span class="s">""</span><span class="o">,</span> <span class="s">"I"</span><span class="o">,</span> <span class="s">"II"</span><span class="o">,</span> <span class="s">"III"</span><span class="o">,</span> <span class="s">"IV"</span><span class="o">,</span> <span class="s">"V"</span><span class="o">,</span> <span class="s">"VI"</span><span class="o">,</span> <span class="s">"VII"</span><span class="o">,</span> <span class="s">"VIII"</span><span class="o">,</span> <span class="s">"IX"</span><span class="o">};</span> 
	<span class="c1">//represents 0,   1,    2,     3,    4,  5,    6,     7,      8,    9</span>

	<span class="k">return</span> <span class="no">M</span><span class="o">[</span><span class="n">num</span><span class="o">/</span><span class="mi">1000</span><span class="o">]</span> <span class="o">+</span> <span class="no">C</span><span class="o">[(</span><span class="n">num</span><span class="o">%</span><span class="mi">1000</span><span class="o">)/</span><span class="mi">100</span><span class="o">]</span> <span class="o">+</span> <span class="no">X</span><span class="o">[(</span><span class="n">num</span><span class="o">%</span><span class="mi">100</span><span class="o">)/</span><span class="mi">10</span><span class="o">]</span> <span class="o">+</span> <span class="no">I</span><span class="o">[</span><span class="n">num</span><span class="o">%</span><span class="mi">10</span><span class="o">];</span> 
<span class="o">}</span> 
</pre></table></code></div></div><p><br /><br /><br /> *** <a name="romantoInteger"></a></p><h1 id="13-roman-to-integer">13-Roman to Integer</h1><p>Roman numerals are represented by seven different symbols I, V, X, L, C, D and M</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre>Symbol 		Value 
I		1
V		5
X		10 
L		50
C		100
D		500
M		1000
</pre></table></code></div></div><p>For example, two is written as II in Roman numeral, just two one’s added together. Twelve is written as XII which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.</p><p>Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine which is written as IX. There are six instances where subtraction is used:</p><ul><li>I can be placed before V (5) and X (10) to make 4 and 9<li>X can be placed before L (50) and C(100) to make 40 and 90<li>C can be placed before D (500) and M(1000) to make 400 and 900</ul><p>Given an integer, convert it to a roman numeral, Input is guaranteed to be within the range from 1 to 3999</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>Example 1: 
	
Input: "III" 
Output: 3 
</pre></table></code></div></div><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>Example 2: 

Input: "IV" 
Output: 4
</pre></table></code></div></div><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>Example 3: 

Input: "IX" 
Output: 9 
</pre></table></code></div></div><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>Example 4: 

Input: "LVIII" 
Output: 58 
Explanation: L=50, V=5, III=3
</pre></table></code></div></div><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>Example 5: 

Input: "MCMXCIV" 
Output: 1994
Explanation: M=1000, CM=900, XC=90 and IV=4
</pre></table></code></div></div><p><br /><br /> <a name="romantoIntegerCharacterArray"></a></p><h2 id="character-array"><span class="me-2">Character Array</span><a href="#character-array" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="kt">int</span> <span class="nf">romanToInt</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
		<span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">();</span> 
		<span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="sc">'I'</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span> 
		<span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="sc">'V'</span><span class="o">,</span> <span class="mi">5</span><span class="o">);</span> 
		<span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="sc">'X'</span><span class="o">,</span> <span class="mi">10</span><span class="o">);</span> 
		<span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="sc">'L'</span><span class="o">,</span> <span class="mi">50</span><span class="o">);</span> 
		<span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="sc">'C'</span><span class="o">,</span> <span class="mi">100</span><span class="o">);</span> 
		<span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="sc">'D'</span><span class="o">,</span> <span class="mi">500</span><span class="o">);</span> 
		<span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="sc">'M'</span><span class="o">,</span> <span class="mi">1000</span><span class="o">);</span> 

		<span class="kt">char</span><span class="o">[]</span> <span class="n">sc</span><span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">();</span> 
		<span class="kt">int</span> <span class="n">total</span><span class="o">=</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">sc</span><span class="o">[</span><span class="mi">0</span><span class="o">]);</span> 
		<span class="kt">int</span> <span class="n">pre</span><span class="o">=</span><span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">sc</span><span class="o">[</span><span class="mi">0</span><span class="o">]);</span> 
		<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">sc</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
			<span class="kt">int</span> <span class="n">curr</span><span class="o">=</span><span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">sc</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span> 
			<span class="k">if</span> <span class="o">(</span><span class="n">curr</span><span class="o">&lt;=</span><span class="n">pre</span><span class="o">)</span> <span class="o">{</span>
				<span class="n">total</span><span class="o">=</span> <span class="n">total</span> <span class="o">+</span> <span class="n">curr</span><span class="o">;</span> 
			<span class="o">}</span>
			<span class="k">else</span> <span class="o">{</span>
				<span class="n">total</span><span class="o">=</span><span class="n">total</span><span class="o">+</span><span class="n">curr</span> <span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">pre</span><span class="o">;</span> 
			<span class="o">}</span>
			<span class="n">pre</span><span class="o">=</span><span class="n">curr</span><span class="o">;</span> 
		<span class="o">}</span>
		<span class="k">return</span> <span class="n">total</span><span class="o">;</span> 
	<span class="o">}</span>

<span class="o">}</span>
</pre></table></code></div></div><p><br /><br /><br /> *** <a name="longestCommonPrefix"></a></p><h1 id="14-longest-common-prefix">14-Longest Common Prefix</h1><p>Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string “”</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>Example 1: 

Input: ["flower", "flow", "flight"]
Output: "fl"
</pre></table></code></div></div><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre>Example 2: 

Input: ["dog", "racecar", "car"] 
Output: ""

Explanation: There is no common prefix among the input strings 
</pre></table></code></div></div><p><em>Note:</em> All given inputs are in lowercase letters a-z</p><p><br /><br /> <a name="longestCommonPrefixHorizontalScanning"></a></p><h2 id="horizontal-scanning"><span class="me-2">Horizontal Scanning</span><a href="#horizontal-scanning" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><br /> <em>Intuition:</em></p><p>For a start we will describe a simple way of find the longest prefix shared by a set of strings LCP(S1 … Sn).We will use the observation that:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>LCP(S1 ... Sn) = LCP(LCP(LCP(S1, S2), S3), ... Sn) 
</pre></table></code></div></div><p><br /><br /> <em>Algorithm:</em></p><p>To employ this idea, the algorithm iterates through the strings [S1 … Sn]. finding at each iteration i the longest common prefix of strings LCP(S1 … Si). When LCP(S1 … Si) is an empty string, the algorithm ends. Otherwise after n iterations, the algorithm returns LCP(S1 … Sn)</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre>
Example: 

{leets, leetcode, leet, leeds}
   \       /      
  LCP{1,2} = leets
  	     leetcode
	     leet 

	 	\	{leets, leetcode, leet, leeds}
		 \ 			   /

		 LCP{1,3} = leet
		 	    leet
			    leet

			      \          {leets, leetcode, leet, leeds}
			       \ 				  /
			       LCP{1,4}   leet
			       		  leeds
					  lee

				LCP{1,4} = "lee"
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="nc">String</span> <span class="n">longestCommon</span> <span class="nf">Prefix</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">strs</span><span class="o">){</span>
	<span class="k">if</span> <span class="o">(</span><span class="n">strs</span><span class="o">.</span><span class="na">length</span><span class="o">==</span><span class="mi">0</span><span class="o">){</span>
		<span class="k">return</span> <span class="s">""</span><span class="o">;</span> 
	<span class="o">}</span>
	<span class="nc">String</span> <span class="n">prefix</span><span class="o">=</span><span class="n">strs</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span> 
	<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">strs</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
		<span class="k">while</span> <span class="o">(</span><span class="n">strs</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">indexOf</span><span class="o">(</span><span class="n">prefix</span><span class="o">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
			<span class="n">prefix</span><span class="o">=</span><span class="n">prefix</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">prefix</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span><span class="mi">1</span><span class="o">);</span>
			<span class="k">if</span> <span class="o">(</span><span class="n">prefix</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
				<span class="k">return</span> <span class="s">""</span><span class="o">;</span>
			<span class="o">}</span>
		<span class="o">}</span>
		<span class="k">return</span> <span class="n">prefix</span><span class="o">;</span> 
	<span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><strong>Complexity Analysis</strong></p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre>Time complexity: 	O(S)	Where S is the sum of all characters in all strings. In the worse case
				all n strings are the same. The algorithm compares the string S1 with 
				the other strings [S2 ... Sn]. There are S character comparisons where
				S is the sum of all characters in the input array 

Space complexity: 	O(1) 	We only used constant extra space 
</pre></table></code></div></div><p><br /><br /> <a name="longestCommonPrefixVerticalScanning"></a></p><h2 id="vertical-scanning"><span class="me-2">Vertical Scanning</span><a href="#vertical-scanning" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Imagine a very short string is at the end of the array. The above approach will still do S comparisons. One way to optimize this case is to do vertical scanning. We compare characters from top to bottom on the same column (same character index of the strings) before moving on to the next column.</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="nc">String</span> <span class="nf">longestCommonPrefix</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">strs</span><span class="o">)</span> <span class="o">{</span>
	<span class="k">if</span> <span class="o">(</span><span class="n">strs</span><span class="o">==</span><span class="kc">null</span> <span class="o">||</span> <span class="n">strs</span><span class="o">.</span><span class="na">length</span><span class="o">==)</span> <span class="k">return</span> <span class="s">""</span><span class="o">;</span> 
	<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">strs</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span><span class="o">++){</span>
		<span class="kt">char</span> <span class="n">c</span><span class="o">=</span><span class="n">strs</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">);</span> 
		<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">strs</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
			<span class="k">if</span> <span class="o">(</span><span class="n">i</span><span class="o">==</span><span class="n">strs</span><span class="o">[</span><span class="n">j</span><span class="o">].</span><span class="na">length</span><span class="o">()</span> <span class="o">||</span> <span class="n">strs</span><span class="o">[</span><span class="n">j</span><span class="o">].</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)!=</span><span class="n">c</span><span class="o">){</span>
				<span class="k">return</span> <span class="n">strs</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">substring</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span><span class="n">i</span><span class="o">);</span>
			<span class="o">}</span>
		<span class="o">}</span>
	<span class="o">}</span>
	<span class="k">return</span> <span class="n">strs</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span> 
<span class="o">}</span>
</pre></table></code></div></div><p><strong>Complexity Analysis</strong></p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre>Time complexity: 	O(S) 	Where S is the sum of all characters in all strings. In the worst case
				there will be n equal strings with length m and the algorithm performs
				S=n*m character comparisons. Even the worst case is still the same as 
				Approach 1, in the best case there are at most n*minLen comparisons 
				where minLen is the length of the shortest string in the array. 

Space complexity: 	O(1)	We only used constant extra space
</pre></table></code></div></div><p><br /><br /> <a name="longestCommonPrefixDivideandConquer"></a></p><h2 id="divide-and-conquer"><span class="me-2">Divide and Conquer</span><a href="#divide-and-conquer" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>The idea of the algorithm comes from the associative property of LCP operation. We notice that: LCP(S1 … Sn) = LCP(LCP(S1 … Sk), LCP(Sk+1 … Sn)), where LCP(S1 … Sn) is the longest common prefix in a set of strings [S1 … Sn], 1&lt;k&lt;n</p><p><br /><br /> <em>Algorithm</em></p><p>To apply the previous observation, we use the divide and conquer technique, where we split the LCP(Si … Sj) problem into two subproblems LCP(Si … Smid) and LCP(Smid+1 … Sj), where mid is (i+j)/2. We use their solutions lcpLeft and lcpRight to construct the solution of the main problem LCP(Si … Sj). To accomplish this we compare one by one the characters of lcpLeft and lcpRight till there is no character match. The found common prefix of lcpLeft and lcpRight is the solution of the LCP(Si … Sj)</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre>				{leetcode, leet, lee, le} 

				    /                \   
Divide 			{leetcode, leet}            {lee, le} 

Conquer				|			 | 

			     {leet} 		        {le} 

			         \                      /

				 	   {le} 

	Searching for the longest common prefix (LCP) in dataset {leetcode, leet, lee, le} 
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="nc">String</span> <span class="nf">longestCommonPrefix</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">strs</span><span class="o">)</span> <span class="o">{</span> 

	<span class="k">if</span> <span class="o">(</span><span class="n">strs</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">strs</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span><span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="s">""</span><span class="o">;</span>
		<span class="k">return</span> <span class="nf">longestCommonPrefix</span><span class="o">(</span><span class="n">strs</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">strs</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span> 

<span class="o">}</span>

<span class="kd">private</span> <span class="nc">String</span> <span class="nf">longestCommonPrefix</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">strs</span><span class="o">,</span> <span class="kt">int</span> <span class="n">l</span><span class="o">,</span> <span class="kt">int</span> <span class="n">r</span><span class="o">)</span> <span class="o">{</span> 
	<span class="k">if</span> <span class="o">(</span><span class="n">l</span><span class="o">==</span><span class="n">r</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">return</span> <span class="n">strs</span><span class="o">[</span><span class="n">l</span><span class="o">];</span>
	<span class="o">}</span>
	<span class="k">else</span> <span class="o">{</span>
		<span class="kt">int</span> <span class="n">mid</span><span class="o">=(</span><span class="n">l</span><span class="o">+</span><span class="n">r</span><span class="o">)/</span><span class="mi">2</span><span class="o">;</span> 
		<span class="nc">String</span> <span class="n">lcpLeft</span><span class="o">=</span> <span class="n">longestCommonPrefix</span><span class="o">(</span><span class="n">strs</span><span class="o">,</span><span class="n">l</span><span class="o">,</span> <span class="n">mid</span><span class="o">);</span> 
		<span class="nc">String</span> <span class="n">lcpRight</span><span class="o">=</span> <span class="n">longestCommonPrefix</span><span class="o">(</span><span class="n">strs</span><span class="o">,</span><span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span><span class="n">r</span><span class="o">);</span> 
		<span class="k">return</span> <span class="nf">commonPrefix</span><span class="o">(</span><span class="n">lcpLeft</span><span class="o">,</span><span class="n">lcpRight</span><span class="o">);</span>
	<span class="o">}</span>
<span class="o">}</span>

<span class="nc">String</span> <span class="nf">commonPrefix</span><span class="o">(</span><span class="nc">String</span> <span class="n">left</span><span class="o">,</span> <span class="nc">String</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
	<span class="kt">int</span> <span class="n">min</span><span class="o">=</span><span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">left</span><span class="o">.</span><span class="na">length</span><span class="o">(),</span> <span class="n">right</span><span class="o">.</span><span class="na">length</span><span class="o">());</span> 
	<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">min</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">left</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">!=</span><span class="n">right</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">){</span>
			<span class="k">return</span> <span class="n">left</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">i</span><span class="o">);</span>
		<span class="o">}</span>
	<span class="o">}</span>
	<span class="k">return</span> <span class="n">left</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">min</span><span class="o">);</span>
<span class="o">}</span>
</pre></table></code></div></div><p><strong>Complexity Analysis</strong></p><p>In the worst case we have n equal strings with length m</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre>Time Complexity: O(S)		where S is the number of all characters in the array, S=m*n so time
				complexity is 2*T(n/2)+O(m). Therefore time complexity is O(S). In the
				best case the algorithm performs O(minLen * n) comparisons, where
				minLen is the shortest string of the array 

Space Complexity: O(m*log(n))	There is a memory overhead since we sotre recursive call in the 
				execution stack. There are log(n) recursive calls, each store needs m
				space to store the result so space complexity is O(m*log(n))
</pre></table></code></div></div><p><br /><br /> <a name="longestCommonPrefixBinarySearch"></a></p><h2 id="binary-search"><span class="me-2">Binary Search</span><a href="#binary-search" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>The idea is to apply binary search method to find the string with maximum value L, which is common prefix of all the strings. The algorithm searches the space in the interval (0 … minLen), where minLen is minimum string length and the maximum possible common prefix. Each time search space is divided in two equal parts, one of them is discarded because it is sure that it doesn’t contain the solution. There are two possible cases:</p><ul><li>S[1…mid] is not a common string. This means that for each j&gt;i, S[1…j] is not a common string and we discard the second half of the search space<li>S [1…mid] is common string. This means that for each i&lt;j, S[1…i] is a common string and we discard the first half of the search space, because we try to find longer common prefix</ul><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre><td class="rouge-code"><pre> 				{leets, leetcode, leetc, leeds} 

						|
					      
					     "leets"
					    /        \
					 "lee"      "ts"

					     midpoint 
				
				"lee" in "leetcode" : yes
				"lee" in "leetc" : yes
				"lee" in "leeds" : yes

						|

					     "leets"
					     /     \
					  "lee"    "ts"
					    |      /   \

					  "lee"   "t"   "s"
					        
						   midpoint


						   "leet" in "leetcode" : yes
						   "leet" in "leetc" : yes 
						   "leet" in "leeds" : no

						   LCP= "lee" 
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="nc">String</span> <span class="nf">longestCommonPrefix</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">strs</span><span class="o">)</span> <span class="o">{</span>
	<span class="k">if</span> <span class="o">(</span><span class="n">strs</span><span class="o">==</span><span class="kc">null</span> <span class="o">||</span> <span class="n">strs</span><span class="o">.</span><span class="na">length</span><span class="o">==</span><span class="mi">0</span><span class="o">)</span>
		<span class="k">return</span> <span class="s">""</span><span class="o">;</span>
	<span class="kt">int</span> <span class="n">minLen</span><span class="o">=</span><span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span> 
	<span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="nl">str:</span> <span class="n">strs</span><span class="o">)</span>
		<span class="n">minLen</span><span class="o">=</span><span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">minLen</span><span class="o">,</span> <span class="n">str</span><span class="o">.</span><span class="na">length</span><span class="o">());</span>
	<span class="kt">int</span> <span class="n">low</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span> 
	<span class="kt">int</span> <span class="n">high</span><span class="o">=</span><span class="n">min</span> <span class="nc">Len</span><span class="o">;</span> 
	<span class="k">while</span> <span class="o">(</span><span class="n">low</span><span class="o">&lt;=</span><span class="n">high</span><span class="o">)</span> <span class="o">{</span>
		<span class="kt">int</span> <span class="n">middle</span><span class="o">=(</span><span class="n">low</span><span class="o">+</span><span class="n">high</span><span class="o">)/</span><span class="mi">2</span><span class="o">;</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">isCommonPrefix</span><span class="o">(</span><span class="n">strs</span><span class="o">,</span> <span class="n">middle</span><span class="o">)</span>
			<span class="n">low</span><span class="o">=</span><span class="n">middle</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span>
		<span class="k">else</span> 
			<span class="n">high</span><span class="o">=</span><span class="n">middle</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span>
	<span class="o">}</span>
	<span class="k">return</span> <span class="n">strs</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">substring</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="o">(</span><span class="n">low</span> <span class="o">+</span> <span class="n">high</span><span class="o">)/</span><span class="mi">2</span><span class="o">);</span>
<span class="o">}</span> 

<span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">isCommonPrefix</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">strs</span><span class="o">,</span> <span class="kt">int</span> <span class="n">len</span><span class="o">)</span> <span class="o">{</span>
	<span class="nc">String</span> <span class="n">str1</span><span class="o">=</span><span class="n">strs</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">substring</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span><span class="n">len</span><span class="o">);</span>
	<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">strs</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
		<span class="k">if</span> <span class="o">(!</span><span class="n">strs</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">startsWith</span><span class="o">(</span><span class="n">str1</span><span class="o">))</span>
			<span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
	<span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><p>**Complexity Analysis</p><p>In the worst case we have n equal strings with length m</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>	Time complexity: 	O(S * log(n)), where S is the sum of all characters in all strings. The
				algorithm makes log(n) iterations, for each of them there are S=m*n 
				comparisons, which gives in total O(S * log(n)) time complexity

	Space complexity: 	O(1). We only used constant extra space 
</pre></table></code></div></div><p><br /><br /> <a name="longestCommonPrefixFurtherThoughts"></a></p><h2 id="further-thoughts"><span class="me-2">Further Thoughts</span><a href="#further-thoughts" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Considering a slightly different problem:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>	Given a set of keys S= [S1, S2 ... Sn], find the longest common prefix among a string q and S.
	This LCP query will be called frequently
</pre></table></code></div></div><p>We coule optimize LCP queries by storing the set of keys S in a Trie. See this for Trie implementation. In a Trie, each node descending from the root represents a common prefix of some keys. But we need to find the longest common prefix of a string q and all key strings. This means that we have to find the deepest path from the root, which satisfies the following conditions</p><ul><li>it is a prefix of query string q<li>each node along the path must contain only one child element. Otherwise the found path will not be a common prefix among all strings<li>the path doesn’t comprise of nodes which are marked as end of key. Otherwise the path couldn’t be a prefix of a key which is shorter than itself</ul><p><br /><br /> <em>Algorithm</em></p><p>The only question left is how to find the deepest path in the Trie, that fulfills the requirements above. The most effective way is to build a trie from {S1 … Sn] strings. Then find the prefix of query string q in the Trie. We traverse the Trie from the root, till it is impossible to continue the path in the Trie because one of the conditions above is not satisfied.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre>Searching for the longest common prefix of string "le" in a Trie from dataset {lead, leet}

			Root

			 1

	l   ===========&gt;  \  l

			     2

	e   ===============&gt;   \ e

LCP "le" FOUND	=============&gt;   3   

			     a	/  \ e    End of Key "lee" 
				     
			      6      4

			 d  /	       \ t
				        
END OF KEY "lead"	  7		 5   End of key "leet"
</pre></table></code></div></div><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
</pre><td class="rouge-code"><pre>public String longestCommonPrefix(String q, String[] strs) {
    if (strs == null || strs.length == 0)
         return "";  
    if (strs.length == 1)
         return strs[0];
    Trie trie = new Trie();      
    for (int i = 1; i &lt; strs.length ; i++) {
        trie.insert(strs[i]);
    }
    return trie.searchLongestPrefix(q);
}

class TrieNode {

    // R links to node children
    private TrieNode[] links;

    private final int R = 26;

    private boolean isEnd;

    // number of children non null links
    private int size;    
    public void put(char ch, TrieNode node) {
        links[ch -'a'] = node;
        size++;
    }

    public int getLinks() {
        return size;
    }
    //assume methods containsKey, isEnd, get, put are implemented as it is described
   //in  https://leetcode.com/articles/implement-trie-prefix-tree/)
}

public class Trie {

    private TrieNode root;

    public Trie() {
        root = new TrieNode();
    }

//assume methods insert, search, searchPrefix are implemented
    private String searchLongestPrefix(String word) {
        TrieNode node = root;
        StringBuilder prefix = new StringBuilder();
        for (int i = 0; i &lt; word.length(); i++) {
            char curLetter = word.charAt(i);
            if (node.containsKey(curLetter) &amp;&amp; (node.getLinks() == 1) &amp;&amp; (!node.isEnd())) {
                prefix.append(curLetter);
                node = node.get(curLetter);
            }
            else
                return prefix.toString();

         }
         return prefix.toString();
    }
}
</pre></table></code></div></div><p><strong>Complexity Analysis</strong></p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre>In the worst case query q has length m and is equal to all n strings of the array 

Time Complexity:   O(S)   where S is the number of all characters in the array, LCP query O(m) 
  			  Trie build has O(S) time complexity. To find the common prefix of q 
			  in the Trie takes in the worst O(m). 

Space complexity:  O(S)   we only used additional S extra space for the Trie. 
</pre></table></code></div></div><p><br /><br /><br /> *** <a name="threeSum"></a></p><h1 id="15-3sum">15-3Sum</h1><p>Given an array “nums” of n integers, are there elements a, b, c in nums such that a+b+c=0? Find all unique triplets in the array which gives the sum of zero.</p><p>Note:</p><p>The solution set must not contain duplicate triplets</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre>Example: 

Given array nums = [-1, 0, 1, 2, -1, -4]. 

A solution set is: 
[
  [-1, 0, 1],
  [-1, -1, 2]
]
</pre></table></code></div></div><p><br /><br /> <a name="threeSumSortedArray"></a></p><h2 id="sorted-array"><span class="me-2">Sorted Array</span><a href="#sorted-array" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>The method is to sort an input array and then run through all indices of a possible first element of a triplet. For each element we make another 2Sum sweep of the remaining part of the array. Also we want to skip elements to avoid duplicates in the answer without expending extra memory.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre><td class="rouge-code"><pre>public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] num) {
    
    //Arrays.sort re-arranges the array of integers in ascending order
    //ex. [1, 2, 3, 4]

    Arrays.sort(num);
    List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); 
    for (int i = 0; i &lt; num.length-2; i++) {
        if (i == 0 || (i &gt; 0 &amp;&amp; num[i] != num[i-1])) {
            
	    //This lets us skip some of the duplicate entries in the array
	    
	    int lo = i+1, hi = num.length-1, sum = 0 - num[i];

	    //This is for the 2 Sum sweep 

            while (lo &lt; hi) {
                if (num[lo] + num[hi] == sum) {
                    res.add(Arrays.asList(num[i], num[lo], num[hi]));
                    while (lo &lt; hi &amp;&amp; num[lo] == num[lo+1]) lo++;
                    while (lo &lt; hi &amp;&amp; num[hi] == num[hi-1]) hi--;

		    //This lets us skip some of the duplicate entries in the array

                    lo++; hi--;
                } else if (num[lo] + num[hi] &lt; sum) lo++;
                else hi--;

		//This allows us to optimize slightly since we know that the array is sorted
           }
        }
    }
    return res;
}
</pre></table></code></div></div><p><strong>Complexity Analysis</strong></p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre>Time Complexity:  O(n^2)   We go through a maximum of n elements for the first element of a triplet, 
			   and then when making a bi-directional 2Sum sweep of the remaining part of 
			   the array we also go through a maxiumum of n elements. 

Space Complexity: O(1)	   If we assume the return linked list is not extra space, then we do not 
			   allocate any significant extra space
</pre></table></code></div></div><p><br /><br /><br /> *** <a name="threeSumClosest"></a></p><h1 id="16-3sum-closest">16-3Sum Closest</h1><p>Given an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>Example:

Given array nums=[-1, 2, 1, -4], and target=1.

The sum that is closest to the target is 2. (-1+2+1=2)
</pre></table></code></div></div><p><br /><br /> <a name="threeSumClosestThreePointers"></a></p><h2 id="3-pointers"><span class="me-2">3 Pointers</span><a href="#3-pointers" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Similar to the previous 3Sum problem, we use three pointers to point to the current element, next element and the last element. If the sum is less than the target, it means that we need to add a larger element so next element move to the next. If the sum is greater, it means we have to add a smaller element so last element move to the second last element. Keep doing this until the end. Each time compare the difference between sum and target, if it is less than minimum difference so far, then replace result with it, otherwise continue iterating.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre>public class Solution {
		public int threeSumClosest(int[] num, int target) {
		int result=num[0] + num[1] + num[num.length-1];
		Arrays.sort(num);
		for (int i=0; i&lt;num.length -2; i++) {
			int start= i+1, end = num.length -1;
			while (start &lt; end) {
				int sum = num[i] + num[start] + num[end];
				if (sum &gt; target) {
					end--;
				} else {
					start++;
				}
				if (Math.abs(sum-target) &lt; Math.abs(result-target)) {
					result=sum;
				}
			}
		}
		return result;
	}
}
</pre></table></code></div></div><p><br /><br /><br /> *** <a name="letterCombinationsofaPhoneNumber"></a></p><h1 id="17-letter-combinations-of-a-phone-number">17-Letter Combinations of a Phone Number</h1><p>Given a string contianing digits from 2-9 inclusive, return all possible letter combinations that the number could represent.</p><p>A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>2 - abc 	3 - def 	4 - ghi		5 - jkl		6 - mno		7 - pqrs 	8 - tuv
				
						9 - wxyz
</pre></table></code></div></div><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre>Example: 


Input: "23" 

Output: ["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"]. 
</pre></table></code></div></div><p><em>Note: The above answer is in lexicographical order but the answer can be in any order</em></p><p><br /><br /> <a name="letterCombinationsofaPhoneNumberBacktracking"></a></p><h2 id="backtracking"><span class="me-2">Backtracking</span><a href="#backtracking" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Backtracking is an algorithm for finding all solutions by exploring all potential candidates. If the solution candidate turns to not be a solution (or at least not the last one), backtracking algorithm discards it by making some changes on the previous step, ie <em>backtracks</em> and then tries again.</p><p>Here is a backtrack function backtrack(combination, next_digits) which takes as arguments an ongoing letter combination and the next digits to check.</p><ul><li>If there are no more digits to check that means the current combination is done<li>If there are still digits to check:<ul><li>Iterate over the letters mapping to the next available digit<li>Append the current letter to the current combination and proceed to check next digits:</ul></ul><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>	  combination = combination + letter

	  backtrack(combination + letter, next_digits[1:]).
</pre></table></code></div></div><p><strong>Visual Representation</strong></p><p><a href="https://raw.githubusercontent.com/SamirPaulb/assets/main/Screenshot-2022-10-26-180426.png" class="popup img-link shimmer"><img src="https://raw.githubusercontent.com/SamirPaulb/assets/main/Screenshot-2022-10-26-180426.png" alt="Visual Representation" loading="lazy"></a></p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>
</pre></table></code></div></div><p><strong>Complexity Analysis</strong></p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre>
Time Complexity: 	O(3^N * 4^M) 	where N is the number of digits in the input that maps to 3
					letters (eg. 2, 3, 4, 5, 6, 8) and M is the number of digits 
					in the input that maps to 4 letters (eg. 7, 9) and N+M is the 
					total number digits in the input 

Space Complexity: 	O(3^N * 4^M)	since one has to keep 3^N * 4^M solutions 
</pre></table></code></div></div><p><br /><br /> <a name="letterCombinationsofaPhoneNumberFIFOQueue"></a></p><h2 id="first-in-first-out-fifo-queue"><span class="me-2">First In First Out (FIFO) Queue</span><a href="#first-in-first-out-fifo-queue" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>This solution utilizes the Single Queue Breadth First Search (BFS) which is an algorithm for traversing or searching tree or graph data structures. It starts at the tree root and explores all of the neighbor nodes.</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="nf">letterCombinations</span><span class="o">(</span><span class="nc">String</span> <span class="n">digits</span><span class="o">)</span> <span class="o">{</span>
	
	<span class="nc">LinkedList</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">ans</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;();</span>
	<span class="k">if</span> <span class="o">(</span><span class="n">digits</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="k">return</span> <span class="n">ans</span><span class="o">;</span> 
	<span class="nc">String</span><span class="o">[]</span> <span class="n">mapping</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">[]</span> <span class="o">{</span><span class="s">"0"</span><span class="o">,</span> <span class="s">"1"</span><span class="o">,</span> <span class="s">"abc"</span><span class="o">,</span> <span class="s">"def"</span><span class="o">,</span> <span class="s">"ghi"</span><span class="o">,</span> <span class="s">"jkl"</span><span class="o">,</span> <span class="s">"mno"</span><span class="o">,</span> <span class="s">"pqrs"</span><span class="o">,</span> <span class="s">"tuv"</span><span class="o">,</span> <span class="o">{</span><span class="n">wxyz</span><span class="s">"};
	ans.add("</span><span class="err">"</span><span class="o">);</span> 
	<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">digits</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
		<span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="nc">Character</span><span class="o">.</span><span class="na">getNumericValue</span><span class="o">(</span><span class="n">digits</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">));</span> 
		
		<span class="c1">//we terminate the while loop when we encounter a new-formed string which is more than</span>
		<span class="c1">//the current level i </span>
		
		<span class="c1">//peek retrieves the first value of the linked list</span>
		<span class="k">while</span> <span class="o">(</span><span class="n">ans</span><span class="o">.</span><span class="na">peek</span><span class="o">().</span><span class="na">length</span><span class="o">==</span><span class="n">i</span><span class="o">){</span>
			
			<span class="c1">//removes the head or the first value in the linkedlist</span>
			<span class="nc">String</span> <span class="n">t</span> <span class="o">=</span> <span class="n">ans</span><span class="o">.</span><span class="na">remove</span><span class="o">();</span> 
			<span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="n">s</span> <span class="o">:</span> <span class="n">mapping</span><span class="o">[</span><span class="n">x</span><span class="o">].</span><span class="na">toCharArray</span><span class="o">())</span> <span class="o">{</span>
				<span class="n">ans</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">t</span><span class="o">+</span><span class="n">s</span><span class="o">);</span>
				<span class="c1">//this works because add appends to the end of the list</span>
			<span class="o">}</span>
		<span class="o">}</span>
		<span class="k">return</span> <span class="n">ans</span><span class="o">;</span> 
	<span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><strong>Complexity Analysis</strong></p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre>
Time Complexity: 	O(3^N * 4^M) 	where N is the number of digits in the input that maps to 3
					letters (eg. 2, 3, 4, 5, 6, 8) and M is the number of digits 
					in the input that maps to 4 letters (eg. 7, 9) and N+M is the 
					total number digits in the input 

Space Complexity: 	O(3^N * 4^M)	since one has to keep 3^N * 4^M solutions 
</pre></table></code></div></div><p><br /><br /><br /> *** <a name="fourSum"></a></p><h1 id="18-4sum">18-4Sum</h1><p>Given an array nums of n integers and an integer target, are there elements a, b, c, and d in nums such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target</p><p><em>Note:</em> The solution set must not contain duplicate quadruplets</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre>Example: 


Given array nums = [1, 0, -1, 0, -2, 2], and target = 0


A solution set is: 

[
  [-1,  0, 0, 1],
  [-2, -1, 1, 2],
  [-2,  0, 0, 2]
]
</pre></table></code></div></div><p><br /><br /> <a name="fourSumSortedArray"></a></p><h2 id="sorted-array-1"><span class="me-2">Sorted Array</span><a href="#sorted-array-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>The idea is the same as the other numbered sum problems like 2sum and 3sum. We sort the array and then proceed to interate through the values until we end up with a result that we are looking for.</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="nf">fourSum</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">num</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
		
		<span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">ans</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
		
		<span class="k">if</span> <span class="o">(</span><span class="n">num</span><span class="o">.</span><span class="na">length</span><span class="o">&lt;</span><span class="mi">4</span><span class="o">)</span> <span class="o">{</span>
			
			<span class="k">return</span> <span class="n">ans</span><span class="o">;</span>
		<span class="o">}</span>
		<span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">num</span><span class="o">);</span> 
		
		<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">num</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">3</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>   <span class="c1">//picking the first candidate must leave room</span>
						       <span class="c1">//for the other values </span>
			
			<span class="k">if</span> <span class="o">(</span><span class="n">num</span><span class="o">[</span><span class="n">i</span><span class="o">]+</span><span class="n">num</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">]+</span><span class="n">num</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="o">]+</span><span class="n">num</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="mi">3</span><span class="o">]&gt;</span><span class="n">target</span><span class="o">)</span> <span class="o">{</span>
				
				<span class="k">break</span><span class="o">;</span>
				<span class="c1">//first candidate too large, search finished</span>
			<span class="o">}</span>

			<span class="k">if</span> <span class="o">(</span><span class="n">num</span><span class="o">[</span><span class="n">i</span><span class="o">]+</span><span class="n">num</span><span class="o">[</span><span class="n">num</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span><span class="o">]+</span><span class="n">num</span><span class="o">[</span><span class="n">num</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">2</span><span class="o">]+</span><span class="n">num</span><span class="o">[</span><span class="n">num</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">3</span><span class="o">]&lt;</span><span class="n">target</span><span class="o">)</span> <span class="o">{</span>
				
				<span class="k">continue</span><span class="o">;</span>
				<span class="c1">//first candidate too small </span>
			<span class="o">}</span>

			<span class="k">if</span><span class="o">(</span><span class="n">i</span><span class="o">&gt;</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">num</span><span class="o">[</span><span class="n">i</span><span class="o">]==</span><span class="n">num</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">])</span> <span class="o">{</span>
				
				<span class="k">continue</span><span class="o">;</span>
				<span class="c1">//prevents duplicate in ans list</span>
			<span class="o">}</span>
			
			<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">num</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">2</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>   <span class="c1">//picking the second candidate must</span>
								 <span class="c1">//leave room for other values </span>
				
				<span class="k">if</span> <span class="o">(</span><span class="n">num</span><span class="o">[</span><span class="n">i</span><span class="o">]+</span><span class="n">num</span><span class="o">[</span><span class="n">j</span><span class="o">]+</span><span class="n">num</span><span class="o">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="o">]+</span><span class="n">num</span><span class="o">[</span><span class="n">j</span><span class="o">+</span><span class="mi">2</span><span class="o">]&gt;</span><span class="n">target</span><span class="o">)</span> <span class="o">{</span>
					
					<span class="k">break</span><span class="o">;</span>
					<span class="c1">//second candidate too large</span>
				<span class="o">}</span>

				<span class="k">if</span> <span class="o">(</span><span class="n">num</span><span class="o">[</span><span class="n">i</span><span class="o">]+</span><span class="n">num</span><span class="o">[</span><span class="n">j</span><span class="o">]+</span><span class="n">num</span><span class="o">[</span><span class="n">num</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span><span class="o">]+</span><span class="n">num</span><span class="o">[</span><span class="n">num</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">2</span><span class="o">]&lt;</span><span class="n">target</span><span class="o">)</span> <span class="o">{</span>
				
					<span class="k">continue</span><span class="o">;</span>
					<span class="c1">//second candidate too small</span>
				<span class="o">}</span>

				<span class="k">if</span><span class="o">(</span><span class="n">j</span><span class="o">&gt;</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">num</span><span class="o">[</span><span class="n">j</span><span class="o">]==</span><span class="n">num</span><span class="o">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">])</span> <span class="o">{</span>
					
					<span class="k">continue</span><span class="o">;</span>
					<span class="c1">//prevents duplicate results in ans list</span>
				<span class="o">}</span>

				<span class="kt">int</span> <span class="n">low</span><span class="o">=</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">high</span><span class="o">=</span><span class="n">num</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span>
				
				<span class="c1">//two pointer search</span>
				<span class="k">while</span><span class="o">(</span><span class="n">low</span><span class="o">&lt;</span><span class="n">high</span><span class="o">)</span> <span class="o">{</span>
					
					<span class="kt">int</span> <span class="n">sum</span><span class="o">=</span><span class="n">num</span><span class="o">[</span><span class="n">i</span><span class="o">]+</span><span class="n">num</span><span class="o">[</span><span class="n">j</span><span class="o">]+</span><span class="n">num</span><span class="o">[</span><span class="n">low</span><span class="o">]+</span><span class="n">num</span><span class="o">[</span><span class="n">high</span><span class="o">];</span>
					<span class="k">if</span> <span class="o">(</span><span class="n">sum</span><span class="o">==</span><span class="n">target</span><span class="o">)</span> <span class="o">{</span>
						
						<span class="n">ans</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="n">num</span><span class="o">[</span><span class="n">i</span><span class="o">],</span><span class="n">num</span><span class="o">[</span><span class="n">j</span><span class="o">],</span><span class="n">num</span><span class="o">[</span><span class="n">low</span><span class="o">],</span><span class="n">num</span><span class="o">[</span><span class="n">high</span><span class="o">]));</span>
						<span class="k">while</span><span class="o">(</span><span class="n">low</span><span class="o">&lt;</span><span class="n">high</span><span class="o">&amp;&amp;</span><span class="n">num</span><span class="o">[</span><span class="n">low</span><span class="o">]==</span><span class="n">num</span><span class="o">[</span><span class="n">low</span><span class="o">+</span><span class="mi">1</span><span class="o">])</span> <span class="o">{</span>
							<span class="n">low</span><span class="o">++;</span> <span class="c1">//skipping over duplicates</span>
						<span class="o">}</span>

						<span class="k">while</span><span class="o">(</span><span class="n">low</span><span class="o">&lt;</span><span class="n">high</span> <span class="o">&amp;&amp;</span> <span class="n">num</span><span class="o">[</span><span class="n">high</span><span class="o">]==</span><span class="n">num</span><span class="o">[</span><span class="n">high</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">{</span>
							<span class="n">high</span><span class="o">--;</span> <span class="c1">//skipping over duplicates </span>
						<span class="o">}</span>
						<span class="n">low</span><span class="o">++;</span>
						<span class="n">high</span><span class="o">--;</span>
					<span class="o">}</span>

					<span class="c1">//moving window</span>
					<span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">sum</span><span class="o">&lt;</span><span class="n">target</span><span class="o">)</span> <span class="o">{</span>
						<span class="n">low</span><span class="o">++;</span>
					<span class="o">}</span>

					<span class="k">else</span> <span class="o">{</span>
						<span class="n">high</span><span class="o">--;</span>
					<span class="o">}</span>
				<span class="o">}</span>
			<span class="o">}</span>
		<span class="o">}</span>
		<span class="k">return</span> <span class="n">ans</span><span class="o">;</span>
	<span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><br /><br /><br /> *** <a name="removeNthNodefromEndofList"></a></p><h1 id="19-remove-nth-node-from-end-of-list">19-Remove Nth Node From End of List</h1><p>Given a linked list, remove the n-th node from the end of the list and return its head</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre>Example: 

Given linked list: 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5, and n=2 


After removing the second node from the end, the linked list becomes 
		   
		   1 -&gt; 2 -&gt; 3 -&gt; 5
</pre></table></code></div></div><p><strong>Note:</strong> Given n will always be valid</p><p><strong>Follow up:</strong> Could you do this in one pass?</p><p><br /><br /> <a name="removeNthNodefromEndofListTwoPassAlgorithm"></a></p><h2 id="two-pass-algorithm"><span class="me-2">Two Pass Algorithm</span><a href="#two-pass-algorithm" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><strong>Intuition</strong></p><p>We notice that the problem could be simply reduced to another one: Remove the (L-n+1)th node from the beginning of the list, where L is the list length. This problem is easy to solve once we found the list length L.</p><p><br /><br /> <strong>Algorithm</strong></p><p>First we will add an auxiliary “dummy” node, which points to the list head. The “dummy” node is used to simplify some corner cases such as a list with only one node or removing the head of the list. On the first pass, find the list length L. Then we set a pointer to the dummy node and start to move it through the list till it comes to the (L-n)th node. We relink next pointer of the (L-n)th node to the (L-n+2)th node and we are done.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre>	D -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; NULL

		    |
		    v

	D -&gt; 1 -&gt; 2 -&gt; 4 -&gt; NULL
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="nc">ListNode</span> <span class="nf">removeNthFromEnd</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
	
	<span class="nc">ListNode</span> <span class="n">dummy</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span> 
	<span class="n">dummy</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span> 
	<span class="kt">int</span> <span class="n">length</span> <span class="o">=</span><span class="mi">0</span><span class="o">;</span> 
	<span class="nc">ListNode</span> <span class="n">first</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span> 
	
	<span class="k">while</span> <span class="o">(</span><span class="n">first</span><span class="o">!=</span><span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
		
		<span class="n">length</span><span class="o">++;</span>
		<span class="n">first</span><span class="o">=</span><span class="n">first</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
	<span class="o">}</span>

	<span class="n">length</span> <span class="o">-=</span> <span class="n">n</span><span class="o">;</span> 
	<span class="n">first</span> <span class="o">=</span> <span class="n">dummy</span><span class="o">;</span>
	<span class="k">while</span> <span class="o">(</span><span class="n">length</span><span class="o">&gt;</span><span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
		
		<span class="n">length</span><span class="o">--;</span>
		<span class="n">first</span><span class="o">=</span><span class="n">first</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
	<span class="o">}</span>
	<span class="n">first</span><span class="o">.</span><span class="na">next</span><span class="o">=</span><span class="n">first</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
	<span class="k">return</span> <span class="n">dummy</span><span class="o">.</span><span class="na">next</span><span class="o">;</span> 
<span class="o">}</span>
</pre></table></code></div></div><p><strong>Complexity Analysis</strong></p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>Time Complexity: 	O(L) 	The algorithm makes two traversals of the list, first to calculate the 
				list length L and second to find the (L-n)th node. There are 2L-n 
				operations and time complexity is O(L)

Space Complexity: 	O(1) 	We only used constant extra space
</pre></table></code></div></div><p><br /><br /> <a name="removeNthNodefromEndofListOnePassAlgorithm"></a></p><h2 id="one-pass-algorithm"><span class="me-2">One Pass Algorithm</span><a href="#one-pass-algorithm" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>The previous algorithm could be optimized to one pass. Instead of one pointer, we could use two pointers. The first pointer advances the list by n+1 steps from the beginning, while the second pointer starts from the beginning of the list. Now, both pointers are separated by exactly n nodes. We maintain this constant gap by advancing both pointers together until the first pointer arrives past the last node. The second pointer will be pointing at the nth node counting from the last. We relink the next pointer of the node referenced by the second pointer to point to the node’s next next node.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
</pre><td class="rouge-code"><pre>Maintaining N=2 nodes apart between the first and second pointer 

	D	-&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; NULL

       first 	 Head 
       second 

			   


Move the first pointer N+1 steps 


			     |
			     v


	D	-&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; NULL

      second     Head       First


Move the first and second pointers together until the first pointer arrives past the last node 


			     |
			     v


	D	-&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; NULL
		
		 Head      Second           First

Second pointer points to the nth node counting from last so link node to the node's next next node 



				  |
				  v


	D	-&gt; 1 -&gt; 2 -&gt; 3 -&gt;   -&gt; 5 -&gt; NULL
	         
		 Head      Second           First
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="nc">ListNode</span> <span class="nf">removeNthFromEnd</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
	
	<span class="nc">ListNode</span> <span class="n">dummy</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
	<span class="n">dummy</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span> 
	<span class="nc">ListNode</span> <span class="n">first</span> <span class="o">=</span> <span class="n">dummy</span><span class="o">;</span> 
	<span class="nc">ListNode</span> <span class="n">second</span> <span class="o">=</span> <span class="n">dummy</span><span class="o">;</span>
	
	<span class="c1">//Moves the first pointer so that the first and second nodes are separated by n nodes</span>
	
	<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
		
		<span class="n">first</span> <span class="o">=</span> <span class="n">first</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
	<span class="o">}</span>

	<span class="c1">//Move first to the end, maintaining the gap</span>

	<span class="k">while</span> <span class="o">(</span><span class="n">first</span><span class="o">!=</span><span class="kc">null</span><span class="o">)</span> <span class="o">{</span>

		<span class="n">first</span><span class="o">=</span><span class="n">first</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
		<span class="n">second</span><span class="o">=</span><span class="n">second</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
	<span class="o">}</span>

	<span class="n">second</span><span class="o">.</span><span class="na">next</span><span class="o">=</span><span class="n">second</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
	<span class="k">return</span> <span class="n">dummy</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><p><strong>Complexity Analysis</strong></p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>Time Complexity: 	O(L) 	The algorithm makes one traversal of the list of L nodes. Therefore
				time complexity is O(L)

Space Complexity: 	O(1)	Only constant extra space was used 
</pre></table></code></div></div><p><br /><br /><br /> *** <a name="validParentheses"></a></p><h1 id="20-valid-parentheses">20-Valid Parentheses</h1><p>Given a string containing just the characters ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[’, ‘]’, determine if the input string is valid</p><p>An input string is valid if:</p><ol><li>Open brackets must be closed by the same type of brackets<li>Open brackets must be closed in the correct order</ol><p>Note that an empty string is also considered valid</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>Example 1: 

Input: "()"
Output: true
</pre></table></code></div></div><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>Example 2: 

Input: "()[]{}"
Output: true 
</pre></table></code></div></div><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>Example 3: 

Input: "(]"
Output: false
</pre></table></code></div></div><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>Example 4: 

Input: "([)]"
Output: false
</pre></table></code></div></div><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>Example 5: 

Input: "{[]}"
Output: true
</pre></table></code></div></div><p><br /><br /> <a name="validParenthesesCounting"></a></p><h2 id="counting-method"><span class="me-2">Counting method</span><a href="#counting-method" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><strong>Intuition</strong></p><p>Imagine you are writing a small compiler for your college project and one of the tasks or sub-tasks for the compiler would be to detect if the parenthesis are in place or not.</p><p>The algorithm we will look at in this article can be then used to process all the parenthesis in the program your compiler is compiling and checking if all the parenthesis are in place. This makes checking if a given string of parenthesis is valid or not, an important programming problem.</p><p>The expressions that we will deal with in this problem can consist of three different types of parenthesis:</p><ul><li>()<li>{}<li>[]</ul><p>Before looking at how we can check if a given expression consisting of thes parenthesis is valid or not, let us look at a simpler version of the problem that consists of just one type of parenthesis. So, the expressions we can encounter in this simplified version of the problem are:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre>(((((()))))) -- VALID

()()()()     -- VALID

(((((((()    -- INVALID

((()(())))   -- VALID
</pre></table></code></div></div><p>Let’s look at a simple algorithm to deal with this problem</p><p><br /><br /></p><ol><li>We process the expression one bracket at a time starting from the left<li>Suppose we encounter an opening bracket ie. <code class="language-plaintext highlighter-rouge">(</code>, it may or may not be an invalid expression because there can be a matching ending bracket somewhere in the remaining part of the expression. Here, we simply increment the counter keeping track of the left parenthesis till now. <code class="language-plaintext highlighter-rouge">left += 1</code><li><p>If we encounter a closing bracket, this has two meanings:</p><ul><li><p>There was no matching opening bracket for this closing bracket and in that case we have an invalid expression. This is the case when <code class="language-plaintext highlighter-rouge">left==0</code> ie. when there are no unmatched left brackets available</p><li><p>We had some unmatched opening bracket available to match this closing bracket. This is the case when <code class="language-plaintext highlighter-rouge">left&gt;0</code> ie. we have unmatched left brackets available</p></ul><li>If we encounter a closing bracket ie. <code class="language-plaintext highlighter-rouge">)</code> when left==0, then we have an invalid expression on our hands. Else, we decrement <code class="language-plaintext highlighter-rouge">left</code> thus reducing the number of unmatched left parenthesis available.<li>Continue processing the string until all parenthesis have been processed<li>If in the end we still have an unmatched left parenthesis available, this implies an invalid expression</ol><p><br /><br /></p><p>The reason we discussed this particular algorithm here is because the approach for the approach for the original problem derives its inspiration from this very solution.</p><p>If we try and follow the same approach for our original problem, then it simply won’t work. The reason a simple counter based approach works above is because all the parenthesis are of the same type. So when we encounter a closing bracket, we simply assume a corresponding opening matching bracket to be available ie. if <code class="language-plaintext highlighter-rouge">left&gt;0</code></p><p>But in our problem, if we encounter say <code class="language-plaintext highlighter-rouge">]</code>, we don’t really know if there is a corresponding opening <code class="language-plaintext highlighter-rouge">[</code> available or not. You could say:</p><blockquote><p>Why not maintain a separate counter for the different types of parenthesis?</p></blockquote><p>This doesn’t work because the relative placement of the parenthesis also matters here eg: <code class="language-plaintext highlighter-rouge">[{]</code></p><p><br /><br /></p><p>If we simply keep counters here, then as soon as we encounter the closing square bracket, we would know there is an unmatched opening square bracket available as well. But, the **closest unmatched opening bracket available is a curly bracket and not a square bracket and hence the counting approach breaks here.</p><p><br /><br /> <a name="validParenthesesStack"></a></p><h2 id="stacks"><span class="me-2">Stacks</span><a href="#stacks" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>An interesting property about a valid parenthesis expression is that a sub-expression. (Not every sub-expression) eg.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>	{ [ [ ] { } ] } ( ) ( ) 

	  ^         ^
	  |         |
</pre></table></code></div></div><p>The entire expression is valid, but sub portions of it are also valid in themselves. This lends a sort of a recursive structure to the problem. For example consider the expression enclosed within the marked parenthesis in the diagram above. The opening bracket is at index <code class="language-plaintext highlighter-rouge">1</code> and the corresponding closing bracket is at index <code class="language-plaintext highlighter-rouge">6</code>.</p><blockquote><p>What if whenever we encounter a matching pair of parenthesis in the expression we simply remove it from the expression?</p></blockquote><p>Let’s have a look at this idea below where we remove the smaller expressions one at a time from the overall expression and since this is a valid expression, we would be left with an empty string in the end.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>The stack data structure can come in handy here in representing this recursive structure of the 
problem. We can't really process this from the inside out because we don't have an idea about the 
overall structure. But, the stack can help us process this recursively ie. from outside to inwards.
</pre></table></code></div></div><p>Lets take a look at the algorithm for this problem using stacks as the intermediate data structure.</p><p><strong>Algorithm</strong></p><ol><li>Initialize a stack S.<li>Process each bracket of the expression one at a time<li>If we encounter an opening bracket, we simply push it onto the stack. This means we will process it later, let us simply move onto the sub-expression ahead<li>If encounter a closing bracket, then we check the element on top of the stack. If the element at the top of the stack is an opening bracket <code class="language-plaintext highlighter-rouge">of the same type</code>, then we pop it off the stack and continue processing. Else, this implies an invalid expression<li>In the end, if we are left with a stack still having elements, then this implies an invalid expression</ol><p>Lets take a look at the implementation for this algorithm</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
	
	<span class="c1">//Hash table that takes care of the mappings</span>
	<span class="kd">private</span> <span class="nc">HashMap</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">,</span> <span class="nc">Character</span><span class="o">&gt;</span> <span class="n">mappings</span><span class="o">;</span> 

	<span class="c1">//Initialize the hash map with mappings. This simply makes the code easier to read </span>
	<span class="kd">public</span> <span class="nf">Solution</span><span class="o">()</span> <span class="o">{</span>
		
		<span class="k">this</span><span class="o">.</span><span class="na">mappings</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">,</span> <span class="nc">Character</span><span class="o">&gt;();</span> 
		<span class="k">this</span><span class="o">.</span><span class="na">mappings</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="sc">')'</span><span class="o">,</span> <span class="sc">'('</span><span class="o">);</span>
		<span class="k">this</span><span class="o">.</span><span class="na">mappings</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="sc">'}'</span><span class="o">,</span> <span class="sc">'{'</span><span class="o">);</span>
		<span class="k">this</span><span class="o">.</span><span class="na">mappings</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="sc">']'</span><span class="o">,</span> <span class="sc">'['</span><span class="o">);</span>
	<span class="o">}</span>

	<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isValid</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span> 
		
		<span class="c1">// Initialize a stack to be used in the algorithm</span>
		<span class="nc">Stack</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">&gt;</span> <span class="n">stack</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Stack</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">&gt;();</span>

		<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
			
			<span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>

			<span class="c1">// If the current character is a closing bracket </span>

			<span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">mappings</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">c</span><span class="o">))</span> <span class="o">{</span>
				
				<span class="c1">// Get the top element of the stack. If the stack is empty, set a dummy value of '#' </span>
				<span class="kt">char</span> <span class="n">topElement</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="na">empty</span><span class="o">()</span> <span class="o">?</span> <span class="sc">'#'</span> <span class="o">:</span> <span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>

				<span class="c1">// If the mapping for this bracket doesn't match the stack's top element, return false. </span>
				<span class="k">if</span> <span class="o">(</span><span class="n">topElement</span> <span class="o">!=</span> <span class="k">this</span><span class="o">.</span><span class="na">mappings</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">c</span><span class="o">))</span> <span class="o">{</span>
					<span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
				<span class="o">}</span>
			<span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
				
				<span class="c1">//If it was an opening bracket, push to the stack  </span>
				
				<span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>
			<span class="o">}</span>
		<span class="o">}</span>

		<span class="c1">//If the stack still contains elements, then it is an invalid expression. </span>
		<span class="k">return</span> <span class="n">stack</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">();</span>
	<span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><strong>Complexity Analysis</strong></p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>Time Complexity: 	O(n)	We simply traverse the given string one character at a time and push 
				and pop operations on a stack take O(1) time 

Space Complexity: 	O(n)	In the worst case, when we push all opening brackets onto the stack, we
				will end up pushing all the brackets onto the stack eg (((((((((((
</pre></table></code></div></div><p><br /><br /><br /> *** <a name="mergeTwoSortedLists"></a></p><h1 id="21-merge-two-sorted-lists">21-Merge Two Sorted Lists</h1><p>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>Example: 

Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4
Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4
</pre></table></code></div></div><p><br /><br /> <a name="mergeTwoSortedListsRecursive"></a></p><h2 id="recursive"><span class="me-2">Recursive</span><a href="#recursive" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">solution</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="nc">ListNode</span> <span class="nf">mergeTwoLists</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">l1</span><span class="o">,</span> <span class="nc">ListNode</span> <span class="n">l2</span><span class="o">)</span> <span class="o">{</span>
		
		<span class="k">if</span> <span class="o">(</span><span class="n">l1</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="n">l2</span><span class="o">;</span> 
		<span class="k">if</span> <span class="o">(</span><span class="n">l2</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="n">l1</span><span class="o">;</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">l1</span><span class="o">.</span><span class="na">val</span> <span class="o">&lt;</span> <span class="n">l2</span><span class="o">.</span><span class="na">val</span><span class="o">)</span> <span class="o">{</span>
			
			<span class="n">l1</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">mergeTwoLists</span><span class="o">(</span><span class="n">l1</span><span class="o">.</span><span class="na">next</span><span class="o">,</span> <span class="n">l2</span><span class="o">);</span>
			<span class="k">return</span> <span class="n">l1</span><span class="o">;</span>
		<span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
			
			<span class="n">l2</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">mergeTwoLists</span><span class="o">(</span><span class="n">l1</span><span class="o">,</span> <span class="n">l2</span><span class="o">.</span><span class="na">next</span><span class="o">);</span>
			<span class="k">return</span> <span class="n">l2</span><span class="o">;</span>
		<span class="o">}</span>
	<span class="o">}</span>	
<span class="o">}</span>
</pre></table></code></div></div><p><br /><br /> <a name="mergeTwoSortedListsNonRecursive"></a></p><h2 id="non-recursive-1"><span class="me-2">Non-Recursive</span><a href="#non-recursive-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Similar approach and implemenation to the recursive solution above but a little more intuitive and does not require memory being held on the stack (as the recursive program runs it has to store variables on the stack so that when the program jumps back it is able to continue)</p><p>As with most other linked list solutions, a dummy node is utilized and two pointers are used to keep track of where we are in the the two linked lists.</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">solution</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="nc">ListNode</span> <span class="nf">mergeTwoLists</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">l1</span><span class="o">,</span> <span class="nc">ListNode</span> <span class="n">l2</span><span class="o">)</span> <span class="o">{</span>
		
		<span class="nc">ListNode</span> <span class="n">returnNode</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(-</span><span class="mi">1</span><span class="o">);</span> 
		<span class="nc">ListNode</span> <span class="n">headNode</span> <span class="o">=</span> <span class="n">returnNode</span><span class="o">;</span> 
		
		<span class="k">while</span> <span class="o">(</span><span class="n">l1</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">l2</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
			<span class="k">if</span> <span class="o">(</span><span class="n">l1</span><span class="o">.</span><span class="na">val</span> <span class="o">&lt;=</span> <span class="n">l2</span><span class="o">.</span><span class="na">val</span><span class="o">)</span> <span class="o">{</span>
				<span class="n">returnNode</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">l1</span><span class="o">;</span>
				<span class="n">l1</span> <span class="o">=</span> <span class="n">l1</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
			<span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
				<span class="n">returnNode</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">l2</span><span class="o">;</span>
				<span class="n">l2</span> <span class="o">=</span> <span class="n">l2</span><span class="o">.</span><span class="na">next</span><span class="o">;</span> 
			<span class="o">}</span>
			<span class="n">returnNode</span> <span class="o">=</span> <span class="n">returnNode</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
		<span class="o">}</span>

		<span class="k">if</span> <span class="o">(</span><span class="n">l1</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
			<span class="n">returnNode</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">l2</span><span class="o">;</span>
		<span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">l2</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
			<span class="n">returnNode</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">l1</span><span class="o">;</span> 
		<span class="o">}</span>

		<span class="k">return</span> <span class="n">headNode</span><span class="o">.</span><span class="na">next</span><span class="o">;</span> 
	<span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><br /><br /><br /> *** <a name="generateParentheses"></a></p><h1 id="22-generate-parentheses">22-Generate Parentheses</h1><p>Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre>For example: 

Given n=3, a solution set is: 

[
  "((()))",
  "(()())".
  "(())()",
  "()(())",
  "()()()"
]
</pre></table></code></div></div><p><br /><br /> <a name="generateParenthesesBruteForce"></a></p><h2 id="brute-force-4"><span class="me-2">Brute Force</span><a href="#brute-force-4" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><strong>Intuition</strong></p><p>We can generate all 2^(2n) sequences of <code class="language-plaintext highlighter-rouge">(</code> and <code class="language-plaintext highlighter-rouge">)</code> characters. Then we can check if each one is valid</p><p><br /></p><p><strong>Algorithm</strong></p><p>To generate all sequences, we use recursion. All sequences of length <code class="language-plaintext highlighter-rouge">n</code> is just <code class="language-plaintext highlighter-rouge">(</code> plus all sequences of length <code class="language-plaintext highlighter-rouge">n-1</code>, and then <code class="language-plaintext highlighter-rouge">)</code> plus all sequences of length <code class="language-plaintext highlighter-rouge">n-1</code>.</p><p>To check whether a sequence is valid, we keep track of <code class="language-plaintext highlighter-rouge">balance</code>, the net number of opening brackets minuts closing brackets. If it falls below zero at any time, or doesn’t end in zero, the sequence is invalid - otherwise it is valid.</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
	
	<span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="nf">generateParenthesis</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
		
		<span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">combinations</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">();</span> 
		<span class="n">generateAll</span><span class="o">(</span><span class="k">new</span> <span class="kt">char</span><span class="o">[</span><span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="o">],</span> <span class="mi">0</span><span class="o">,</span> <span class="n">combinations</span><span class="o">);</span>
		<span class="k">return</span> <span class="n">combinations</span><span class="o">;</span>
	<span class="o">}</span>

	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">generateAll</span><span class="o">(</span><span class="kt">char</span><span class="o">[]</span> <span class="n">current</span><span class="o">,</span> <span class="kt">int</span> <span class="n">pos</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">result</span><span class="o">)</span> <span class="o">{</span>
		
		<span class="k">if</span><span class="o">(</span><span class="n">pos</span> <span class="o">==</span> <span class="n">current</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">{</span>
			
			<span class="k">if</span> <span class="o">(</span><span class="n">valid</span><span class="o">(</span><span class="n">current</span><span class="o">))</span> <span class="o">{</span>
				<span class="n">result</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">current</span><span class="o">));</span>
			<span class="o">}</span> 

		<span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
			<span class="n">current</span><span class="o">[</span><span class="n">pos</span><span class="o">]</span> <span class="o">=</span> <span class="sc">'('</span><span class="o">;</span>
			<span class="n">generateAll</span><span class="o">(</span><span class="n">current</span><span class="o">,</span> <span class="n">pos</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">result</span><span class="o">);</span>
			<span class="n">current</span><span class="o">[</span><span class="n">pos</span><span class="o">]</span> <span class="o">=</span> <span class="sc">')'</span><span class="o">;</span>
			<span class="n">generateAll</span><span class="o">(</span><span class="n">current</span><span class="o">,</span> <span class="n">pos</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">result</span><span class="o">);</span>
		
		<span class="o">}</span>
	<span class="o">}</span>

	<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">valid</span><span class="o">(</span><span class="kt">char</span><span class="o">[]</span> <span class="n">current</span><span class="o">)</span> <span class="o">{</span>
		
		<span class="kt">int</span> <span class="n">balance</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> 
		<span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">:</span> <span class="n">current</span><span class="o">)</span> <span class="o">{</span>
			
			<span class="k">if</span><span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">'('</span><span class="o">)</span> <span class="o">{</span>
				<span class="n">balance</span><span class="o">++;</span>
			<span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
				<span class="n">balance</span><span class="o">--;</span>
			<span class="o">}</span>

			<span class="k">if</span><span class="o">(</span><span class="n">balance</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
				<span class="k">return</span> <span class="kc">false</span><span class="o">;</span> 
			<span class="o">}</span>
		<span class="o">}</span>
		<span class="k">return</span> <span class="o">(</span><span class="n">balance</span> <span class="o">==</span> <span class="mi">0</span><span class="o">);</span>
	<span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><strong>Complexity Analysis</strong></p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>Time Complexity: 	O(2^2n * n)	For each of 2^2n sequences, we need to create an validate the 
					sequence, which takes O(n) work in the worst case 

Space Complexity: 	O(2^2n * n) 	Naively, every sequence could be valid, see Closure number for
					a tighter asymptotic bound 
</pre></table></code></div></div><p><br /><br /> <a name="generateParenthesesBacktracking"></a></p><h2 id="backtracking-1"><span class="me-2">Backtracking</span><a href="#backtracking-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><strong>Intuition and Algorithm</strong></p><p>Instead of adding <code class="language-plaintext highlighter-rouge">(</code> or <code class="language-plaintext highlighter-rouge">)</code> every time as we do in the Brute Force algorithm, let’s only add them when we know it will remain a valid sequence. We can do this by keeping track of the number of opening and closing brackets we have placed so far.</p><p>We can start an opening bracket if we still have one (of <code class="language-plaintext highlighter-rouge">n</code>) left to place. And we can start a closing bracket if it would not exceed the number of opening brackets</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
	
	<span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="nf">generateParenthesis</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
		
		<span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">ans</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">();</span> 
		<span class="n">backtrack</span><span class="o">(</span><span class="n">ans</span><span class="o">,</span> <span class="s">""</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">n</span><span class="o">);</span>
		<span class="k">return</span> <span class="n">ans</span><span class="o">;</span> 
	<span class="o">}</span>

	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">backtrack</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">ans</span><span class="o">,</span> <span class="nc">String</span> <span class="n">cur</span><span class="o">,</span> <span class="kt">int</span> <span class="n">open</span><span class="o">,</span> <span class="kt">int</span> <span class="n">close</span><span class="o">,</span> <span class="kt">int</span> <span class="n">max</span><span class="o">){</span>
		
		<span class="k">if</span> <span class="o">(</span><span class="n">cur</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">==</span> <span class="n">max</span><span class="o">*</span><span class="mi">2</span><span class="o">)</span> <span class="o">{</span>
			<span class="n">ans</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">cur</span><span class="o">);</span>
			<span class="k">return</span><span class="o">;</span>
		<span class="o">}</span>

		<span class="k">if</span><span class="o">(</span><span class="n">open</span> <span class="o">&lt;</span> <span class="n">max</span><span class="o">)</span> <span class="o">{</span>
			<span class="n">backtrack</span><span class="o">(</span><span class="n">ans</span><span class="o">,</span> <span class="n">cur</span> <span class="o">+</span> <span class="s">"("</span><span class="o">,</span> <span class="n">open</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">close</span><span class="o">,</span> <span class="n">max</span><span class="o">);</span>
		<span class="o">}</span> 
		
		<span class="k">if</span> <span class="o">(</span><span class="n">close</span> <span class="o">&lt;</span> <span class="n">open</span><span class="o">)</span> <span class="o">{</span>
			<span class="n">backtrack</span><span class="o">(</span><span class="n">ans</span><span class="o">,</span> <span class="n">cur</span> <span class="o">+</span> <span class="s">")"</span><span class="o">,</span> <span class="n">open</span><span class="o">,</span> <span class="n">close</span> <span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">max</span><span class="o">);</span>
		<span class="o">}</span>
	<span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><strong>Complexity Analysis</strong></p><p>Our complexity analysis rests on understanding how many elements there are in <code class="language-plaintext highlighter-rouge">generateParenthesis(n)</code>. This analysis is outside the scope of this article, but it turns out this is the nth Catalan number 1/(n+1) (2n choose n), which is bounded asymptotically by 4^n/(n* sqrt(n)).</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>Time Complexity: 	O((4^n)/sqrt(n))	Each valid sequence has at most n steps during the 
						backtracking procedure

Space Complexity: 	O((4^n)/sqrt(n))	As described above and using O(n) space to store the
						sequence
</pre></table></code></div></div><p>Another way to think about the runtime of backtracking algorithms on interviewers is O(b^d), where b is the branching factor and d is the maximum depth of recursion.</p><p>Backtracking is characterized by a number of decisions b that can be made at each level of recursion. If you visualize the recursion tree, this is the number of children each internal node has. You can also think of b as standing for “base”, which helps us remember that b is the base of the exponential.</p><p>If we make b decisions at each level of recursion, and we expand the recursion tree to d levels (ie. each path has a length of d), then we get b^d nodes. Since backtracking is exhaustive and must visit each of these nodes, the runtime is O(b^d)</p><p><br /><br /> <a name="generateParenthesesClosureNumber"></a></p><h2 id="closure-number"><span class="me-2">Closure Number</span><a href="#closure-number" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>To enumerate something, generally we would like to express it as a sum of disjoint subsets that are easier to count.</p><p>Consider the <em>closure number</em> of a valid parentheses sequence <code class="language-plaintext highlighter-rouge">s</code>: the least <code class="language-plaintext highlighter-rouge">index &gt;= 0</code> so that `S[0], S[1], … , S[2 * index + 1] is valid. Clearly, every parentheses sequence has a unique closure number. We can try to enumerate them individually.</p><p><br /><br /></p><p><strong>Algorithm</strong></p><p>For each closure number c, we know the starting and ending brackets must be at index <code class="language-plaintext highlighter-rouge">0</code> and <code class="language-plaintext highlighter-rouge">2 * c + 1</code>. Then, the <code class="language-plaintext highlighter-rouge">2 * c</code> elements between must be a valid sequence, plus the rest of the elements must be a valid sequence.</p><p>This is just some minor improvement to the backtracking solution using the fact that for all valid solutions the first char is always ‘(‘ and the lat char is always ‘)’. We initialize the starting string to ‘(‘ and set the recursion bottom condition to string reaching length of <code class="language-plaintext highlighter-rouge">2 * n - 1</code> - we know that we need to append a bracket at the end. There will not be much of an improvement in the runtime however.</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="nf">generateParenthesis</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
		<span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">ans</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">();</span> 
		<span class="k">if</span> <span class="o">(</span><span class="n">n</span><span class="o">==</span><span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
			<span class="n">ans</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">""</span><span class="o">);</span>
		<span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
			<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">c</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">c</span><span class="o">&lt;</span><span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">c</span><span class="o">)</span>
				<span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="nl">left:</span> <span class="n">generateParenthesis</span><span class="o">(</span><span class="n">c</span><span class="o">))</span>
					<span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="nl">right:</span> <span class="n">generateParenthesis</span><span class="o">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">c</span><span class="o">))</span>
						<span class="n">ans</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"("</span> <span class="o">+</span> <span class="n">left</span> <span class="o">+</span> <span class="s">")"</span> <span class="o">+</span> <span class="n">right</span><span class="o">);</span>
		<span class="o">}</span>
		<span class="k">return</span> <span class="n">ans</span><span class="o">;</span>
	<span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><strong>Complexity Analysis</strong></p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>Time Complexity: 	O((4^n)/sqrt(n))

Space Complexity: 	O((4^n)/sqrt(n))
</pre></table></code></div></div><p><br /><br /><br /> *** <a name="mergeKSortedLists"></a></p><h1 id="23-merge-k-sorted-lists">23-Merge k Sorted Lists</h1><p>Merge k sorted linked lists and return it as one sorted list. Analyze and descibe its complexity:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre>Example: 

Input: 
[
	1 -&gt; 4 -&gt; 5,
	1 -&gt; 3 -&gt; 4,
	2 -&gt; 6
]

Output: 1 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 4 -&gt; 5 -&gt; 6
</pre></table></code></div></div><p><br /><br /> <a name="mergeKSortedLists"></a></p><h2 id="brute-force-5"><span class="me-2">Brute Force</span><a href="#brute-force-5" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><strong>Intuition and Algorithm</strong></p><ul><li>Traverse all the linked lists and collect the values of the nodes into an array<li>Sort and iterate over this array to get the proper value of nodes<li>Create a new sorted linked list and extend it with the new nodes</ul><p>As for sorting you can refer to the Algorithms/Data Structures CheatSheet for more about sorting algorithms.</p><p><br /><br /><br /> *** <a name="lruCache"></a></p><h1 id="146-lru-cache">146-LRU Cache</h1><p>Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: <code class="language-plaintext highlighter-rouge">get</code> and <code class="language-plaintext highlighter-rouge">put</code>.</p><p><code class="language-plaintext highlighter-rouge">get(key)</code> - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return <code class="language-plaintext highlighter-rouge">-1</code></p><p><code class="language-plaintext highlighter-rouge">put(key, value)</code> - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.</p><p><strong>Follow up:</strong> Could both of these operations be done in <strong>O(1)</strong> time complexity?</p><p><strong>Example:</strong></p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre>LRUCache cache = new LRUCache(2 /* capacity */);

cache.put(1, 1);
cache.put(2, 2);
cache.get(1); 			// returns 1 
cache.put(3, 3); 		// evicts key 2
cache.get(2);			// returns -1 (not found)
	
</pre></table></code></div></div><h1 id="index">Index</h1><ol><li><a href="#lowest-common-ancestor">Lowest Common Ancestor</a><li><a href="#count-and-say">Count And Say</a><li><a href="#maximum-subarray">Maximum SubArray</a><li><a href="#plus-one">Plus One</a><li><a href="#sqrt-of-x">Sqrt of X</a><li><a href="#climbing-stairs">Climbing Stairs</a><li><a href="#remove-duplicates-from-sorted-list">Remove Duplicates from sorted list</a><li><a href="#same-tree">Same Tree</a><li><a href="#symmetric-tree">Symmetric Tree</a><li><a href="#max-depth-of-binary-tree">Max Depth of Binary Tree</a><li><a href="#convert-sorted-array-to-binary-search-tree">Convert Sorted Array to Binary Search Tree</a><li><a href="#balanced-binary-tree">Balanced Binary Tree</a><li><a href="#minimum-depth-of-binary-tree">Minimum Depth of Binary Tree</a><li><a href="#path-sum">Path Sum</a><li><a href="#pascal's-triangle">Pascal’s Triangle</a><li><a href="#valid-palindrome">Valid Palindrome</a><li><a href="#pascal's-triangle-ii">Pascal’s Triangle II</a><li><a href="#best-time-to-buy-and-sell-stock">Best Time to Buy and Sell Stock</a><li><a href="#best-time-to-buy-and-sell-stock-ii">Best Time to Buy and Sell Stock II</a><li><a href="#single-number">Single Number</a><li><a href="#linked-list-cycle">Linked List Cycle</a><li><a href="#min-stack">Min Stack</a><li><a href="#intersection-of-two-linked-lists">Intersection of Two Linked Lists</a><li><a href="#two-sum-ii---input-array-is-sorted">Two Sum II - Input array is sorted</a><li><a href="#excel-sheet-column-title">Excel Sheet Column Title</a><li><a href="#majority-element">Majority Element</a><li><a href="#excel-sheet-column-number">Excel Sheet Column Number</a><li><a href="#factorial-trailing-zeroes">Factorial Trailing Zeroes</a><li><a href="#combine-two-tables">Combine Two Tables</a><li><a href="#second-highest-salary">Second Highest Salary</a><li><a href="#employees-earning-more-than-their-managers">Employees Earning More Than Their Managers</a><li><a href="#duplicate-emails">Duplicate Emails</a><li><a href="#customers-who-never-order">Customers Who Never Order</a><li><a href="#rotate-array">Rotate Array</a><li><a href="#delete-duplicate-emails">Delete Duplicate Emails</a><li><a href="#rising-temperature">Rising Temperature</a><li><a href="#x-of-a-kind-in-a-deck-of-cards">X of a Kind in a Deck of Cards</a><li><a href="#reverse-integer">Reverse Integer</a><li><a href="#add-two-numbers">Add Two Numbers</a><li><a href="#longest-substring-without-repeating-characters">Longest Substring Without Repeating Characters</a><li><a href="#house-robber">House Robber</a><li><a href="#happy-number">Happy Number</a><li><a href="#remove-linked-list-elements">Remove Linked List Elements</a><li><a href="#count-primes">Count Primes</a><li><a href="#isomorphic-strings">Isomorphic Strings</a><li><a href="#reverse-linkedlist">Reverse LinkedList</a><li><a href="#contains-duplicate">Contains Duplicate</a><li><a href="#contains-duplicate-ii">Contains Duplicate II</a><li><a href="#implement-stack-using-queues">Implement Stack Using Queues</a><li><a href="#invert-binary-tree">Invert Binary Tree</a><li><a href="#fibonacci-number">Fibonacci Number</a><li><a href="#kth-largest-element">kth Largest Element</a><li><a href="#power-of-two">Power Of Two</a><li><a href="#valid-sudoku">Valid Sudoku</a><li><a href="#implement-queue-using-stack">Implement Queue Using Stack</a><li><a href="#palindrome-linkedlist">Palindrome LinkedList</a><li><a href="#delete-node-in-a-linked-list">Delete Node in a Linked List</a><li><a href="#is-anagram">Is Anagram</a><li><a href="#binary-tree-paths">Binary Tree Paths</a><li><a href="#add-digits">Add Digits</a><li><a href="#largest-perimeter-triangle">Largest Perimeter Triangle</a><li><a href="#ugly-number">Ugly Number</a><li><a href="#missing-number">Missing Number</a><li><a href="#is-bad-version">Is Bad Version</a><li><a href="#move-zeroes">Move Zeroes</a><li><a href="#word-pattern">Word Pattern</a><li><a href="#can-win-nim">Can Win Nim</a><li><a href="#power-of-three">Power Of Three</a><li><a href="#power-of-four">Power of Four</a><li><a href="#reverse-string">Reverse String</a><li><a href="#implement-strstr()">Implement strStr()</a><li><a href="#reverse-vowels-of-a-string">Reverse Vowels of a String</a><li><a href="#intersection-of-two-arrays">Intersection of two arrays</a><li><a href="#is-perfect-square">Is Perfect Square</a><li><a href="#sum-of-two-integers">Sum of Two Integers</a><li><a href="#guess-number-higher-or-lower">Guess Number Higher or Lower</a><li><a href="#ransom-note">Ransom Note</a><li><a href="#first-unique-character-in-a-string">First Unique Character in a String</a><li><a href="#find-the-difference">Find the Difference</a><li><a href="#nth-digit">Nth Digit</a><li><a href="#sum-of-left-leaves">Sum of Left Leaves</a><li><a href="#longest-palindrome">Longest Palindrome</a><li><a href="#fizz-buzz">Fizz Buzz</a><li><a href="#third-maximum-number">Third maximum Number</a><li><a href="#add-two-strings">Add Two Strings</a><li><a href="#construct-quad-tree">Construct Quad Tree</a><li><a href="#n-ary-tree-level-order-traversal">N-ary Tree Level Order Traversal</a><li><a href="#number-of-segments-in-a-string">Number of Segments in a String</a><li><a href="#binary-tree-level-order-traversal">Binary Tree Level Order Traversal</a><li><a href="#path-sum-iii">Path Sum III</a><li><a href="#find-all-anagrams-in-a-string">Find All Anagrams in a String</a><li><a href="#arranging-coins">Arranging Coins</a><li><a href="#hamming-distance">Hamming Distance</a><li><a href="#string-compression">String Compression</a><li><a href="#number-of-boomerangs">Number of Boomerangs</a><li><a href="#find-all-numbers-disappeared-in-an-array">Find All Numbers Disappeared in an Array</a><li><a href="#assign-cookies">Assign Cookies</a><li><a href="#poor-pigs">Poor Pigs</a><li><a href="#find-pivot-index">Find Pivot Index</a><li><a href="#squares-of-a-sorted-array">Squares of a Sorted Array</a><li><a href="#repeated-substring-pattern">Repeated Substring Pattern</a><li><a href="#island-perimeter">Island Perimeter</a><li><a href="#number-complement">Number Complement</a><li><a href="#binary-watch">Binary Watch</a><li><a href="#minimum-moves-to-equal-array-elements">Minimum Moves to Equal Array Elements</a><li><a href="#license-key-formatting">License Key Formatting</a><li><a href="#max-consecutive-ones">Max Consecutive Ones</a><li><a href="#permutations">Permutations</a><li><a href="#construct-the-rectangle">Construct the Rectangle</a><li><a href="#merge-intervals">Merge Intervals</a><li><a href="#merged-sorted-lists">Merged sorted lists</a><li><a href="#next-greater-element-i">Next Greater Element I</a><li><a href="#string-without-aaa-or-bbb">String Without AAA or BBB</a><li><a href="#keyboard-row">Keyboard Row</a><li><a href="#find-mode-in-binary-search-tree">Find Mode in Binary Search Tree</a><li><a href="#base-7">Base 7</a><li><a href="#relative-ranks">Relative Ranks</a><li><a href="#perfect-number">Perfect Number</a><li><a href="#detect-capital">Detect Capital</a><li><a href="#longest-uncommon-subsequence-i">Longest Uncommon Subsequence I</a><li><a href="#course-schedule-ii">Course Schedule II</a><li><a href="#letter-combinations-of-a-phone-number">Letter Combinations of a Phone Number</a><li><a href="#sudoku-solver">Sudoku Solver</a><li><a href="#bulls-and-cows">Bulls and Cows</a><li><a href="#n-queens-1">N-Queens 1</a><li><a href="#k-diff-pairs-in-an-array">K-diff pairs in an Array</a><li><a href="#is-subsequence">Is Subsequence</a><li><a href="#minimum-absolute-difference-in-bst">Minimum Absolute Difference in BST</a><li><a href="#bst-tree-to-greater-tree">BST Tree to Greater Tree</a><li><a href="#student-attendance-record-I">Student Attendance Record I</a><li><a href="#reverse-words-in-string-iii">Reverse Words in String III</a><li><a href="#quad-tree-intersection">Quad Tree Intersection</a><li><a href="#long-pressed-name">Long Pressed Name</a><li><a href="#binary-tree-zigzag-level-order-traversal">Binary Tree Zigag Level Order Traversal</a><li><a href="#array-partition-I">Array Partition I</a><li><a href="#reshape-the-matrix">Reshape the matrix</a><li><a href="#swap-nodes-in-pairs">Swap Nodes in Pairs</a><li><a href="#generate-parentheses">Generate Parentheses</a><li><a href="#distribute-candies">Distribute Candies</a><li><a href="#maximum-subproduct-subarray">Maximum Subproduct Subarray</a><li><a href="#binary-tree-right-side-view">Binary Tree Right Side View</a><li><a href="#find-minimum-in-rotated-sorted-array">Find Minimum in Rotated Sorted Array</a><li><a href="#binary-search-tree-iterator">Binary Search Tree Iterator</a><li><a href="#find-peak-element">Find Peak Element</a><li><a href="#next-permutation">Next Permutation</a><li><a href="#search-in-rotated-sorted-array">Search in Rotated Sorted Array</a><li><a href="#transpose-matrix">Transpose Matrix</a><li><a href="#merge-k-sorted-lists">Merge K sorted lists</a></ol><hr /><hr /><h3 id="lowest-common-ancestor"><span class="me-2"><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/">Lowest Common Ancestor</a><a name="lowest-common-ancestor"></a></span><a href="#lowest-common-ancestor" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="nc">TreeNode</span> <span class="nf">lowestCommonAncestor</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">,</span> <span class="nc">TreeNode</span> <span class="n">p</span><span class="o">,</span> <span class="nc">TreeNode</span> <span class="n">q</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">TreeNode</span> <span class="n">current</span> <span class="o">=</span> <span class="n">root</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">current</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">val</span> <span class="o">&lt;</span> <span class="n">current</span><span class="o">.</span><span class="na">val</span> <span class="o">&amp;&amp;</span> <span class="n">q</span><span class="o">.</span><span class="na">val</span> <span class="o">&lt;</span> <span class="n">current</span><span class="o">.</span><span class="na">val</span><span class="o">)</span>		<span class="c1">// Both located in left side.</span>
            <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
        <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">val</span> <span class="o">&gt;</span> <span class="n">current</span><span class="o">.</span><span class="na">val</span> <span class="o">&amp;&amp;</span> <span class="n">q</span><span class="o">.</span><span class="na">val</span> <span class="o">&gt;</span> <span class="n">current</span><span class="o">.</span><span class="na">val</span><span class="o">)</span>	<span class="c1">// Both located in right side</span>
            <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
        <span class="k">else</span>
            <span class="k">return</span> <span class="n">current</span><span class="o">;</span>		<span class="c1">// Seperate branches, therefore current is lca.</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="count-and-say"><span class="me-2"><a href="https://leetcode.com/problems/count-and-say/">Count And Say</a><a name="count-and-say"></a></span><a href="#count-and-say" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>The updated version runs in 2ms and passes 96.85% submissions.</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="nc">String</span> <span class="nf">countAndSay</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">String</span> <span class="n">result</span> <span class="o">=</span> <span class="s">"1"</span><span class="o">;</span>		<span class="c1">// initial result</span>
    <span class="nc">StringBuilder</span> <span class="n">temp</span><span class="o">;</span>			<span class="c1">// to create intermediate strings efficiently.</span>
    <span class="kt">int</span> <span class="n">len</span><span class="o">;</span>					<span class="c1">// length of the result string.</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>	<span class="c1">// We need to iterate n-1 times, because 1st result is 1</span>
        <span class="kt">int</span> <span class="n">startIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>			<span class="c1">// we will look at each index of result</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>	<span class="c1">// and store freq,char in the builder</span>
        <span class="n">len</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">startIndex</span> <span class="o">&lt;</span> <span class="n">len</span><span class="o">){</span>
            <span class="kt">char</span> <span class="n">ch</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">startIndex</span><span class="o">++);</span>	<span class="c1">// get the char at startIndex, and increment it, because we also want to look at the next character</span>
            <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>					<span class="c1">// intialize it's count to 1, we just saw it.</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">startIndex</span> <span class="o">&lt;</span> <span class="n">len</span> <span class="o">&amp;&amp;</span> <span class="n">ch</span> <span class="o">==</span> <span class="n">result</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">startIndex</span><span class="o">)){</span>
                <span class="n">count</span><span class="o">++;</span>			<span class="c1">// If next also matches, increment count and startIndex</span>
                <span class="n">startIndex</span><span class="o">++;</span>
            <span class="o">}</span>
            <span class="n">temp</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">count</span><span class="o">).</span><span class="na">append</span><span class="o">(</span><span class="n">ch</span><span class="o">);</span>	<span class="c1">// No more match, Add the freq and the char</span>
        <span class="o">}</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">temp</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>	<span class="c1">// Update result to generate the next cound-and-say</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="maximum-subarray"><span class="me-2"><a href="https://leetcode.com/problems/maximum-subarray/">Maximum SubArray</a><a name="maximum-subarray"></a></span><a href="#maximum-subarray" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">int</span> <span class="nf">maxSubArray</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">localMax</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>		<span class="c1">// keeps track of max sum between the previous and current</span>
    <span class="kt">int</span> <span class="n">globalMax</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>	<span class="c1">// keeps track of global max sum.</span>

    <span class="cm">/*
    The idea is as follows:
    If the current element is greater than the previous local max, then we found an element that is a better option then before.
    Then, if that localmax changed and is greater than our global max, update our global max.
    */</span>

    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
        <span class="n">localMax</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">localMax</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
        <span class="n">globalMax</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">localMax</span><span class="o">,</span> <span class="n">globalMax</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="n">globalMax</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="plus-one"><span class="me-2"><a href="https://leetcode.com/problems/plus-one/">Plus One</a><a name="plus-one"></a></span><a href="#plus-one" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">plusOne</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">digits</span><span class="o">)</span>
<span class="o">{</span>
    <span class="n">digits</span><span class="o">[</span><span class="n">digits</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span><span class="o">]++;</span>			<span class="c1">// Add one to the last place.</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">digits</span><span class="o">[</span><span class="n">digits</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">==</span> <span class="mi">10</span><span class="o">)</span>	<span class="c1">// If it became 10,</span>
    <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">digits</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">--)</span>	<span class="c1">// Then add one to its previous place</span>
        <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">digits</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="mi">10</span><span class="o">){</span>	<span class="c1">// If that also results in 10, keep propogating that 1</span>
                <span class="n">digits</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">]++;</span>		<span class="c1">// upstream</span>
                <span class="n">digits</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">digits</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">==</span> <span class="mi">10</span><span class="o">){</span>	<span class="c1">// If the index 0 is 10, then the number is a multiple of 10.</span>
            <span class="n">digits</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">digits</span><span class="o">.</span><span class="na">length</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>
            <span class="n">digits</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>		<span class="c1">// So increase length by 1 and set index 0 to 1.</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">digits</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="sqrt-of-x"><span class="me-2"><a href="https://leetcode.com/problems/sqrtx/">Sqrt of X</a><a name="sqrt-of-x"></a></span><a href="#sqrt-of-x" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">int</span> <span class="nf">mySqrt</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">long</span> <span class="n">x1</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">-</span> <span class="o">(</span><span class="mi">100</span> <span class="o">-</span> <span class="n">x</span><span class="o">)/</span><span class="mi">20</span><span class="o">;</span>		<span class="c1">// Using Newton's method of computing square roots.</span>
    <span class="kt">boolean</span> <span class="n">done</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(!</span><span class="n">done</span><span class="o">)</span>
    <span class="o">{</span>
        <span class="kt">long</span> <span class="n">x2</span> <span class="o">=</span> <span class="n">x1</span> <span class="o">-</span> <span class="o">(</span><span class="n">x1</span><span class="o">*</span><span class="n">x1</span> <span class="o">-</span> <span class="n">x</span><span class="o">)/(</span><span class="mi">2</span><span class="o">*</span><span class="n">x1</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">x2</span> <span class="o">==</span> <span class="n">x1</span><span class="o">)</span>
            <span class="n">done</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="k">else</span>
            <span class="n">x1</span> <span class="o">=</span> <span class="n">x2</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span><span class="n">x1</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="climbing-stairs"><span class="me-2"><a href="https://leetcode.com/problems/climbing-stairs/">Climbing Stairs</a><a name="climbing-stairs"></a></span><a href="#climbing-stairs" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">int</span> <span class="nf">climbStairs</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="o">)</span>		<span class="c1">// I chose n &lt; 4 because climbStairs(0 &lt;= n &lt;= 3) = n</span>
        <span class="k">return</span> <span class="n">n</span><span class="o">;</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
        <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
    <span class="c1">//return naiveDP(n, dp);</span>
    <span class="k">return</span> <span class="nf">efficientDP</span><span class="o">(</span><span class="n">n</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kt">int</span> <span class="nf">naiveDP</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="kt">int</span> <span class="n">dp</span><span class="o">[]){</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">n</span><span class="o">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span>		<span class="c1">// If already computed, return it.</span>
        <span class="k">return</span> <span class="n">dp</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
    <span class="kt">int</span> <span class="n">ways</span> <span class="o">=</span>  <span class="n">naiveDP</span><span class="o">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="n">dp</span><span class="o">)</span> <span class="o">+</span> <span class="n">naiveDP</span><span class="o">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="o">,</span> <span class="n">dp</span><span class="o">);</span>	<span class="c1">// Just like Fibonacci.</span>
    <span class="n">dp</span><span class="o">[</span><span class="n">n</span><span class="o">]</span> <span class="o">=</span> <span class="n">ways</span><span class="o">;</span>		<span class="c1">// Save it.</span>
    <span class="k">return</span> <span class="n">ways</span><span class="o">;</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kt">int</span> <span class="nf">efficientDP</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">){</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="o">)</span>
        <span class="k">return</span> <span class="n">n</span><span class="o">;</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>		<span class="c1">// Initialize dp of length n+1 to store n'th way.</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
        <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>					<span class="c1">// climbStairs(0 &lt;= n &lt;= 3) = n</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>	<span class="c1">// climbStairs(n) = climbStairs(n-1) + climbstairs(n-2);</span>
        <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">2</span><span class="o">];</span>  <span class="c1">// So fetch those values from the dp array.</span>
    <span class="k">return</span> <span class="n">dp</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="remove-duplicates-from-sorted-list"><span class="me-2"><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-list/">Remove Duplicates from sorted list</a><a name="remove duplicates from sorted list"></a></span><a href="#remove-duplicates-from-sorted-list" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="nc">ListNode</span> <span class="nf">deleteDuplicates</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">){</span>
    <span class="nc">ListNode</span> <span class="n">current</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
    <span class="c1">// while we haven't reached the tail</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">current</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">current</span><span class="o">.</span><span class="na">next</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
    <span class="o">{</span>
        <span class="c1">// if current's next is the same as current, skip and update its next</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">current</span><span class="o">.</span><span class="na">next</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">current</span><span class="o">.</span><span class="na">val</span> <span class="o">==</span> <span class="n">current</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">val</span><span class="o">)</span>
            <span class="n">current</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">head</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="same-tree"><span class="me-2"><a href="https://leetcode.com/problems/same-tree/">Same Tree</a><a name="same-tree"></a></span><a href="#same-tree" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isSameTree</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">p</span><span class="o">,</span> <span class="nc">TreeNode</span> <span class="n">q</span><span class="o">)</span>
<span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">p</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">q</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>		<span class="c1">// Two empty trees</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="c1">// If one of the node is null, the two trees can't be equal.</span>
    <span class="k">if</span> <span class="o">((</span><span class="n">p</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">q</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">||</span> <span class="o">(</span><span class="n">p</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">q</span> <span class="o">==</span> <span class="kc">null</span><span class="o">))</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="c1">// If the values in the two nodes are same, compare its's left and right sub-tree.</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">val</span> <span class="o">==</span> <span class="n">q</span><span class="o">.</span><span class="na">val</span><span class="o">)</span>
        <span class="k">return</span> <span class="nf">isSameTree</span><span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">q</span><span class="o">.</span><span class="na">left</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">isSameTree</span><span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">q</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>		<span class="c1">// If nothing worked out, they can't be same.</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="symmetric-tree"><span class="me-2"><a href="https://leetcode.com/problems/symmetric-tree/">Symmetric Tree</a><a name="symmetric-tree"></a></span><a href="#symmetric-tree" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isSymmetric</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span>
<span class="o">{</span>
    <span class="k">return</span> <span class="nf">isSymmetricIterative</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isSymmetricIterative</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span>
<span class="o">{</span>
    <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">TreeNode</span><span class="o">&gt;</span> <span class="n">track</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
    <span class="n">track</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>		<span class="c1">// Add the root twice so we can compare its left and right</span>
    <span class="n">track</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
    <span class="k">while</span> <span class="o">(!</span><span class="n">track</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span>
    <span class="o">{</span>
        <span class="nc">TreeNode</span> <span class="n">x</span> <span class="o">=</span> <span class="n">track</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>		<span class="c1">// Remove 2 nodes</span>
        <span class="nc">TreeNode</span> <span class="n">y</span> <span class="o">=</span> <span class="n">track</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">y</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>		<span class="c1">// If they are both null, skip it.</span>
            <span class="k">continue</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">y</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">x</span><span class="o">.</span><span class="na">val</span> <span class="o">!=</span> <span class="n">y</span><span class="o">.</span><span class="na">val</span><span class="o">)</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>				<span class="c1">// If values don't match or one is null</span>
        <span class="n">track</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>		<span class="c1">// Otherwise add them in this order -&gt; LRRL</span>
        <span class="n">track</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">y</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>		<span class="c1">// because we need to compare left most with the</span>
        <span class="n">track</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>		<span class="c1">// right most, then inner left with inner right.</span>
        <span class="n">track</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">y</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>		<span class="c1">// Everything's all right, so they must be symmetric.</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isSymmetricRecursive</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span>
<span class="o">{</span>
    <span class="k">return</span> <span class="nf">helperRecursive</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">root</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">helperRecursive</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">x</span><span class="o">,</span> <span class="nc">TreeNode</span> <span class="n">y</span><span class="o">)</span>
<span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">y</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>		<span class="c1">// Base Case: Both or one is null, so true</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="k">return</span> <span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">val</span> <span class="o">==</span> <span class="n">y</span><span class="o">.</span><span class="na">val</span> <span class="o">&amp;&amp;</span> <span class="n">helperRecursive</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">y</span><span class="o">.</span><span class="na">right</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">helperRecursive</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">y</span><span class="o">.</span><span class="na">left</span><span class="o">));</span>
    <span class="c1">// Check if values match and 1.left matches with the 2.right and 1.right matches with 2.left</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="max-depth-of-binary-tree"><span class="me-2"><a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/">Max Depth of Binary Tree</a><a name="max depth of binary tree"></a></span><a href="#max-depth-of-binary-tree" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="cm">/*
If root is null, height is 0 else add 1 and find if the left or the right has a greater depth.
*/</span>
<span class="kd">public</span> <span class="kt">int</span> <span class="nf">maxDepth</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">root</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span> <span class="o">+</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">maxDepth</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">),</span> <span class="n">maxDepth</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">));</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="convert-sorted-array-to-binary-search-tree"><span class="me-2"><a href="https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/">Convert Sorted Array to Binary Search Tree</a><a name="convert-sorted-array-to-binary-search-tree"></a></span><a href="#convert-sorted-array-to-binary-search-tree" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="nc">TreeNode</span> <span class="nf">sortedArrayToBST</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span>
<span class="o">{</span>
    <span class="k">return</span> <span class="nf">aux</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="nc">TreeNode</span> <span class="nf">aux</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">n</span><span class="o">,</span> <span class="kt">int</span> <span class="n">left</span><span class="o">,</span> <span class="kt">int</span> <span class="n">right</span><span class="o">)</span>
<span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">left</span> <span class="o">&gt;</span> <span class="n">right</span><span class="o">)</span>					<span class="c1">// Either empty, or return a null node</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>

    <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="o">(</span><span class="n">left</span><span class="o">+</span><span class="n">right</span><span class="o">+</span><span class="mi">1</span><span class="o">)/</span><span class="mi">2</span><span class="o">;</span>			<span class="c1">// Create a node with the middle value</span>
    <span class="nc">TreeNode</span> <span class="n">root</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="o">(</span><span class="n">n</span><span class="o">[</span><span class="n">mid</span><span class="o">]);</span>
    <span class="n">root</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">aux</span><span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">mid</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>	<span class="c1">// Compute the left (which is the mid in left side)</span>
    <span class="n">root</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">aux</span><span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">right</span><span class="o">);</span>	<span class="c1">// Compute the right (which is the mid in right side)</span>
    <span class="k">return</span> <span class="n">root</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="balanced-binary-tree"><span class="me-2"><a href="https://leetcode.com/problems/balanced-binary-tree/">Balanced Binary Tree</a><a name="balanced-binary-tree"></a></span><a href="#balanced-binary-tree" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isBalanced</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span>
<span class="o">{</span>
    <span class="k">return</span> <span class="nf">isBalancedBottomUp</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isBalancedTopDown</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span>
<span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="c1">// if difference between root's left and right is &gt; 1, they're not balanced</span>
    <span class="k">if</span> <span class="o">(</span><span class="nc">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">((</span><span class="n">getHeight</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">)</span> <span class="o">-</span> <span class="n">getHeight</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">)))</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="o">)</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="c1">// otherwise, we need to check if the left and right subtree are also balanced.</span>
    <span class="k">return</span> <span class="nf">isBalanced</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">isBalanced</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kt">int</span> <span class="nf">getHeight</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">node</span><span class="o">)</span>
<span class="o">{</span>
    <span class="c1">// Standard height of a binary tree calculator</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">node</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
        <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">getHeight</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">left</span><span class="o">),</span> <span class="n">getHeight</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">right</span><span class="o">));</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isBalancedBottomUp</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span>
<span class="o">{</span>
    <span class="k">return</span> <span class="nf">getHeight2</span><span class="o">(</span><span class="n">root</span><span class="o">)</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>	<span class="c1">// -1 means not balanced.</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kt">int</span> <span class="nf">getHeight2</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">node</span><span class="o">)</span>
<span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">node</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
        <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>

    <span class="kt">int</span> <span class="n">lHeight</span> <span class="o">=</span> <span class="n">getHeight2</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>	<span class="c1">// Get the height of left and right tree</span>
    <span class="kt">int</span> <span class="n">rHeight</span> <span class="o">=</span> <span class="n">getHeight2</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>

    <span class="c1">// If at any point there was a height difference of more than 1 or previous node's leftheight || rightheight returned -1, return -1 to let the next node know there was an imbalance.</span>
    <span class="k">if</span> <span class="o">((</span><span class="nc">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">lHeight</span><span class="o">-</span><span class="n">rHeight</span><span class="o">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">||</span> <span class="n">lHeight</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">||</span> <span class="n">rHeight</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>

    <span class="k">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">lHeight</span><span class="o">,</span> <span class="n">rHeight</span><span class="o">);</span> <span class="c1">// Else carry on with the normal procedure</span>
<span class="o">}</span>

</pre></table></code></div></div><h3 id="minimum-depth-of-binary-tree"><span class="me-2"><a href="https://leetcode.com/problems/minimum-depth-of-binary-tree/">Minimum Depth of Binary Tree</a><a name="minimum-depth-of-binary-tree"></a></span><a href="#minimum-depth-of-binary-tree" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">int</span> <span class="nf">minDepth</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// Base case</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
    <span class="c1">// Left is null, find minheight from right side</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">minDepth</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
    <span class="c1">// Right is null, find minheight from left side</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">minDepth</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
    <span class="c1">// Else, both are not null, so compute min height from the two sides.</span>
    <span class="k">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">minDepth</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">),</span> <span class="n">minDepth</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">));</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="path-sum"><span class="me-2"><a href="https://leetcode.com/problems/path-sum/">Path Sum</a><a name="path-sum"></a></span><a href="#path-sum" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">hasPathSum</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">,</span> <span class="kt">int</span> <span class="n">sum</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>	<span class="c1">// No sum exist</span>
    <span class="n">sum</span> <span class="o">-=</span> <span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">;</span>	<span class="c1">// Sum decreases</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">root</span><span class="o">.</span><span class="na">right</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>	<span class="c1">// If we are at a leaf</span>
        <span class="k">return</span> <span class="n">sum</span> <span class="o">==</span> <span class="mi">0</span><span class="o">;</span>	<span class="c1">// Check if the sum is 0.</span>
    <span class="k">return</span> <span class="nf">hasPathSum</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">sum</span><span class="o">)</span> <span class="o">||</span> <span class="n">hasPathSum</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">sum</span><span class="o">);</span>
    <span class="c1">// Otherwise look if you can make sum = 0 by exploring the left or right side.</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="pascals-triangle"><span class="me-2"><a href="https://leetcode.com/problems/pascals-triangle/">Pascal’s Triangle</a><a name="pascal's-triangle"></a></span><a href="#pascals-triangle" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="nf">generate</span><span class="o">(</span><span class="kt">int</span> <span class="n">numRows</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">pt</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numRows</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>	<span class="c1">// Need to add all n rows</span>
    <span class="o">{</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">temp</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>		<span class="c1">// temp list to store values</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">i</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span>
        <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">j</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="o">)</span>		<span class="c1">// First and last values are always 1.</span>
                <span class="n">temp</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
            <span class="k">else</span>	<span class="c1">// Else, get the previous row and surrounding two values and add them</span>
                <span class="n">temp</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">pt</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">).</span><span class="na">get</span><span class="o">(</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">+</span> <span class="n">pt</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">).</span><span class="na">get</span><span class="o">(</span><span class="n">j</span><span class="o">));</span>
        <span class="o">}</span>
        <span class="n">pt</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">temp</span><span class="o">);</span>		<span class="c1">// Add it to pt.</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">pt</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="valid-palindrome"><span class="me-2"><a href="https://leetcode.com/problems/valid-palindrome/">Valid Palindrome</a><a name="valid-palindrome"></a></span><a href="#valid-palindrome" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isPalindrome</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">){</span>		<span class="c1">// Only do this is s is not empty</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">toLowerCase</span><span class="o">();</span>	<span class="c1">// Convert it to lowercase</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>			<span class="c1">// Initialize left and right pointers</span>
        <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()-</span><span class="mi">1</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">)</span>	<span class="c1">// continue while we haven't hit the middle of the string</span>
        <span class="o">{</span>
            <span class="c1">// If char at left is not a letter or a number, skip it.</span>
            <span class="k">if</span> <span class="o">(!</span><span class="nc">Character</span><span class="o">.</span><span class="na">isLetter</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">left</span><span class="o">))</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nc">Character</span><span class="o">.</span><span class="na">isDigit</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">left</span><span class="o">)))</span>
                <span class="n">left</span><span class="o">++;</span>
            <span class="c1">// Same with char at right.</span>
            <span class="k">else</span> <span class="nf">if</span> <span class="o">(!</span><span class="nc">Character</span><span class="o">.</span><span class="na">isLetter</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">right</span><span class="o">))</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nc">Character</span><span class="o">.</span><span class="na">isDigit</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">right</span><span class="o">)))</span>
                <span class="n">right</span><span class="o">--;</span>
            <span class="c1">//Char's are now alphanumeric.</span>
            <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">left</span><span class="o">)</span> <span class="o">!=</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">right</span><span class="o">))</span>	<span class="c1">// If they don't match</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>	<span class="c1">// return false</span>
            <span class="k">else</span>	<span class="c1">// They matched, so try to match the inner string</span>
            <span class="o">{</span>
                <span class="n">left</span><span class="o">++;</span>
                <span class="n">right</span><span class="o">--;</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>	<span class="c1">// No mismatch found, return true.</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="pascals-triangle-ii"><span class="me-2"><a href="https://leetcode.com/problems/pascals-triangle-ii/">Pascal’s Triangle II</a><a name="pascal's-triangle-ii"></a></span><a href="#pascals-triangle-ii" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="nf">getRow</span><span class="o">(</span><span class="kt">int</span> <span class="n">rowIndex</span><span class="o">)</span>
<span class="o">{</span>
    <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">row</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
    <span class="n">row</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>	<span class="c1">// First is always 1.</span>
	<span class="c1">// Using the nth row formula to compute the coeeficients. You can google "nth row Pascal"</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">rowIndex</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
        <span class="n">row</span><span class="o">.</span><span class="na">add</span><span class="o">((</span><span class="kt">int</span><span class="o">)(</span><span class="mf">1.0</span><span class="o">*</span><span class="n">row</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">)*(</span><span class="n">rowIndex</span><span class="o">-</span><span class="n">i</span><span class="o">)/(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">)));</span>
    <span class="k">return</span> <span class="n">row</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="best-time-to-buy-and-sell-stock"><span class="me-2"><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/">Best Time to Buy and Sell Stock</a><a name="best-time-to-buy-and-sell-stock"></a></span><a href="#best-time-to-buy-and-sell-stock" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><pre><code class="language-Java">/*
The general idea is that if the price you are looking at right now in the array minus the minimum observed so far is greater than the maximum profit you recorded, update the max.
*/
public int maxProfit(int[] prices) {
    if (prices.length == 0)		// Empty array
        return 0;
    int min = prices[0];

    int max = 0;
    for (int i = 1; i &lt; prices.length; i++)
    {
        if (prices[i] &lt; min)
            min = prices[i];
        else if (prices[i] - min &gt; max)
            max = prices[i]-min;
    }
    return max;
}
</code></pre><h3 id="best-time-to-buy-and-sell-stock-ii"><span class="me-2"><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/">Best Time to Buy and Sell Stock II</a><a name="best-time-to-buy-and-sell-stock-ii"></a></span><a href="#best-time-to-buy-and-sell-stock-ii" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="cm">/*
The general idea is that the moment you observe a valley and consecutive peak, make the trade by buying the stock on the valley day and selling it on the peak day.
*/</span>
<span class="kd">public</span> <span class="kt">int</span> <span class="nf">maxProfit</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">prices</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">prices</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">prices</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">prices</span><span class="o">[</span><span class="n">i</span><span class="o">])</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="o">(</span><span class="n">prices</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">]</span> <span class="o">-</span> <span class="n">prices</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
    <span class="k">return</span> <span class="n">sum</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="single-number"><span class="me-2"><a href="https://leetcode.com/problems/single-number/">Single Number</a><a name="single-number"></a></span><a href="#single-number" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="cm">/*
The general idea is that XOR of two same numbers returns 0 and XOR with 0 returns the same number. So if there is only one element that doesn't have a pair, all the remaining will XOR with themselves at one point and give 0 but not the singleton element.
*/</span>
<span class="kd">public</span> <span class="kt">int</span> <span class="nf">singleNumber</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
        <span class="n">num</span> <span class="o">^=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
    <span class="k">return</span> <span class="n">num</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="linked-list-cycle"><span class="me-2"><a href="https://leetcode.com/problems/linked-list-cycle/">Linked List Cycle</a><a name="linked-list-cycle"></a></span><a href="#linked-list-cycle" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="c1">// Using the slow-fast runner technique.</span>
<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">hasCycle</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">head</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="nc">ListNode</span> <span class="n">first</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>	<span class="c1">// Slow runner</span>
    <span class="nc">ListNode</span> <span class="n">second</span> <span class="o">=</span> <span class="n">first</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>		<span class="c1">// Fast Runner</span>
    <span class="c1">// while second is not at the end or it isn't the tail</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">second</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">second</span><span class="o">.</span><span class="na">next</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
    <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">second</span> <span class="o">==</span> <span class="n">first</span><span class="o">)</span>	<span class="c1">// If fast made a full loop and met up with slow</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>		<span class="c1">// We got a cycle</span>
        <span class="n">first</span> <span class="o">=</span> <span class="n">first</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>		<span class="c1">// Slow moves one step</span>
        <span class="n">second</span> <span class="o">=</span> <span class="n">second</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>	<span class="c1">// Second advances two.</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>		<span class="c1">// We don't have a cycle</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="min-stack"><span class="me-2"><a href="https://leetcode.com/problems/min-stack/">Min Stack</a><a name="min-stack"></a></span><a href="#min-stack" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><pre><code class="language-Java">class MinStack {

    int min;
    Stack&lt;Integer&gt; stack;

    public MinStack() {
        min = Integer.MAX_VALUE;
        stack = new Stack&lt;&gt;();
    }

    public void push(int x) {
        stack.push(x);		// Push the value
        if (x &lt; min)		// If that value is minimum than we have, update min
            min = x;
        stack.push(min);	// Push the minimum on top of the stack for constant time
    }						// minimum retrieval.

    public void pop() {
        stack.pop();		// Pop the minimum.
        stack.pop();		// Pop the actual element meant to be popped
        if (stack.isEmpty())	// If empty, min is Max int value
            min = Integer.MAX_VALUE;
        else
            min = stack.peek();	// Otherwise, min would be the top most element since we
    }							// always push the minimum on top of any element we push.

    public int top() {
        return stack.elementAt(stack.size()-2);	// Top element is actually at second last
    }				// index since the last element is the minimum.

    public int getMin() {
        return min;
    }
}
</code></pre><h3 id="intersection-of-two-linked-lists"><span class="me-2"><a href="https://leetcode.com/problems/intersection-of-two-linked-lists/">Intersection of Two Linked Lists</a><a name="intersection-of-two-linked-lists"></a></span><a href="#intersection-of-two-linked-lists" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="cm">/*
The general idea is that if you are done traversing any of the lists, make it's pointer point to the head of the other list and start iterating. The reasoning is that the second time they iterate, they will have traversed exactly the same distance (it's length plus the other list's head to the intersecting node) and will meet at the intersecting node.
*/</span>
<span class="kd">public</span> <span class="nc">ListNode</span> <span class="nf">getIntersectionNode</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">headA</span><span class="o">,</span> <span class="nc">ListNode</span> <span class="n">headB</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="nc">ListNode</span> <span class="n">pA</span> <span class="o">=</span> <span class="n">headA</span><span class="o">;</span>
    <span class="nc">ListNode</span> <span class="n">pB</span> <span class="o">=</span> <span class="n">headB</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">pA</span> <span class="o">!=</span> <span class="n">pB</span><span class="o">){</span>
        <span class="n">pA</span> <span class="o">=</span> <span class="n">pA</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">?</span> <span class="n">headB</span> <span class="o">:</span> <span class="n">pA</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="n">pB</span> <span class="o">=</span> <span class="n">pB</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">?</span> <span class="n">headA</span> <span class="o">:</span> <span class="n">pB</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">pA</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="two-sum-ii---input-array-is-sorted"><span class="me-2"><a href="https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/">Two Sum II - Input array is sorted</a><a name="two-sum-ii---input-array-is-sorted"></a></span><a href="#two-sum-ii---input-array-is-sorted" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">twoSum</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">numbers</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">numbers</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">)</span>	<span class="c1">// Narrow down the window from both sides until they add up.</span>
    <span class="o">{</span>
        <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">numbers</span><span class="o">[</span><span class="n">left</span><span class="o">]</span> <span class="o">+</span> <span class="n">numbers</span><span class="o">[</span><span class="n">right</span><span class="o">];</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">sum</span> <span class="o">&gt;</span> <span class="n">target</span><span class="o">)</span>	<span class="c1">// We overshot, so decrease the window from right</span>
            <span class="n">right</span><span class="o">--;</span>
        <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">sum</span> <span class="o">&lt;</span> <span class="n">target</span><span class="o">)</span>	<span class="c1">// Undershot, increase windows from left so next sum is more</span>
            <span class="n">left</span><span class="o">++;</span>
        <span class="k">else</span>
            <span class="k">break</span><span class="o">;</span>				<span class="c1">// Found the two numbers</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]</span> <span class="o">{</span><span class="n">left</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">right</span><span class="o">+</span><span class="mi">1</span><span class="o">};</span>	<span class="c1">// +1 because LeetCode followed 1-n indexing.</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="excel-sheet-column-title"><span class="me-2"><a href="https://leetcode.com/problems/excel-sheet-column-title/">Excel Sheet Column Title</a><a name="excel-sheet-column-title"></a></span><a href="#excel-sheet-column-title" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="nc">String</span> <span class="nf">convertToTitle</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">String</span> <span class="n">res</span> <span class="o">=</span> <span class="s">""</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span>
    <span class="o">{</span>
        <span class="cm">/* 1 is A and 26 is Z, so n-1 to change it to 0-25 scheme. Then, % 26 to find how
        much it is off on a full alphabet cycle, add 65 (ASCII for A) and convert it to char
        */</span>
        <span class="n">res</span> <span class="o">=</span> <span class="nc">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">((</span><span class="kt">char</span><span class="o">)(</span><span class="mi">65</span><span class="o">+((</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">)%</span><span class="mi">26</span><span class="o">)))</span> <span class="o">+</span> <span class="n">res</span><span class="o">;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="o">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">/</span> <span class="mi">26</span><span class="o">;</span>	<span class="c1">// Subtract 1 and divide by 26 to get prepare for the next character</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="majority-element"><span class="me-2"><a href="https://leetcode.com/problems/majority-element/">Majority Element</a><a name="majority-element"></a></span><a href="#majority-element" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Uses <a href="https://www.geeksforgeeks.org/majority-element/">Moore’s Algorithm</a></p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="c1">// This is the implementation of Moore's Algorithm for O(n) complexity.</span>
<span class="kd">public</span> <span class="kt">int</span> <span class="nf">majorityElement</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">major</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
    <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>

   <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">major</span> <span class="o">==</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">])</span>
            <span class="n">count</span><span class="o">++;</span>
        <span class="k">else</span>
            <span class="n">count</span><span class="o">--;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
            <span class="n">major</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="n">count</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">major</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="excel-sheet-column-number"><span class="me-2"><a href="https://leetcode.com/problems/excel-sheet-column-number/">Excel Sheet Column Number</a><a name="excel-sheet-column-number"></a></span><a href="#excel-sheet-column-number" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="cm">/*
Start from the end of String s, compute the ASCII for the char, +1 for 1-26 Alphabet-Scheme (hence -64 instead of -65) and multiply it to 26^{distance from the end of the string}
*/</span>
<span class="kd">public</span> <span class="kt">int</span> <span class="nf">titleToNumber</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">length</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()-</span><span class="mi">1</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">length</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">--)</span>
        <span class="n">total</span> <span class="o">+=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)-</span><span class="mi">64</span><span class="o">)</span> <span class="o">*</span> <span class="nc">Math</span><span class="o">.</span><span class="na">pow</span><span class="o">(</span><span class="mi">26</span><span class="o">,</span><span class="n">length</span><span class="o">-</span><span class="n">i</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">total</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="factorial-trailing-zeroes"><span class="me-2"><a href="https://leetcode.com/problems/factorial-trailing-zeroes/">Factorial Trailing Zeroes</a><a name="factorial-trailing-zeroes"></a></span><a href="#factorial-trailing-zeroes" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="cm">/*
The general idea is that every factorial that has 5 as a multiple also has 2 to multiply to 10. So if we can count the number of times we can divide n by 5, should gives us the number of trailing zeroes. O(log(n) base 5) complexity.
*/</span>
<span class="kd">public</span> <span class="kt">int</span> <span class="nf">trailingZeroes</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="o">)</span>
    <span class="o">{</span>
        <span class="n">res</span> <span class="o">+=</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">5</span><span class="o">;</span>
        <span class="n">n</span> <span class="o">/=</span> <span class="mi">5</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="combine-two-tables"><span class="me-2"><a href="https://leetcode.com/problems/combine-two-tables/">Combine Two Tables</a><a name="combine-two-tables"></a></span><a href="#combine-two-tables" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><pre><code class="language-mysql">select FirstName, LastName, City, State
from Person left join Address on Address.personId = person.personId;
</code></pre><h3 id="second-highest-salary"><span class="me-2"><a href="https://leetcode.com/problems/second-highest-salary/">Second Highest Salary</a><a name="second-highest-salary"></a></span><a href="#second-highest-salary" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><pre><code class="language-mysql">select max(salary) as SecondHighestSalary
from Employee
where salary not in (select max(salary) from employee);
</code></pre><h3 id="employees-earning-more-than-their-managers"><span class="me-2"><a href="https://leetcode.com/problems/employees-earning-more-than-their-managers/">Employees Earning More Than Their Managers</a><a name="employees-earning-more-than-their-managers"></a></span><a href="#employees-earning-more-than-their-managers" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><pre><code class="language-mysql">select emp.Name as Employee
from Employee emp, Employee man
where emp.managerId = man.Id and emp.salary &gt; man.salary;
</code></pre><h3 id="duplicate-emails"><span class="me-2"><a href="https://leetcode.com/problems/duplicate-emails/">Duplicate Emails</a><a name="duplicate-emails"></a></span><a href="#duplicate-emails" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><pre><code class="language-mysql">select email
from person
group by (email)
having count(*) &gt; 1;
</code></pre><h3 id="customers-who-never-order"><span class="me-2"><a href="https://leetcode.com/problems/customers-who-never-order/">Customers Who Never Order</a><a name="customers-who-never-order"></a></span><a href="#customers-who-never-order" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><pre><code class="language-mysql">select name as Customers
from Customers
where customers.id not in (select customerId from orders);
</code></pre><h3 id="rotate-array"><span class="me-2"><a href="https://leetcode.com/problems/rotate-array/">Rotate Array</a><a name="rotate-array"></a></span><a href="#rotate-array" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">void</span> <span class="nf">rotate</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">k</span> <span class="o">%=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>		<span class="c1">// k == nums.length ? Then it's a full rotation and no change</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
        <span class="k">return</span><span class="o">;</span>
    <span class="n">reverse</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="mi">0</span> <span class="o">,</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>	<span class="c1">// First reverse the full array</span>
    <span class="n">reverse</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>				<span class="c1">// Then reverse element from index 0 to k-1</span>
    <span class="n">reverse</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">k</span><span class="o">,</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>	<span class="c1">// Then reverse all elements from k to end of Array</span>
<span class="o">}</span>

<span class="c1">// Reverse function that reverses the array from specified indices.</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">reverse</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">start</span><span class="o">,</span> <span class="kt">int</span> <span class="n">end</span><span class="o">)</span>
<span class="o">{</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">start</span> <span class="o">&lt;</span> <span class="n">end</span><span class="o">){</span>
        <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">start</span><span class="o">];</span>
        <span class="n">nums</span><span class="o">[</span><span class="n">start</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">end</span><span class="o">];</span>
        <span class="n">nums</span><span class="o">[</span><span class="n">end</span><span class="o">]</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>
        <span class="n">start</span><span class="o">++;</span>
        <span class="n">end</span><span class="o">--;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="delete-duplicate-emails"><span class="me-2"><a href="https://leetcode.com/problems/delete-duplicate-emails/">Delete Duplicate Emails</a><a name="delete-duplicate-emails"></a></span><a href="#delete-duplicate-emails" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><pre><code class="language-mysql">delete from Person
where Id not in (select min_id from
(select min(Id) as min_id from Person group by Email) as a)
</code></pre><h3 id="rising-temperature"><span class="me-2"><a href="https://leetcode.com/problems/rising-temperature/">Rising Temperature</a><a name="rising-temperature"></a></span><a href="#rising-temperature" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><pre><code class="language-mysql">select w2.id
from weather w1, weather w2
where Datediff(w2.recorddate, w1.recorddate) = 1 and w2.temperature &gt; w1.temperature;
</code></pre><h3 id="x-of-a-kind-in-a-deck-of-cards"><span class="me-2"><a href="https://leetcode.com/problems/x-of-a-kind-in-a-deck-of-cards/">X of a Kind in a Deck of Cards</a><a name="x-of-a-kind-in-a-deck-of-cards"></a></span><a href="#x-of-a-kind-in-a-deck-of-cards" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">hasGroupsSizeX</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">deck</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">HashMap</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">freq</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>

    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">deck</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>		<span class="c1">// Record the frequencies</span>
        <span class="n">freq</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">deck</span><span class="o">[</span><span class="n">i</span><span class="o">],</span><span class="n">freq</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">deck</span><span class="o">[</span><span class="n">i</span><span class="o">],</span><span class="mi">0</span><span class="o">)+</span><span class="mi">1</span><span class="o">);</span>

<span class="cm">/*
deck = [1,1,2,2,2,2,3,3,3,3,3,3]
number 1 has len of 2, number 2 has len of 4, number 3 has len of 6, they share a Greatest common divisor of 2, which means diving them into group of size X = 2, will be valid. Thus we just have to ensure each length (of a number) shares a Greatest Common Divisor that's &gt;= 2.
*/</span>
    <span class="kt">int</span> <span class="n">hcf</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="nl">i:</span> <span class="n">freq</span><span class="o">.</span><span class="na">keySet</span><span class="o">())</span>
        <span class="n">hcf</span> <span class="o">=</span> <span class="n">gcd</span><span class="o">(</span><span class="n">hcf</span><span class="o">,</span> <span class="n">freq</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>

    <span class="k">return</span> <span class="n">hcf</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="o">;</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">gcd</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">)</span>
<span class="o">{</span>
    <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">y</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">){</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="n">y</span><span class="o">;</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">%</span> <span class="n">y</span><span class="o">;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="reverse-integer"><span class="me-2"><a href="https://leetcode.com/problems/reverse-integer/solution/">Reverse Integer</a><a name="reverse-integer"></a></span><a href="#reverse-integer" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><pre><code class="language-Java">public int reverse(int x) {
    int sign = x &lt; 0 ? -1 : 1;
    x = x * sign;							// Make x positive
    long n = 0;
    while (x &gt; 0){
        n = n * 10 + x % 10;				// Start adding from the end.
        x /= 10;
    }
    return (int)n == n ? (int)n*sign : 0;	// Try converting to int from long, if no change,
}											// Return n * sign, else 0 cause overflow.
</code></pre><h3 id="add-two-numbers"><span class="me-2"><a href="https://leetcode.com/problems/add-two-numbers/submissions/">Add Two Numbers</a><a name="add-two-numbers"></a></span><a href="#add-two-numbers" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="nc">ListNode</span> <span class="nf">addTwoNumbers</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">l1</span><span class="o">,</span> <span class="nc">ListNode</span> <span class="n">l2</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">carry</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>							<span class="c1">// To record the carry</span>
    <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>							<span class="c1">// To record the total of two vals</span>
    <span class="nc">ListNode</span> <span class="n">dummy</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>		<span class="c1">// Dummy's next is the actual head</span>
    <span class="nc">ListNode</span> <span class="n">curr</span> <span class="o">=</span> <span class="n">dummy</span><span class="o">;</span>
    <span class="k">do</span><span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">l1</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>						<span class="c1">// If one of the node is null, we set it to a</span>
            <span class="n">l1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>			<span class="c1">// dummy value of 0 so we can adjust for</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">l2</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>						<span class="c1">// different length of the two lists.</span>
            <span class="n">l2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
        <span class="n">sum</span> <span class="o">=</span> <span class="n">l1</span><span class="o">.</span><span class="na">val</span> <span class="o">+</span> <span class="n">l2</span><span class="o">.</span><span class="na">val</span> <span class="o">+</span> <span class="n">carry</span><span class="o">;</span>		<span class="c1">// Add the two vals and the carry.</span>
        <span class="n">carry</span> <span class="o">=</span> <span class="n">sum</span> <span class="o">&lt;</span> <span class="mi">10</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span><span class="o">;</span>			<span class="c1">// Record the carry for the next iteration</span>
        <span class="n">curr</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(</span><span class="n">sum</span> <span class="o">%</span> <span class="mi">10</span><span class="o">);</span>	<span class="c1">// next node's value is sum % 10.</span>
        <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>					<span class="c1">// advance current, l1 and l2.</span>
        <span class="n">l1</span> <span class="o">=</span> <span class="n">l1</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="n">l2</span> <span class="o">=</span> <span class="n">l2</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="o">}</span> <span class="k">while</span><span class="o">(</span><span class="n">l1</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">l2</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">carry</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span>							<span class="c1">// In the end, if carry is 1, it was from</span>
        <span class="n">curr</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(</span><span class="n">carry</span><span class="o">);</span>	<span class="c1">// from adding last terms, so make next node 1</span>

    <span class="k">return</span> <span class="n">dummy</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>						<span class="c1">// Return the actual head.</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="longest-substring-without-repeating-characters"><span class="me-2"><a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/">Longest Substring Without Repeating Characters</a><a name="longest-substring-without-repeating-characters"></a></span><a href="#longest-substring-without-repeating-characters" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">int</span> <span class="nf">lengthOfLongestSubstring</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">s</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
        <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>

    <span class="kt">int</span><span class="o">[]</span> <span class="n">hash</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">128</span><span class="o">];</span>					<span class="c1">// To store the occurence of characters</span>
    <span class="kt">int</span> <span class="n">maxLength</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">j</span><span class="o">++){</span>
        <span class="n">i</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">hash</span><span class="o">[</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">)],</span> <span class="n">i</span><span class="o">);</span>		<span class="c1">// Check the most recent index of character.</span>
        <span class="n">maxLength</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">maxLength</span><span class="o">,</span> <span class="n">j</span><span class="o">-</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">);</span>	<span class="c1">// That minus current pointer gives length</span>
        <span class="n">hash</span><span class="o">[</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">)]</span> <span class="o">=</span> <span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span>				<span class="c1">// Record the index of the next character.</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">maxLength</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="house-robber"><span class="me-2"><a href="https://leetcode.com/problems/house-robber">House Robber</a><a name="house-robber"></a></span><a href="#house-robber" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre><span class="cm">/*
The basic idea is that if you are robbing house i, the maximum loot may come from by robbing the i-2th house or by robbing the i-3th house. Therefore rob both and then find the path that gave the maximum profit.
Example: loot = [1,9,3,8,4,3,6,4,3,5,7,6]
Profit DP = [1,9,4,17,13,20,23,24,26,29,33,35]
Here,
	dp[2] = loot[2] + loot[1]
	dp[4] = loot[4] + max(dp[2], dp[1])
	dp[5] = loot[5] + max(dp[3], dp[2]) and so on.
In the end, just compare the last two elements to check which path gave us the maximum profit.
Some people might not prefer modifying the original nums array. In that case, you can initialize another dp array of same length, initialize the first two elements as dp[0] = nums[0] and dp[1] = nums[1] and dp[3] = nums[0] + nums[2] and then performing the same loop. In that case, you would be using O(n) space.
*/</span>
<span class="kd">public</span> <span class="kt">int</span> <span class="nf">rob</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">nums</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>			<span class="c1">// 3 Base Case</span>
        <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span>
        <span class="k">return</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
    <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">2</span><span class="o">)</span>
        <span class="k">return</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">],</span> <span class="n">nums</span><span class="o">[</span><span class="mi">1</span><span class="o">]);</span>
    <span class="k">else</span><span class="o">{</span>
        <span class="n">nums</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="mi">2</span><span class="o">];</span>				<span class="c1">// House 3 profit is rob House 1 and 3.</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
            <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">2</span><span class="o">],</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">3</span><span class="o">]);</span>
        <span class="k">return</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span><span class="o">],</span> <span class="n">nums</span><span class="o">[</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">2</span><span class="o">]);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="happy-number"><span class="me-2"><a href="https://leetcode.com/problems/happy-number/submissions/">Happy Number</a><a name="happy-number"></a></span><a href="#happy-number" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isHappy</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nf">isHappyConstantSpace</span><span class="o">(</span><span class="n">n</span><span class="o">);</span>		<span class="c1">// Much faster than set method</span>
        <span class="c1">//return isHappySet(n);</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">isHappyConstantSpace</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">){</span>
        <span class="kt">int</span> <span class="n">numSeenLessThan10</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>		<span class="c1">// If I see 10 single digits, then it means that I am</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">n</span> <span class="o">!=</span> <span class="mi">1</span><span class="o">){</span>					<span class="c1">// now starting to see repititions.</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="o">)</span>					<span class="c1">// Each time I see a num &lt; 10, increment the counter</span>
                <span class="n">numSeenLessThan10</span><span class="o">++;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">numSeenLessThan10</span> <span class="o">&gt;</span> <span class="mi">9</span><span class="o">)</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">getSquare</span><span class="o">(</span><span class="n">n</span><span class="o">);</span>			<span class="c1">// Get the total of square of its digits.</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>

<span class="cm">/*
The general idea is that the moment you see a repition, it can't be a happy number, so keep track of digit square obtained so far. If they hit 1, well and good, otherwise there will be some repition, so return false.
*/</span>
    <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">isHappySet</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">){</span>
        <span class="nc">HashSet</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">seen</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>		<span class="c1">// Keep track of numbers</span>
        <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">){</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">getSquare</span><span class="o">(</span><span class="n">n</span><span class="o">);</span>							<span class="c1">// Get the sum of digits square</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span>									<span class="c1">// If it's 1, it's a happy number</span>
                <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
            <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">seen</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">n</span><span class="o">))</span>					<span class="c1">// If it's a repition of something</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>							<span class="c1">// seen before, it's not a happy no.</span>
            <span class="k">else</span>
                <span class="n">seen</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">n</span><span class="o">);</span>							<span class="c1">// If not seen, add it.</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">int</span> <span class="nf">getSquare</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">){</span>		<span class="c1">// Add the squares of the digits.</span>
        <span class="kt">int</span> <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">n</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">digit</span> <span class="o">=</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">10</span><span class="o">;</span>
            <span class="n">total</span> <span class="o">+=</span> <span class="n">digit</span> <span class="o">*</span> <span class="n">digit</span><span class="o">;</span>
            <span class="n">n</span> <span class="o">/=</span> <span class="mi">10</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">total</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="remove-linked-list-elements"><span class="me-2"><a href="https://leetcode.com/problems/remove-linked-list-elements/">Remove Linked List Elements</a><a name="remove-linked-list-elements"></a></span><a href="#remove-linked-list-elements" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="nc">ListNode</span> <span class="nf">removeElements</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">,</span> <span class="kt">int</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">head</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">head</span><span class="o">.</span><span class="na">val</span> <span class="o">==</span> <span class="n">val</span><span class="o">)</span>				<span class="c1">// While head contains the val, skip</span>
        <span class="n">head</span> <span class="o">=</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>								<span class="c1">// the head</span>
    <span class="nc">ListNode</span> <span class="n">current</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">current</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">current</span><span class="o">.</span><span class="na">next</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>	<span class="c1">// While we have something to iterate</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">current</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">val</span> <span class="o">==</span> <span class="n">val</span><span class="o">)</span>					<span class="c1">// If current's val match, skip the</span>
            <span class="n">current</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>			<span class="c1">// next node.</span>
        <span class="k">else</span>
            <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>						<span class="c1">// Else advance to the next node.</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">head</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="count-primes"><span class="me-2"><a href="https://leetcode.com/problems/count-primes/submissions/">Count Primes</a><a name="count-primes"></a></span><a href="#count-primes" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">int</span> <span class="nf">countPrimes</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="o">)</span>
        <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>							<span class="c1">// No prime numbers for numbers &lt; 2</span>
    <span class="kt">boolean</span><span class="o">[]</span> <span class="n">store</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>		<span class="c1">// Using Sieve of Eratosthenes</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span> <span class="n">i</span><span class="o">*</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>			<span class="c1">// Start from i = 2 to sqrt(n)</span>
        <span class="k">if</span> <span class="o">(!</span><span class="n">store</span><span class="o">[</span><span class="n">i</span><span class="o">])</span>						<span class="c1">// If store[i] = false, then mark all its</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">*</span><span class="n">i</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">j</span> <span class="o">+=</span> <span class="n">i</span><span class="o">)</span><span class="c1">// multiples in the store as true</span>
                <span class="n">store</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>			<span class="c1">// True = not a prime, false = prime</span>
    <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>				<span class="c1">// Loop through the array, count</span>
        <span class="k">if</span> <span class="o">(!</span><span class="n">store</span><span class="o">[</span><span class="n">i</span><span class="o">])</span>
            <span class="n">count</span><span class="o">++;</span>
    <span class="k">return</span> <span class="n">count</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="isomorphic-strings"><span class="me-2"><a href="https://leetcode.com/problems/isomorphic-strings/submissions/">Isomorphic Strings</a><a name="isomorphic-strings"></a></span><a href="#isomorphic-strings" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><pre><code class="language-Java">public boolean isIsomorphic(String s, String t) {
    if (s.length() != t.length())			// Can't be isomorphic is string lengths do not
        return false;						// match
    char[] hashS = new char[128];			// To store String s' match
    char[] hashT = new char[128];			// To store String t's match
    for (int i = 0; i &lt; s.length(); i++){
        char charS = s.charAt(i), charT = t.charAt(i);
        if (hashS[charS] != hashT[charT])	// If the values at respective characters index
            return false;					// do not match, return false
        hashS[charS] = (char)(i+1);			// Otherwise, mark those index with the same
        hashT[charT] = (char)(i+1);			// arbitrary value. I chose a simple (i+1) to
    }										// to mark both the hash with the same value.
    return true;							// Everything worked out, return true;
}
</code></pre><h3 id="reverse-linkedlist"><span class="me-2"><a href="https://leetcode.com/problems/reverse-linked-list/solution/">Reverse LinkedList</a><a name="reverse-linkedlist"></a></span><a href="#reverse-linkedlist" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre><td class="rouge-code"><pre><span class="c1">// Recursive</span>
<span class="kd">public</span> <span class="nc">ListNode</span> <span class="nf">reverseList</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>	<span class="c1">// Very tricky. Refer to the demo below</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">head</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
        <span class="k">return</span> <span class="n">head</span><span class="o">;</span>
    <span class="nc">ListNode</span> <span class="n">node</span> <span class="o">=</span> <span class="n">reverseList</span><span class="o">(</span><span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">);</span>
    <span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
    <span class="n">head</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="k">return</span> <span class="n">node</span><span class="o">;</span>
<span class="o">}</span>

<span class="c1">//Iterative</span>
<span class="kd">public</span> <span class="nc">ListNode</span> <span class="nf">reverseList</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">head</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
        <span class="k">return</span> <span class="n">head</span><span class="o">;</span>						<span class="c1">// No point in reversing empty or 1-sized list</span>
    <span class="nc">ListNode</span> <span class="n">curr</span> <span class="o">=</span> <span class="n">head</span><span class="o">,</span> <span class="n">prev</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="nc">ListNode</span> <span class="n">nextNode</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">curr</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>					<span class="c1">// While we haven't reached the tail</span>
        <span class="n">nextNode</span> <span class="o">=</span> <span class="n">curr</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>				<span class="c1">// Store the next node</span>
        <span class="n">curr</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">prev</span><span class="o">;</span>					<span class="c1">// Current's next becomes it's previous</span>
        <span class="n">prev</span> <span class="o">=</span> <span class="n">curr</span><span class="o">;</span>						<span class="c1">// Advance previous to current.</span>
        <span class="n">curr</span> <span class="o">=</span> <span class="n">nextNode</span><span class="o">;</span>					<span class="c1">// Make current the actual next node</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">prev</span><span class="o">;</span>							<span class="c1">// Current is at null, so it's previous is the</span>
<span class="o">}</span>											<span class="c1">// new head.</span>
</pre></table></code></div></div><p><a href="https://raw.githubusercontent.com/SamirPaulb/assets/main/reverse-a-linked-list-image.webp" class="popup img-link shimmer"><img src="https://raw.githubusercontent.com/SamirPaulb/assets/main/reverse-a-linked-list-image.webp" alt="reverse Linked list" loading="lazy"></a></p><h3 id="contains-duplicate"><span class="me-2"><a href="https://leetcode.com/problems/contains-duplicate/submissions/">Contains Duplicate</a><a name="contains-duplicate"></a></span><a href="#contains-duplicate" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">containsDuplicate</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="o">)</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>							<span class="c1">// There can't be any duplicates.</span>
    <span class="nc">HashSet</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">store</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>	<span class="c1">// Store unique values.</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="nl">n:</span> <span class="n">nums</span><span class="o">){</span>
        <span class="k">if</span> <span class="o">(!</span><span class="n">store</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">n</span><span class="o">))</span>						<span class="c1">// Add func returns true if n was'nt present,</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>						<span class="c1">// false if duplicate. Therefore if it was a</span>
    <span class="o">}</span>											<span class="c1">// duplicate, return true.</span>
    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>								<span class="c1">// No duplicates, so return false</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="contains-duplicate-ii"><span class="me-2"><a href="https://leetcode.com/problems/contains-duplicate-ii/">Contains Duplicate II</a><a name="contains-duplicate-ii"></a></span><a href="#contains-duplicate-ii" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">containsNearbyDuplicate</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="o">)</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="nc">HashSet</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">store</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>	<span class="c1">// Use a rotating window of size k</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">right</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">){</span>				<span class="c1">// While we haven't processed everything</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">store</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">right</span><span class="o">]))</span>		<span class="c1">// If our current window contains duplicate</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="n">store</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">right</span><span class="o">]);</span>					<span class="c1">// No duplicates in the window</span>
        <span class="n">right</span><span class="o">++;</span>								<span class="c1">// Increase right to visit the new element</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">&gt;</span> <span class="n">k</span><span class="o">){</span>					<span class="c1">// If window becomes &gt; k</span>
            <span class="n">store</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">left</span><span class="o">]);</span>			<span class="c1">// remove the number on the left side of</span>
            <span class="n">left</span><span class="o">++;</span>								<span class="c1">// the window and increase the left counter</span>
        <span class="o">}</span>										<span class="c1">// for new window from the next index</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>								<span class="c1">// No duplicates found in any window.</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="implement-stack-using-queues"><span class="me-2"><a href="https://leetcode.com/problems/implement-stack-using-queues/">Implement Stack Using Queues</a><a name="implement-stack-using-queues"></a></span><a href="#implement-stack-using-queues" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">MyStack</span> <span class="o">{</span>
    <span class="nc">Deque</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">stack</span><span class="o">;</span>
    <span class="cm">/** Initialize your data structure here. */</span>
    <span class="kd">public</span> <span class="nf">MyStack</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayDeque</span><span class="o">&lt;&gt;();</span>
    <span class="o">}</span>

    <span class="cm">/** Push element x onto stack. */</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">push</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">stack</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">x</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="cm">/** Removes the element on top of the stack and returns that element. */</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">pop</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">stack</span><span class="o">.</span><span class="na">removeLast</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="cm">/** Get the top element. */</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">top</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">stack</span><span class="o">.</span><span class="na">peekLast</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="cm">/** Returns whether the stack is empty. */</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">empty</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">stack</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="invert-binary-tree"><span class="me-2"><a href="https://leetcode.com/problems/invert-binary-tree/">Invert Binary Tree</a><a name="invert-binary-tree"></a></span><a href="#invert-binary-tree" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="nc">TreeNode</span> <span class="nf">invertTree</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="nc">TreeNode</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>		<span class="c1">// Swap the left and right nodes</span>
    <span class="n">root</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
    <span class="n">root</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>
    <span class="n">invertTree</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>			<span class="c1">// Then swap the subsequent trees of those nodes.</span>
    <span class="n">invertTree</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">root</span><span class="o">;</span>					<span class="c1">// Return the original root.</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="fibonacci-number"><span class="me-2"><a href="https://leetcode.com/problems/fibonacci-number/">Fibonacci Number</a><a name="fibonacci-number"></a></span><a href="#fibonacci-number" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="c1">// Iterative</span>
<span class="kd">public</span> <span class="kt">int</span> <span class="nf">fib</span><span class="o">(</span><span class="kt">int</span> <span class="no">N</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="no">N</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="o">)</span>						<span class="c1">// fib(0) = 0; fib(1) = 1</span>
        <span class="k">return</span> <span class="no">N</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">f0</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">f1</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span> <span class="n">fn</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
        <span class="n">fn</span> <span class="o">=</span> <span class="n">f0</span> <span class="o">+</span> <span class="n">f1</span><span class="o">;</span>				<span class="c1">// fib(n) = fib(n-1) + fib(n-2)</span>
        <span class="n">f0</span> <span class="o">=</span> <span class="n">f1</span><span class="o">;</span>					<span class="c1">// f0 becomes f1</span>
        <span class="n">f1</span> <span class="o">=</span> <span class="n">fn</span><span class="o">;</span>					<span class="c1">// f1 becomes fn</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">f1</span><span class="o">;</span>
<span class="o">}</span>

<span class="c1">// Dynamic Programming</span>
<span class="kd">private</span> <span class="kt">int</span> <span class="nf">fibDP</span><span class="o">(</span><span class="kt">int</span> <span class="no">N</span><span class="o">){</span>
    <span class="k">if</span> <span class="o">(</span><span class="no">N</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="o">)</span>
        <span class="k">return</span> <span class="no">N</span><span class="o">;</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="no">N</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>		<span class="c1">// To store intermediate result</span>
    <span class="n">dp</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>						<span class="c1">// fib(0) = 0; fib(1) = 1</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
        <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">]+</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">2</span><span class="o">];</span>	<span class="c1">// fib(i) = fib(i-1) + fib(i-2)</span>
    <span class="k">return</span> <span class="n">dp</span><span class="o">[</span><span class="no">N</span><span class="o">];</span>					<span class="c1">// Return the last number in the array</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="kth-largest-element"><span class="me-2"><a href="https://leetcode.com/problems/kth-largest-element-in-an-array/">kth Largest Element</a><a name="kth-largest-element"></a></span><a href="#kth-largest-element" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ol><li>The minheap algorithm has $O(n lg n) $ complexity and $O(1)$ space. The idea here is that we use a minheap to keep only the k greatest elements. If size becomes more than k, we remove the smallest element at the top of the heap. Thereby, at the end, our kth largest element will be at the top.<li>QuickSelect Algorithm performs in $O(n)$ best case, $O(n^2)$ worst case when the pivot chosen is always the largest, so we use a random pivot.</ol><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
</pre><td class="rouge-code"><pre><span class="c1">// MinHeap Algorithm</span>
<span class="kd">public</span> <span class="kt">int</span> <span class="nf">kthLargest</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">){</span>
    <span class="nc">PriorityQueue</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">q</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PriorityQueue</span><span class="o">&lt;&gt;((</span><span class="n">n1</span><span class="o">,</span><span class="n">n2</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">n1</span> <span class="o">-</span> <span class="n">n2</span><span class="o">);</span>	<span class="c1">// Initialize minheap</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="nl">n:</span> <span class="n">nums</span><span class="o">){</span>
        <span class="n">q</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">n</span><span class="o">);</span>				<span class="c1">// Add number one by one</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">q</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&gt;</span> <span class="n">k</span><span class="o">)</span>		<span class="c1">// If size is greater than k</span>
            <span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>			<span class="c1">// Remove the topmost element</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>			<span class="c1">// The topmost element is our answer</span>
<span class="o">}</span>

<span class="c1">// QuickSelect Algorithm - Hoare's Partition Scheme</span>

<span class="kd">private</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">;</span>

<span class="kd">public</span> <span class="kt">int</span> <span class="nf">kthLargest</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">){</span>
	<span class="n">arr</span> <span class="o">=</span> <span class="n">nums</span><span class="o">;</span>
	<span class="k">return</span> <span class="nf">quickselect</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="n">k</span><span class="o">);</span><span class="c1">// kth largest is (n-k)th largest</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kt">int</span> <span class="nf">quickselect</span><span class="o">(</span><span class="kt">int</span> <span class="n">left</span><span class="o">,</span> <span class="kt">int</span> <span class="n">right</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">){</span>
	<span class="k">if</span> <span class="o">(</span><span class="n">left</span> <span class="o">==</span> <span class="n">right</span><span class="o">)</span>					<span class="c1">// Array contains only 1 element, that's the answer</span>
  		<span class="k">return</span> <span class="n">arr</span><span class="o">[</span><span class="n">left</span><span class="o">];</span>
	<span class="nc">Random</span> <span class="n">rand</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Random</span><span class="o">();</span>				<span class="c1">// Choose a random pivot between left and right</span>
	<span class="kt">int</span> <span class="n">pivotIndex</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="n">rand</span><span class="o">.</span><span class="na">nextInt</span><span class="o">(</span><span class="n">right</span><span class="o">-</span><span class="n">left</span><span class="o">);</span>	<span class="c1">// but not left</span>
	<span class="n">pivotIndex</span> <span class="o">=</span> <span class="n">partition</span><span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">,</span> <span class="n">pivotIndex</span><span class="o">);</span>	<span class="c1">// Partition, and find it's correct index</span>
	<span class="k">if</span> <span class="o">(</span><span class="n">k</span> <span class="o">==</span> <span class="n">pivotIndex</span><span class="o">)</span>					<span class="c1">// That index is equal to kth statistic</span>
  		<span class="k">return</span> <span class="n">arr</span><span class="o">[</span><span class="n">pivotIndex</span><span class="o">];</span>
	<span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">k</span> <span class="o">&lt;</span> <span class="n">pivotIndex</span><span class="o">)</span>			<span class="c1">// If it's less than the index, our ans lies in the</span>
  		<span class="k">return</span> <span class="nf">quickselect</span><span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">pivotIndex</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="n">k</span><span class="o">);</span>	<span class="c1">// left side</span>
	<span class="k">else</span>
  		<span class="k">return</span> <span class="nf">quickselect</span><span class="o">(</span><span class="n">pivotIndex</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">right</span><span class="o">,</span> <span class="n">k</span><span class="o">);</span>	<span class="c1">// Otherwise, it's on the right side.</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kt">int</span> <span class="nf">partition</span><span class="o">(</span><span class="kt">int</span> <span class="n">left</span><span class="o">,</span> <span class="kt">int</span> <span class="n">right</span><span class="o">,</span> <span class="kt">int</span> <span class="n">pivotIndex</span><span class="o">){</span>
	<span class="kt">int</span> <span class="n">pivot</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">pivotIndex</span><span class="o">];</span>			<span class="c1">// Partition element</span>
	<span class="n">swap</span><span class="o">(</span><span class="n">pivotIndex</span><span class="o">,</span> <span class="n">right</span><span class="o">);</span>				<span class="c1">// Move that element to the end</span>
	<span class="kt">int</span> <span class="n">wall</span> <span class="o">=</span> <span class="n">left</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>					<span class="c1">// wall is initially before everything</span>
	<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">left</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
  		<span class="k">if</span> <span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">pivot</span><span class="o">)</span>				<span class="c1">// If the current element is &lt; than the pivot, then</span>
    		<span class="n">swap</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="o">++</span><span class="n">wall</span><span class="o">);</span>			<span class="c1">// we need to swap it with the element next to wall.</span>
	<span class="o">}</span>
	<span class="n">swap</span><span class="o">(</span><span class="n">right</span><span class="o">,</span> <span class="o">++</span><span class="n">wall</span><span class="o">);</span>					<span class="c1">// Lastly, swap the element at wall and the end.</span>
	<span class="k">return</span> <span class="n">wall</span><span class="o">;</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kt">void</span> <span class="nf">swap</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">j</span><span class="o">){</span>
	<span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
	<span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
	<span class="n">arr</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="power-of-two"><span class="me-2"><a href="https://leetcode.com/problems/power-of-two/">Power Of Two</a><a name="power-of-two"></a></span><a href="#power-of-two" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isPowerOfTwo</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="o">)</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>		<span class="c1">// n &lt; 0 cannot be powers of 2</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="o">){</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span>		<span class="c1">// If n is odd, it can't be a power of 2.</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>			<span class="c1">// It is a multiple of 2, so divide it by 2.</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>			<span class="c1">// n came out to be 1 which is a power of 2, so return true.</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="valid-sudoku"><span class="me-2"><a href="https://leetcode.com/problems/valid-sudoku/">Valid Sudoku</a><a name="valid-sudoku"></a></span><a href="#valid-sudoku" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
</pre><td class="rouge-code"><pre><span class="kd">private</span> <span class="kt">char</span><span class="o">[][]</span> <span class="n">board</span><span class="o">;</span>
<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isValidSudoku</span><span class="o">(</span><span class="kt">char</span><span class="o">[][]</span> <span class="n">board</span><span class="o">){</span>
<span class="k">this</span><span class="o">.</span><span class="na">board</span> <span class="o">=</span> <span class="n">board</span><span class="o">;</span>
<span class="k">return</span> <span class="nf">rowCheck</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">colCheck</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">boxCheck</span><span class="o">();</span>	<span class="c1">// Check row first, then column and at</span>
<span class="o">}</span>												<span class="c1">// last, boxes because they are time</span>
                                                <span class="c1">// consuming.</span>
  
<span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">onePassCheck</span><span class="o">(){</span>
  <span class="nc">HashSet</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;[]</span> <span class="n">rows</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">[</span><span class="mi">9</span><span class="o">];</span>		<span class="c1">// 1 HashSet for each row</span>
  <span class="nc">HashSet</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;[]</span> <span class="n">columns</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">[</span><span class="mi">9</span><span class="o">];</span>	<span class="c1">// 1 HashSet for each column</span>
  <span class="nc">HashSet</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;[]</span> <span class="n">boxes</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">[</span><span class="mi">9</span><span class="o">];</span>	<span class="c1">// 1 HashSet for each box.</span>

  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">9</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
      <span class="n">rows</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>
      <span class="n">columns</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>
      <span class="n">boxes</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>
  <span class="o">}</span>

  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">9</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
      <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">9</span><span class="o">;</span> <span class="n">j</span><span class="o">++){</span>
          <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)(</span><span class="n">board</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]);</span>
          <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">2</span><span class="o">){</span>							<span class="c1">// -2 = '.'		</span>
              <span class="kt">int</span> <span class="n">boxIndex</span> <span class="o">=</span> <span class="o">(</span><span class="n">i</span><span class="o">/</span><span class="mi">3</span><span class="o">)</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">+</span> <span class="n">j</span><span class="o">/</span><span class="mi">3</span><span class="o">;</span>	<span class="c1">// Calculate which box we are in.</span>
              <span class="k">if</span> <span class="o">(!</span><span class="n">rows</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">add</span><span class="o">(</span><span class="n">n</span><span class="o">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">columns</span><span class="o">[</span><span class="n">j</span><span class="o">].</span><span class="na">add</span><span class="o">(</span><span class="n">n</span><span class="o">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">boxes</span><span class="o">[</span><span class="n">boxIndex</span><span class="o">].</span><span class="na">add</span><span class="o">(</span><span class="n">n</span><span class="o">))</span>
                  <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>					<span class="c1">// If the row set or the column set or the</span>
          <span class="o">}</span>										<span class="c1">// box set contains that val, return false.</span>
      <span class="o">}</span>
  <span class="o">}</span>

  <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">rowCheck</span><span class="o">(){</span>						<span class="c1">// Horizontal check</span>
    <span class="kt">boolean</span><span class="o">[]</span> <span class="n">arr</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">char</span><span class="o">[]</span> <span class="nl">row:</span> <span class="n">board</span><span class="o">){</span>
      <span class="n">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="mi">9</span><span class="o">];</span>
      <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="nl">c:</span> <span class="n">row</span><span class="o">){</span>
        <span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="n">c</span><span class="o">-</span><span class="sc">'0'</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">val</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">2</span><span class="o">){</span>								<span class="c1">// val = -2 means '.' in the board</span>
          <span class="k">if</span> <span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">val</span><span class="o">-</span><span class="mi">1</span><span class="o">])</span>							<span class="c1">// If val already seen, invalid sudoku</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
          <span class="n">arr</span><span class="o">[</span><span class="n">val</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>						<span class="c1">// else, Mark that index as seen.</span>
        <span class="o">}</span>
      <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">colCheck</span><span class="o">(){</span>						<span class="c1">// Vertical Check.</span>
    <span class="kt">boolean</span><span class="o">[]</span> <span class="n">arr</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">col</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">col</span> <span class="o">&lt;</span> <span class="n">board</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">col</span><span class="o">++){</span>
      <span class="n">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="mi">9</span><span class="o">];</span>
      <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">row</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">row</span> <span class="o">&lt;</span> <span class="n">board</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">;</span> <span class="n">row</span><span class="o">++){</span>
        <span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="n">board</span><span class="o">[</span><span class="n">row</span><span class="o">][</span><span class="n">col</span><span class="o">]-</span><span class="sc">'0'</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">val</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">2</span><span class="o">){</span>
          <span class="k">if</span> <span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">val</span><span class="o">-</span><span class="mi">1</span><span class="o">])</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
          <span class="n">arr</span><span class="o">[</span><span class="n">val</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
      <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">boxCheck</span><span class="o">(){</span>					<span class="c1">// For the 9 sub boxes, let the single</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">9</span><span class="o">;</span> <span class="n">i</span><span class="o">+=</span><span class="mi">3</span><span class="o">){</span>				<span class="c1">// box checker check it's validity.</span>
      <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">9</span><span class="o">;</span> <span class="n">j</span><span class="o">+=</span><span class="mi">3</span><span class="o">)</span>				<span class="c1">// If any of the subbox was invalid,</span>
        <span class="k">if</span> <span class="o">(!</span><span class="n">singleBoxCheck</span><span class="o">(</span><span class="n">i</span><span class="o">,</span><span class="n">j</span><span class="o">))</span>				<span class="c1">// we abort and return false.</span>
          <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">singleBoxCheck</span><span class="o">(</span><span class="kt">int</span> <span class="n">topRightRow</span><span class="o">,</span> <span class="kt">int</span> <span class="n">topRightCol</span><span class="o">){</span>
    <span class="kt">boolean</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="mi">9</span><span class="o">];</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>				<span class="c1">// Each sub box has 3 rows and 3 columns</span>
      <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="o">;</span> <span class="n">j</span><span class="o">++){</span>
        <span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="n">board</span><span class="o">[</span><span class="n">topRightRow</span><span class="o">+</span><span class="n">i</span><span class="o">][</span><span class="n">topRightCol</span><span class="o">+</span><span class="n">j</span><span class="o">]-</span><span class="sc">'0'</span><span class="o">;</span>	<span class="c1">// This gives us the value at </span>
        <span class="k">if</span> <span class="o">(</span><span class="n">val</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">2</span><span class="o">){</span>							<span class="c1">// each cell in the sub box and we fill the</span>
          <span class="k">if</span> <span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">val</span><span class="o">-</span><span class="mi">1</span><span class="o">])</span>						<span class="c1">// arr with all values that are seen.</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>						<span class="c1">// If seen twice, return false;</span>
          <span class="n">arr</span><span class="o">[</span><span class="n">val</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
      <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="implement-queue-using-stack"><span class="me-2"><a href="https://leetcode.com/problems/implement-queue-using-stacks/submissions/">Implement Queue Using Stack</a><a name="implement-queue-using-stack"></a></span><a href="#implement-queue-using-stack" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre><td class="rouge-code"><pre><span class="cm">/*
Since we reverse stack1 into stack2, stack2 is basically our queue, so if stack2 isn't empty, then the topmost element is what we need when we pop or peek. If it is empty, then again fill it with whatever's there is stack1, and it again becomes the correct queue.
*/</span>
<span class="nc">Stack</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">stack1</span><span class="o">;</span>
<span class="nc">Stack</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">stack2</span><span class="o">;</span>

<span class="kd">public</span> <span class="nf">MyQueue</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">stack1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Stack</span><span class="o">&lt;&gt;();</span>
    <span class="n">stack2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Stack</span><span class="o">&lt;&gt;();</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kt">void</span> <span class="nf">push</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">stack1</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">x</span><span class="o">);</span>			<span class="c1">// Push onto stack1</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kt">int</span> <span class="nf">pop</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">peek</span><span class="o">();</span>					<span class="c1">// First call the peek function, to make sure stack 2 isn't</span>
    <span class="k">return</span> <span class="n">stack2</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>	<span class="c1">// empty. Then, the topmost element of stack2 is what we want</span>
<span class="o">}</span>

<span class="cm">/** Get the front element. */</span>
<span class="kd">public</span> <span class="kt">int</span> <span class="nf">peek</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">stack2</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()){</span>			
        <span class="k">while</span> <span class="o">(!</span><span class="n">stack1</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span>
            <span class="n">stack2</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">stack1</span><span class="o">.</span><span class="na">pop</span><span class="o">());</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">stack2</span><span class="o">.</span><span class="na">peek</span><span class="o">();</span>	<span class="c1">// stack2 is basically the queue, so return whatever's on the top</span>
<span class="o">}</span>

<span class="cm">/** Returns whether the queue is empty. */</span>
<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">empty</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">stack1</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">stack2</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">();</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="palindrome-linkedlist"><span class="me-2"><a href="https://leetcode.com/problems/palindrome-linked-list/submissions/">Palindrome LinkedList</a><a name="palindrome-linkedlist"></a></span><a href="#palindrome-linkedlist" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><pre><code class="language-JAVA">public boolean isPalindrome(ListNode head) {
    if (head == null || head.next == null)		// Size 0 or 1 list, must be unique.
        return true;
    if (head.next.next == null)					// Size 2 list, compare the head and tail
        return head.val == head.next.val;		// values

    ListNode middleNode = head;					// Standard Rabbit-Tortoise pointers.
    ListNode fastPointer = head;				// Fast pointer jumps twice so by the time
												// it reaches the end of the list, middlenode
    ListNode curr = head;						// is at the middle of the linkedlist.
    ListNode prev = null;
    ListNode nextNode;							// These three nodes are for reversing the 
												// first half of the list
    while (fastPointer != null &amp;&amp; fastPointer.next != null){
        middleNode = middleNode.next;			// Advance middle once, fastpointer twice
        fastPointer = fastPointer.next.next;

        nextNode = curr.next;					// Reverse the curr node, but first store the
        curr.next = prev;						// next newNode. By doing this, we would have
        prev = curr;							// reversed exactly half of the list because
        curr = nextNode;						// fastpointer advacnes at double the speed.
    }

    if (fastPointer != null)					// If faspointer isn't null, then we have an
        middleNode = middleNode.next;			// odd length list, so advance middle once,
												// List looks like 1-&gt;2-&gt;3-&gt;2-&gt;1 instead of
    while (middleNode != null){					// 1-&gt;2-&gt;3-&gt;3-&gt;2-&gt;1
        if (middleNode.val != prev.val)			// While middle isn't null, check middlenode
            return false;						// val and prev val. Prev is basically the
        middleNode = middleNode.next;			// the point where the list reverses.
        prev = prev.next;						// Advance middle and next.
    }
    return true;								// Values matched, so return true.
}												// Reversed list looks like this:
												// 1&lt;-2&lt;-3&lt;-prev middle-&gt;3-&gt;2-&gt;1 in even len
												// 1&lt;-2&lt;-prev middle-&gt;2-&gt;1 in odd lengths.
</code></pre><h3 id="delete-node-in-a-linked-list"><span class="me-2"><a href="https://leetcode.com/problems/delete-node-in-a-linked-list/submissions/">Delete Node in a Linked List</a><a name="delete-node-in-a-linked-list"></a></span><a href="#delete-node-in-a-linked-list" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">void</span> <span class="nf">deleteNode</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">node</span><span class="o">.</span><span class="na">val</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">val</span><span class="o">;</span>		<span class="c1">// Node's value becomes its next node's value</span>
    <span class="n">node</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>  	<span class="c1">// Node's next is it's next's next.</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="is-anagram"><span class="me-2"><a href="https://leetcode.com/problems/valid-anagram/submissions/">Is Anagram</a><a name="is-anagram"></a></span><a href="#is-anagram" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isAnagram</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="nc">String</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">!=</span> <span class="n">t</span><span class="o">.</span><span class="na">length</span><span class="o">())</span>			<span class="c1">// Can't be anagram if size aren't the same</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">store</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">26</span><span class="o">];</span>				<span class="c1">// Acts like a hashmap</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span>	<span class="c1">// Increment the count by 1 in the store for the</span>
        <span class="n">store</span><span class="o">[</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)-</span><span class="sc">'a'</span><span class="o">]++;</span>			<span class="c1">// index = position of char in the alphabet</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">t</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span><span class="o">++){</span>	<span class="c1">// Loop throught the second string, decrement</span>
        <span class="k">if</span> <span class="o">(--</span><span class="n">store</span><span class="o">[</span><span class="n">t</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)-</span><span class="sc">'a'</span><span class="o">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span>	<span class="c1">// count of each character in store by 1, but if</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>					<span class="c1">// it goes below 0, then it means that character</span>
    <span class="o">}</span>										<span class="c1">// occurred more than it did in s. So false.</span>
    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>							<span class="c1">// Everything matched, so return true.</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="binary-tree-paths"><span class="me-2"><a href="https://leetcode.com/problems/binary-tree-paths/">Binary Tree Paths</a><a name="binary-tree-paths"></a></span><a href="#binary-tree-paths" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">paths</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
<span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="nf">binaryTreePaths</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>					<span class="c1">// No paths</span>
        <span class="k">return</span> <span class="n">paths</span><span class="o">;</span>
    <span class="nc">String</span> <span class="n">rootval</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="na">val</span> <span class="o">+</span> <span class="s">""</span><span class="o">;</span>		<span class="c1">// Converting int to string.</span>
    <span class="n">traverse</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">rootval</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">paths</span><span class="o">;</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kt">void</span> <span class="nf">traverse</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">,</span> <span class="nc">String</span> <span class="n">s</span><span class="o">){</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">root</span><span class="o">.</span><span class="na">right</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>		<span class="c1">// It's a leaf, and you found a path</span>
        <span class="n">paths</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>									<span class="c1">// so add it to the list</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>								<span class="c1">// Left side is traversable, so</span>
        <span class="n">traverse</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">s</span> <span class="o">+</span> <span class="s">"-&gt;"</span> <span class="o">+</span> <span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>	<span class="c1">// visit it and record its value.</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>								<span class="c1">// Same as above, but for right side.</span>
        <span class="n">traverse</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">s</span> <span class="o">+</span> <span class="s">"-&gt;"</span> <span class="o">+</span> <span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="add-digits"><span class="me-2"><a href="https://leetcode.com/problems/add-digits/">Add Digits</a><a name="add-digits"></a></span><a href="#add-digits" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre><td class="rouge-code"><pre><span class="kd">private</span> <span class="kt">int</span> <span class="nf">constantTime</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">){</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="o">)</span>
        <span class="k">return</span> <span class="n">n</span><span class="o">;</span>			<span class="c1">// Already a single digit</span>
    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">9</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">result</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>		<span class="c1">// If perfectly divisible by 9, then sum will be 9.</span>
        <span class="k">return</span> <span class="mi">9</span><span class="o">;</span>
    <span class="k">return</span> <span class="n">result</span><span class="o">;</span>			<span class="c1">// Otherwise, the result is going to be n % 9.</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kt">int</span> <span class="nf">iterative</span><span class="o">(</span><span class="kt">int</span> <span class="n">num</span><span class="o">){</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">num</span> <span class="o">&gt;</span> <span class="mi">9</span><span class="o">){</span>				<span class="c1">// While number isn't between 2-9</span>
        <span class="n">num</span> <span class="o">=</span> <span class="n">sumOfDigits</span><span class="o">(</span><span class="n">num</span><span class="o">);</span>		<span class="c1">// make num = sum of it's digits.</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">num</span><span class="o">;</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kt">int</span> <span class="nf">sumOfDigits</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">){</span>		<span class="c1">// Standard method to add the digits of a number.</span>
    <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">n</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">){</span>
        <span class="n">sum</span> <span class="o">+=</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">10</span><span class="o">;</span>				<span class="c1">// Extract the last digit, add it to sum.</span>
        <span class="n">n</span> <span class="o">/=</span> <span class="mi">10</span><span class="o">;</span>					<span class="c1">// Divide the num by 10.</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">sum</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="largest-perimeter-triangle"><span class="me-2"><a href="https://leetcode.com/problems/largest-perimeter-triangle/">Largest Perimeter Triangle</a><a name="largest-perimeter-triangle"></a></span><a href="#largest-perimeter-triangle" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">int</span> <span class="nf">largestPerimeter</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="no">A</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="no">A</span><span class="o">);</span>							<span class="c1">// Sort so the largest sides are at the end.</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="no">A</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">3</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="o">--</span><span class="n">i</span><span class="o">)</span>	<span class="c1">// Triangle inequality Theorem : a + b &gt; c</span>
        <span class="k">if</span> <span class="o">(</span><span class="no">A</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="no">A</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">]</span> <span class="o">&gt;</span> <span class="no">A</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="o">])</span>			<span class="c1">// If sum of last two is greater than the last</span>
            <span class="k">return</span> <span class="no">A</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="no">A</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="no">A</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="o">];</span>	<span class="c1">// we found out max perimeter, otherwise</span>
    <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>								<span class="c1">// decrease i by i, then check the next three</span>
<span class="o">}</span>											<span class="c1">// triplets</span>
											<span class="c1">// In the end if nothing works out, we return 0.</span>
</pre></table></code></div></div><h3 id="ugly-number"><span class="me-2"><a href="https://leetcode.com/problems/ugly-number/submissions/">Ugly Number</a><a name="ugly-number"></a></span><a href="#ugly-number" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isUgly</span><span class="o">(</span><span class="kt">int</span> <span class="n">num</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">num</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="o">)</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>		<span class="c1">// Negative numbers are automatically non ugly</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">num</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>	<span class="c1">// Keep dividing number by 2 till it is divisible</span>
        <span class="n">num</span> <span class="o">/=</span> <span class="mi">2</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">num</span> <span class="o">%</span> <span class="mi">3</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>	<span class="c1">// Keep dividing by 3</span>
        <span class="n">num</span> <span class="o">/=</span> <span class="mi">3</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">num</span> <span class="o">%</span> <span class="mi">5</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>	<span class="c1">// and 5</span>
        <span class="n">num</span> <span class="o">/=</span> <span class="mi">5</span><span class="o">;</span>
    <span class="k">return</span> <span class="n">num</span> <span class="o">==</span> <span class="mi">1</span><span class="o">;</span>		<span class="c1">// If num isn't 1, that means that there are other prime factors</span>
<span class="o">}</span>							<span class="c1">// except 2,3 and 5.</span>
</pre></table></code></div></div><h3 id="missing-number"><span class="me-2"><a href="https://leetcode.com/problems/missing-number/">Missing Number</a><a name="missing-number"></a></span><a href="#missing-number" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">int</span> <span class="nf">missingNumber</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>			<span class="c1">// Since it's given that the array contains</span>
    <span class="kt">int</span> <span class="n">nsum</span> <span class="o">=</span> <span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">*(</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">+</span><span class="mi">1</span><span class="o">))/</span><span class="mi">2</span><span class="o">;</span>	<span class="c1">// all numbers from 0-n, we use the formula</span>
    <span class="kt">int</span> <span class="n">arraySum</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>						<span class="c1">// to compute sum of n numbers.</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>		<span class="c1">// Then we loop through the array to compute</span>
        <span class="n">arraySum</span> <span class="o">+=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>					<span class="c1">// the sum of the array.</span>
    <span class="k">return</span> <span class="n">nsum</span> <span class="o">-</span> <span class="n">arraySum</span><span class="o">;</span>						<span class="c1">// Subtract the array sum from the required</span>
<span class="o">}</span>												<span class="c1">// sum, and that gives us the missing number</span>
</pre></table></code></div></div><h3 id="is-bad-version"><span class="me-2"><a href="https://leetcode.com/problems/first-bad-version/submissions/">Is Bad Version</a><a name="is-bad-version"></a></span><a href="#is-bad-version" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">int</span> <span class="nf">firstBadVersion</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>		<span class="c1">// Basic Binary Search Algorithm</span>
    <span class="kt">int</span> <span class="n">low</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span> <span class="n">high</span> <span class="o">=</span> <span class="n">n</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">mid</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">low</span> <span class="o">&lt;</span> <span class="n">high</span><span class="o">){</span>
        <span class="n">mid</span> <span class="o">=</span> <span class="n">low</span> <span class="o">+</span> <span class="o">(</span><span class="n">high</span> <span class="o">-</span> <span class="n">low</span><span class="o">)/</span><span class="mi">2</span><span class="o">;</span>		<span class="c1">// high - low to prefent integer overflow.</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">isBadVersion</span><span class="o">(</span><span class="n">mid</span><span class="o">))</span>			<span class="c1">// if the model at mid was bad version, then we</span>
            <span class="n">high</span> <span class="o">=</span> <span class="n">mid</span><span class="o">;</span>					<span class="c1">// could possibly have a bad version before it</span>
        <span class="k">else</span>
            <span class="n">low</span> <span class="o">=</span> <span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span>				<span class="c1">// If it wasn't, then our first bad version lies</span>
    <span class="o">}</span>									<span class="c1">// beyond the middle element.</span>
    <span class="k">return</span> <span class="n">low</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="move-zeroes"><span class="me-2"><a href="https://leetcode.com/problems/move-zeroes/solution/">Move Zeroes</a><a name="move-zeroes"></a></span><a href="#move-zeroes" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre><td class="rouge-code"><pre><span class="cm">/*
The general idea is that we know the end of the array is going to contain zeroes. So first, iterate over the array, if you find any non-zero value, copy it down to the front of the array. Then we you are done, length of the array minus the last index where you copied the non-zero element is the number of zeroes you need to fill in. So iterate from that last non-zero index to the end of the array and fill in zeroes.
*/</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">moveZeroes</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">lastNonZeroIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span>
            <span class="n">nums</span><span class="o">[</span><span class="n">lastNonZeroIndex</span><span class="o">++]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">lastNonZeroIndex</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
        <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
<span class="o">}</span>

<span class="cm">/*
This solution is an extension of the above, but a better one because we only swap elements when needed and do not do any unnecessary writes. Start from the beginning of the array, maintain the last position of non-zero value you saw, and the current element. If you see a non-zero value, swap the current value with the index just after the last non-zero index you have, and then increment the non-zero index by 1 because you just found a new non-zero value. This helps us prepare for the next non-zero value we find and copy it at this index+1. By doing so, we are basically partitioning the array into non-zeroes and zero values.
*/</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">moveZeroes</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">lastNonZeroIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span>
            <span class="n">swap</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">i</span> <span class="o">,</span> <span class="n">lastNonZeroIndex</span><span class="o">++);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kt">void</span> <span class="nf">swap</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">j</span><span class="o">){</span>
    <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
    <span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
    <span class="n">a</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="word-pattern"><span class="me-2"><a href="https://leetcode.com/problems/word-pattern/">Word Pattern</a><a name="word-pattern"></a></span><a href="#word-pattern" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">wordPattern</span><span class="o">(</span><span class="nc">String</span> <span class="n">pattern</span><span class="o">,</span> <span class="nc">String</span> <span class="n">str</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">String</span><span class="o">[]</span> <span class="n">words</span> <span class="o">=</span> <span class="n">str</span><span class="o">.</span><span class="na">split</span><span class="o">(</span><span class="s">" "</span><span class="o">);</span>		<span class="c1">// Split str into words</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">pattern</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">!=</span> <span class="n">words</span><span class="o">.</span><span class="na">length</span><span class="o">)</span>	<span class="c1">// If length of pattern and words mismatch</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>						<span class="c1">// then pattern do not match</span>
    <span class="nc">HashMap</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">patternStore</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>	<span class="c1">// Map pattern char to word</span>
    <span class="nc">HashMap</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Character</span><span class="o">&gt;</span> <span class="n">wordMap</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>		<span class="c1">// Map word to pattern char</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">words</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
        <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">pattern</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>					<span class="c1">// Get the char</span>
        <span class="n">patternStore</span><span class="o">.</span><span class="na">putIfAbsent</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="n">words</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>		<span class="c1">// Put it in patternStore if absent</span>
        <span class="k">if</span> <span class="o">(!</span><span class="n">patternStore</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">c</span><span class="o">).</span><span class="na">equals</span><span class="o">(</span><span class="n">words</span><span class="o">[</span><span class="n">i</span><span class="o">]))</span>	<span class="c1">// If it was already there and it doesn't</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>							<span class="c1">// map to words[i], we have a violation</span>
        <span class="n">wordMap</span><span class="o">.</span><span class="na">putIfAbsent</span><span class="o">(</span><span class="n">words</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">c</span><span class="o">);</span>			<span class="c1">// Now check the other way around. If</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">wordMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">words</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">!=</span> <span class="n">c</span><span class="o">)</span>				<span class="c1">// words is absent in the map, map it to</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>							<span class="c1">// the char. If present, then fetch it's</span>
    <span class="o">}</span>												<span class="c1">// mapping and check if both match to c.</span>
    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>							<span class="c1">// No violation, so return true</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="can-win-nim"><span class="me-2"><a href="https://leetcode.com/problems/nim-game/">Can Win Nim</a><a name="can-win-nim"></a></span><a href="#can-win-nim" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">canWinNim</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">4</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">;</span>			<span class="c1">// You can always win the game if n is not divisible by 4.</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="power-of-three"><span class="me-2"><a href="https://leetcode.com/problems/power-of-three/">Power Of Three</a><a name="power-of-three"></a></span><a href="#power-of-three" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isPowerOfThree</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="o">)</span>				<span class="c1">// If negative, it can't be a power of 3.</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">n</span> <span class="o">%</span> <span class="mi">3</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>		<span class="c1">// While n is divisible by 3, keep dividing it.</span>
        <span class="n">n</span> <span class="o">/=</span> <span class="mi">3</span><span class="o">;</span>
    <span class="k">return</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="o">;</span>			<span class="c1">// In the end, if it was a power of 3, then n should be 1.</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="power-of-four"><span class="me-2"><a href="https://leetcode.com/problems/power-of-four/submissions/">Power of Four</a><a name="power-of-four"></a></span><a href="#power-of-four" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="cm">/*
You can also use the iterative method that I have used in Power of Two and Power of Three problems. I just wanted to try a different approach here. This is a constant time function.
*/</span>
<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isPowerOfFour</span><span class="o">(</span><span class="kt">int</span> <span class="n">num</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">double</span> <span class="n">pow</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">log</span><span class="o">(</span><span class="n">num</span><span class="o">)/</span><span class="nc">Math</span><span class="o">.</span><span class="na">log</span><span class="o">(</span><span class="mi">4</span><span class="o">);</span>	<span class="c1">// Calculate x in 4^x = num using logs.</span>
    <span class="k">return</span> <span class="n">pow</span> <span class="o">==</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span><span class="n">pow</span><span class="o">;</span>					<span class="c1">// Making sure that x is an integer and not a</span>
<span class="o">}</span>											<span class="c1">// fractional exponent.</span>
</pre></table></code></div></div><h3 id="reverse-string"><span class="me-2"><a href="https://leetcode.com/problems/reverse-string/">Reverse String</a><a name="reverse-string"></a></span><a href="#reverse-string" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="cm">/*
1 Liner solution. Basically, create a StringBuilder of the string, the builder already has a reverse method, so reverse it and then return it's toString.
*/</span>

<span class="kd">public</span> <span class="nc">String</span> <span class="nf">reverseString</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nf">StringBuilder</span><span class="o">(</span><span class="n">s</span><span class="o">).</span><span class="na">reverse</span><span class="o">().</span><span class="na">toString</span><span class="o">();</span>
<span class="o">}</span>

<span class="cm">/*
Golfing aside, here is how one is expected to solve it in an interview.
*/</span>

<span class="kd">public</span> <span class="nc">String</span> <span class="nf">reverseString</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
	<span class="kt">char</span><span class="o">[]</span> <span class="n">array</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">();</span>		<span class="c1">// Create a char array of the string</span>
	<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>				<span class="c1">// length of the array</span>
	<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="o">/</span><span class="mi">2</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>	<span class="c1">// We only need to iterate over half the array.</span>
		<span class="kt">char</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">array</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>			<span class="c1">// Swap the 0th index element with (len-1)th,</span>
		<span class="n">array</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">array</span><span class="o">[</span><span class="n">len</span><span class="o">-</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">];</span>		<span class="c1">// 1st index element with (len-2)th, until you get</span>
		<span class="n">array</span><span class="o">[</span><span class="n">len</span><span class="o">-</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>			<span class="c1">// to the middle element.</span>
	<span class="o">}</span>
	<span class="k">return</span> <span class="k">new</span> <span class="nf">String</span><span class="o">(</span><span class="n">array</span><span class="o">);</span>			<span class="c1">// Return a new string with the reversed array.</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="implement-strstr"><span class="me-2"><a href="https://leetcode.com/problems/implement-strstr/submissions/">Implement strStr()</a><a name="implement-strstr()"></a></span><a href="#implement-strstr" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="cm">/*
The basic idea here is that you only need to iterate haystack length - needle length, and then check the substring of size = needle length in haystack from each index. If you are successfully able to match each character of the needle in the corresponding substring in haystack, return the index you start from. 
*/</span>
<span class="kd">public</span> <span class="kt">int</span> <span class="nf">strStr</span><span class="o">(</span><span class="nc">String</span> <span class="n">haystack</span><span class="o">,</span> <span class="nc">String</span> <span class="n">needle</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">needle</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&gt;</span> <span class="n">haystack</span><span class="o">.</span><span class="na">length</span><span class="o">())</span>	<span class="c1">// Needle length can't be &gt; than haystack</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">hl</span> <span class="o">=</span> <span class="n">haystack</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
    <span class="kt">int</span> <span class="n">nl</span> <span class="o">=</span> <span class="n">needle</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">nl</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>								<span class="c1">// Empty strings are always a match starting</span>
        <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>								<span class="c1">// from 0.</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">hl</span><span class="o">-</span><span class="n">nl</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>			<span class="c1">// Iterate haystack length - needle length.</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">nl</span> <span class="o">&amp;&amp;</span> <span class="n">haystack</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="o">)</span> <span class="o">==</span> <span class="n">needle</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">);</span> <span class="o">++</span><span class="n">j</span><span class="o">)}</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">j</span> <span class="o">==</span> <span class="n">nl</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span>						<span class="c1">// We are checking how far from i can we</span>
                <span class="k">return</span> <span class="n">i</span><span class="o">;</span>						<span class="c1">// match. If i matched with j, increment j</span>
        <span class="o">}</span>										<span class="c1">// and then match the character i+1 to j.</span>
    <span class="o">}</span>											<span class="c1">// If that matches, increment j and match i+2</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>									<span class="c1">// j == n-1 checked wether or not if we were</span>
<span class="o">}</span>												<span class="c1">// able to match the full needle string, if</span>
												<span class="c1">// yes, then i is our index</span>
												<span class="c1">// in the end, nothing matched, so return -1</span>
</pre></table></code></div></div><h3 id="reverse-vowels-of-a-string"><span class="me-2"><a href="https://leetcode.com/problems/reverse-vowels-of-a-string/">Reverse Vowels of a String</a><a name="reverse-vowels-of-a-string"></a></span><a href="#reverse-vowels-of-a-string" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="nc">String</span> <span class="nf">reverseVowels</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="o">)</span>
        <span class="k">return</span> <span class="n">s</span><span class="o">;</span>					<span class="c1">// No need to reverse a string of length 0 or 1</span>
    <span class="kt">char</span><span class="o">[]</span> <span class="n">str</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">();</span>	<span class="c1">// Get the char array</span>

    <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">str</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span>

    <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">){</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">isVowel</span><span class="o">(</span><span class="n">str</span><span class="o">[</span><span class="n">left</span><span class="o">]))</span>		<span class="c1">// While left is pointing to a</span>
            <span class="n">left</span><span class="o">++;</span>										<span class="c1">// consonant, increment it/</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">isVowel</span><span class="o">(</span><span class="n">str</span><span class="o">[</span><span class="n">right</span><span class="o">]))</span>	<span class="c1">// While right is pointing to a</span>
            <span class="n">right</span><span class="o">--;</span>									<span class="c1">// consonant, decrement it.</span>

        <span class="kt">char</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">str</span><span class="o">[</span><span class="n">left</span><span class="o">];</span>							<span class="c1">// Left and right are now pointing</span>
        <span class="n">str</span><span class="o">[</span><span class="n">left</span><span class="o">]</span> <span class="o">=</span> <span class="n">str</span><span class="o">[</span><span class="n">right</span><span class="o">];</span>							<span class="c1">// to vowels, so swap it.</span>
        <span class="n">str</span><span class="o">[</span><span class="n">right</span><span class="o">]</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>								<span class="c1">// And then increment left and</span>
        <span class="n">left</span><span class="o">++;</span>											<span class="c1">// decrement right to process the</span>
        <span class="n">right</span><span class="o">--;</span>										<span class="c1">// inner string</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nf">String</span><span class="o">(</span><span class="n">str</span><span class="o">);</span>			<span class="c1">// Return a string from the reveresed array.</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">isVowel</span><span class="o">(</span><span class="kt">char</span> <span class="n">c</span><span class="o">){</span>	<span class="c1">// Function to check if a character is a vowel.</span>
    <span class="k">switch</span> <span class="o">(</span><span class="n">c</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">case</span> <span class="sc">'a'</span><span class="o">:</span>
        <span class="k">case</span> <span class="sc">'e'</span><span class="o">:</span>
        <span class="k">case</span> <span class="sc">'i'</span><span class="o">:</span>
        <span class="k">case</span> <span class="sc">'o'</span><span class="o">:</span>
        <span class="k">case</span> <span class="sc">'u'</span><span class="o">:</span>
        <span class="k">case</span> <span class="sc">'A'</span><span class="o">:</span>
        <span class="k">case</span> <span class="sc">'E'</span><span class="o">:</span>
        <span class="k">case</span> <span class="sc">'I'</span><span class="o">:</span>
        <span class="k">case</span> <span class="sc">'O'</span><span class="o">:</span>
        <span class="k">case</span> <span class="sc">'U'</span><span class="o">:</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="k">default</span><span class="o">:</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="intersection-of-two-arrays"><span class="me-2"><a href="https://leetcode.com/problems/intersection-of-two-arrays/">Intersection of two arrays</a><a name="intersection-of-two-arrays"></a></span><a href="#intersection-of-two-arrays" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">intersection</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">set1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;();</span>		<span class="c1">// Record all unique values in set 1</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="nl">i:</span> <span class="n">nums1</span><span class="o">)</span>
        <span class="n">set1</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
    <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">intersect</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>		<span class="c1">// We will use it to record intersection</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="nl">i:</span> <span class="n">nums2</span><span class="o">)</span>								<span class="c1">// For each value in nums2 array</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">set1</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">i</span><span class="o">))</span>						<span class="c1">// If set1 contains it, we found an</span>
            <span class="n">intersect</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>						<span class="c1">// intersecting element, so add it.</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">intersect</span><span class="o">.</span><span class="na">size</span><span class="o">()];</span>			<span class="c1">// We will now convert the set to an</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>										<span class="c1">// array and then return the array.</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="nl">n:</span> <span class="n">intersect</span><span class="o">)</span>
        <span class="n">res</span><span class="o">[</span><span class="n">i</span><span class="o">++]</span> <span class="o">=</span> <span class="n">n</span><span class="o">;</span>
    <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="is-perfect-square"><span class="me-2"><a href="https://leetcode.com/problems/valid-perfect-square/">Is Perfect Square</a><a name="is-perfect-square"></a></span><a href="#is-perfect-square" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre><td class="rouge-code"><pre><span class="cm">/**
The basic idea here is to close in on the square root using binary search algorithm. 
I handle 4 seperately because it's root is the only one where 4/3 &lt; it's square root. 
All other numbers square root is greater than its value/3.
So we create a lowerBound of 1 and an upperBound of num/3. Then if the middle value's square
overshoots, we make upperBound = mid-1, otherwise increment lowerBound to mid+1. This way, we
close on the square root from both sides, and if the middle values is the square root, it's
square will yield num.
*/</span>
<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isPerfectSquare</span><span class="o">(</span><span class="kt">int</span> <span class="n">num</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">num</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">||</span> <span class="n">num</span> <span class="o">==</span> <span class="mi">4</span><span class="o">)</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="kt">long</span> <span class="n">lowerBound</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
    <span class="kt">long</span> <span class="n">upperBound</span> <span class="o">=</span> <span class="n">num</span><span class="o">/</span><span class="mi">3</span><span class="o">;</span>
    <span class="kt">long</span> <span class="n">mid</span><span class="o">;</span>
    <span class="kt">long</span> <span class="n">square</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">lowerBound</span> <span class="o">&lt;=</span> <span class="n">upperBound</span><span class="o">){</span>
        <span class="n">mid</span> <span class="o">=</span> <span class="n">lowerBound</span> <span class="o">+</span> <span class="o">(</span><span class="n">upperBound</span><span class="o">-</span><span class="n">lowerBound</span><span class="o">)/</span><span class="mi">2</span><span class="o">;</span>
        <span class="n">square</span> <span class="o">=</span> <span class="n">mid</span><span class="o">*</span><span class="n">mid</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">square</span> <span class="o">==</span> <span class="n">num</span><span class="o">)</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">square</span> <span class="o">&gt;</span> <span class="n">num</span><span class="o">)</span>
            <span class="n">upperBound</span> <span class="o">=</span> <span class="n">mid</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="k">else</span>
            <span class="n">lowerBound</span> <span class="o">=</span> <span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="sum-of-two-integers"><span class="me-2"><a href="https://leetcode.com/problems/sum-of-two-integers/">Sum of Two Integers</a><a name="sum-of-two-integers"></a></span><a href="#sum-of-two-integers" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>I cannot explain it better than this <a href="https://leetcode.com/problems/sum-of-two-integers/discuss/132479/Simple-explanation-on-how-to-arrive-at-the-solution">post</a>.</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">int</span> <span class="nf">getSum</span><span class="o">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">a</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
        <span class="k">return</span> <span class="n">b</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">b</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
        <span class="k">return</span> <span class="n">a</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">a</span> <span class="o">^</span> <span class="n">b</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">carry</span> <span class="o">=</span> <span class="n">a</span> <span class="o">&amp;</span> <span class="n">b</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">carry</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
        <span class="k">return</span> <span class="n">sum</span><span class="o">;</span>
    <span class="k">return</span> <span class="nf">getSum</span><span class="o">(</span><span class="n">sum</span><span class="o">,</span> <span class="n">carry</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="o">);</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="guess-number-higher-or-lower"><span class="me-2"><a href="https://leetcode.com/problems/guess-number-higher-or-lower/">Guess Number Higher or Lower</a><a name="guess-number-higher-or-lower"></a></span><a href="#guess-number-higher-or-lower" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">int</span> <span class="nf">guessNumber</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>				<span class="c1">// Standard binary search algorithm</span>
    <span class="kt">int</span> <span class="n">low</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span> <span class="n">high</span> <span class="o">=</span> <span class="n">n</span><span class="o">,</span> <span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="o">;</span>		<span class="c1">// Arbitrary result, but not 0</span>
    <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">result</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">){</span>
        <span class="n">mid</span> <span class="o">=</span> <span class="n">low</span> <span class="o">+</span> <span class="o">(</span><span class="n">high</span><span class="o">-</span><span class="n">low</span><span class="o">)/</span><span class="mi">2</span><span class="o">;</span>			<span class="c1">// Check the mid.</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">guess</span><span class="o">(</span><span class="n">mid</span><span class="o">);</span>				<span class="c1">// Check if our guess is correct</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">result</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span>					<span class="c1">// If result == -1, then we overshot</span>
            <span class="n">high</span> <span class="o">=</span> <span class="n">mid</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span>					<span class="c1">// So we can discard all values &gt; mid</span>
        <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">result</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span>				<span class="c1">// If result == 1, we undershot</span>
            <span class="n">low</span> <span class="o">=</span> <span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span>					<span class="c1">// Need to discard all the values &lt; mid</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">mid</span><span class="o">;</span>								<span class="c1">// Result == 0, so return the mid.</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="ransom-note"><span class="me-2"><a href="https://leetcode.com/problems/ransom-note/submissions/">Ransom Note</a><a name="ransom-note"></a></span><a href="#ransom-note" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">canConstruct</span><span class="o">(</span><span class="nc">String</span> <span class="n">ransomNote</span><span class="o">,</span> <span class="nc">String</span> <span class="n">magazine</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">store</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">26</span><span class="o">];</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="nl">c:</span> <span class="n">magazine</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">())</span>		<span class="c1">// First, fill the store with available</span>
        <span class="n">store</span><span class="o">[</span><span class="n">c</span><span class="o">-</span><span class="sc">'a'</span><span class="o">]++;</span>							<span class="c1">// characters from the magazine</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="nl">c:</span> <span class="n">ransomNote</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">())</span>		<span class="c1">// Then, scan through the note, decrement</span>
        <span class="k">if</span> <span class="o">(--</span><span class="n">store</span><span class="o">[</span><span class="n">c</span><span class="o">-</span><span class="sc">'a'</span><span class="o">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span>					<span class="c1">// each char's index by 1 because we used</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>						<span class="c1">// it. If it's frequency drops below 0,</span>
    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>								<span class="c1">// then it means that we need more chars</span>
<span class="o">}</span>												<span class="c1">// than available. In the end, return</span>
												<span class="c1">// true if everything worked out.</span>
</pre></table></code></div></div><h3 id="first-unique-character-in-a-string"><span class="me-2"><a href="https://leetcode.com/problems/first-unique-character-in-a-string/submissions/">First Unique Character in a String</a><a name="first-unique-character-in-a-string"></a></span><a href="#first-unique-character-in-a-string" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">int</span> <span class="nf">firstUniqChar</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">freq</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">26</span><span class="o">];</span>			<span class="c1">// Preprocess freq array to maintain freq of each</span>
    <span class="kt">char</span><span class="o">[]</span> <span class="n">chars</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">();</span>		<span class="c1">// character in the string s</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="nl">c:</span> <span class="n">chars</span><span class="o">)</span>
        <span class="o">++</span><span class="n">freq</span><span class="o">[</span><span class="n">c</span><span class="o">-</span><span class="sc">'a'</span><span class="o">];</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">chars</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>	<span class="c1">// Make a second pass through the chars of the</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">freq</span><span class="o">[</span><span class="n">chars</span><span class="o">[</span><span class="n">i</span><span class="o">]-</span><span class="sc">'a'</span><span class="o">]</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span>		<span class="c1">// string in order, and if any of the char's</span>
            <span class="k">return</span> <span class="n">i</span><span class="o">;</span>						<span class="c1">// frequency is 1, that's our unique char</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>								<span class="c1">// Otherwise, no unique character</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="find-the-difference"><span class="me-2"><a href="https://leetcode.com/problems/find-the-difference/">Find the Difference</a><a name="find-the-difference"></a></span><a href="#find-the-difference" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="cm">/**
The general idea here is same as the problem where we are required to find a unique int
in an array containing duplicates except one. We use the xor operator between each character
of the string s and t, and the ones that are duplicate will xor to give 0. XOR of any element
with 0 is the element itself, and XOR of two same elements gives 0. This way, since string s
and t basically has pairs of repeating characters except one, the unique element will XOR
with 0 and give us it's ASCII code. The only thing we need to take care of is to now shift it
up by 26, so we add 'a' and convert it to char.
*/</span>
<span class="kd">public</span> <span class="kt">char</span> <span class="nf">findTheDifference</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="nc">String</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">xor</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="nl">c:</span> <span class="n">s</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">())</span>
        <span class="n">xor</span> <span class="o">^=</span> <span class="n">c</span><span class="o">-</span><span class="sc">'a'</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="nl">c:</span> <span class="n">t</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">())</span>
        <span class="n">xor</span> <span class="o">^=</span> <span class="n">c</span><span class="o">-</span><span class="sc">'a'</span><span class="o">;</span>
    <span class="k">return</span> <span class="o">(</span><span class="kt">char</span><span class="o">)(</span><span class="n">xor</span><span class="o">+</span><span class="sc">'a'</span><span class="o">);</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="nth-digit"><span class="me-2"><a href="https://leetcode.com/problems/nth-digit/">Nth Digit</a><a name="nth-digit"></a></span><a href="#nth-digit" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="cm">/**
Notice that # of digits between 0-9 is 1*9, 10-99 is 2*90, 100-999 is 3*900. If we generalize
it, it is exactly equal to 9 * (num of digits in the number) * 10^{# of digits - 1}.
*/</span>
<span class="kd">public</span> <span class="kt">int</span> <span class="nf">findNthDigit</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="o">)</span>
        <span class="k">return</span> <span class="n">n</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">pow</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>				<span class="c1">// First we need to figure out how many digits there are</span>
    <span class="kt">long</span> <span class="n">upperBound</span> <span class="o">=</span> <span class="mi">9</span><span class="o">;</span>		<span class="c1">// in the number.</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="n">upperBound</span><span class="o">){</span>
        <span class="n">n</span> <span class="o">-=</span> <span class="n">upperBound</span><span class="o">;</span>		<span class="c1">// If n is a two digit number, subtract the 9 single digit</span>
        <span class="o">++</span><span class="n">pow</span><span class="o">;</span>					<span class="c1">// numbers, if 3 digit, subtract the first 189 digits.</span>
        <span class="n">upperBound</span> <span class="o">=</span> <span class="o">(</span><span class="kt">long</span><span class="o">)</span><span class="nc">Math</span><span class="o">.</span><span class="na">pow</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="n">pow</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">*</span> <span class="n">pow</span> <span class="o">*</span> <span class="mi">9</span><span class="o">;</span>
    <span class="o">}</span>							<span class="c1">// pow allows us to track how many digits there are in num.</span>

    <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span><span class="nc">Math</span><span class="o">.</span><span class="na">pow</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span><span class="n">pow</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">+</span> <span class="o">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">)/</span><span class="n">pow</span><span class="o">;</span>		<span class="c1">// Calculate which number we want</span>
    <span class="kt">int</span> <span class="n">position</span> <span class="o">=</span> <span class="n">pow</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="o">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">%</span> <span class="n">pow</span><span class="o">;</span>				<span class="c1">// Calculate which index we want</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">position</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>					<span class="c1">// Divide num that many times</span>
        <span class="n">num</span> <span class="o">/=</span> <span class="mi">10</span><span class="o">;</span>
    <span class="k">return</span> <span class="n">num</span> <span class="o">%</span> <span class="mi">10</span><span class="o">;</span>									<span class="c1">// num % 10 gives us that digit.</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="sum-of-left-leaves"><span class="me-2"><a href="https://leetcode.com/problems/sum-of-left-leaves/">Sum of Left Leaves</a><a name="sum-of-left-leaves"></a></span><a href="#sum-of-left-leaves" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">int</span> <span class="nf">sumOfLeftLeaves</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>		<span class="c1">// Empty tree, therefore total is 0.</span>
        <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>			<span class="c1">// Initialize sum.</span>
    <span class="c1">// Look ahead and check. If left is not null but left is a leaf, then sum is the value of the left leaf.</span>
    <span class="c1">// But if left is null or left is an inner node, then we need to explore it, so sum is whatever the subtree from the left node returns.</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">left</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">right</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
        <span class="n">sum</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">val</span><span class="o">;</span>
    <span class="k">else</span>
        <span class="n">sum</span> <span class="o">=</span> <span class="n">sumOfLeftLeaves</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
    <span class="c1">// We computed the sum of the left side. Now we need to traverse the right side and fetch</span>
    <span class="c1">// the sum, so total sum is sum of the left side as computed above + sum returned by</span>
    <span class="c1">// traversing the right side.</span>
    <span class="k">return</span> <span class="n">sum</span> <span class="o">+</span> <span class="n">sumOfLeftLeaves</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="longest-palindrome"><span class="me-2"><a href="https://leetcode.com/problems/longest-palindrome/">Longest Palindrome</a><a name="longest-palindrome"></a></span><a href="#longest-palindrome" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">int</span> <span class="nf">longestPalindrome</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">freq</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">128</span><span class="o">];</span>		<span class="c1">// To record the frequency of each char</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="nl">c:</span> <span class="n">s</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">())</span>
        <span class="n">freq</span><span class="o">[</span><span class="n">c</span><span class="o">]++;</span>					<span class="c1">// Increment count by 1 for each character observed</span>
    <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>					<span class="c1">// length of the longest palindrome</span>
    <span class="kt">boolean</span> <span class="n">isOdd</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>			<span class="c1">// Check if our palindrome length is odd</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">128</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>	<span class="c1">// Go through each character's index</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">freq</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">){</span>			<span class="c1">// Only if it has been observed atleast once</span>
            <span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="n">freq</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>		<span class="c1">// Store it's frequency</span>
            <span class="kt">int</span> <span class="n">used</span><span class="o">;</span>				<span class="c1">// Record how many of it's occurrences we will use</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">val</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>		<span class="c1">// If a perfect multiple of 2, we will use all</span>
                <span class="n">used</span> <span class="o">=</span> <span class="n">val</span><span class="o">;</span>
            <span class="k">else</span><span class="o">{</span>
                <span class="n">used</span> <span class="o">=</span> <span class="n">val</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span>		<span class="c1">// If odd occurrences, then the max we can use to form a</span>
                <span class="n">isOdd</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>		<span class="c1">// valid palindrome is val-1. It also tells us that the</span>
            <span class="o">}</span>						<span class="c1">// palindrome is going to be of odd length.</span>
            <span class="n">len</span> <span class="o">+=</span> <span class="n">used</span><span class="o">;</span>			<span class="c1">// Finally, increment length by the number of chars used</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">isOdd</span><span class="o">)</span>						<span class="c1">// If length is odd, we can always insert any single</span>
        <span class="k">return</span> <span class="n">len</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span>				<span class="c1">// character in the middle to keep the palindrome valid.</span>
    <span class="k">return</span> <span class="n">len</span><span class="o">;</span>						<span class="c1">// If the length is even, then we can't do anything.</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="fizz-buzz"><span class="me-2"><a href="https://leetcode.com/problems/fizz-buzz/">Fizz Buzz</a><a name="fizz-buzz"></a></span><a href="#fizz-buzz" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="nf">fizzBuzz</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">nums</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;();</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>				<span class="c1">// Loop from 1 to n</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">15</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>						<span class="c1">// If i divisible by 15, add "FizzBuzz"</span>
            <span class="n">nums</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"FizzBuzz"</span><span class="o">);</span>
        <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">5</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>					<span class="c1">// i's not a multiple of 15, check if it's a</span>
            <span class="n">nums</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"Buzz"</span><span class="o">);</span>					<span class="c1">// multiple of 5. If so, add "Buzz"</span>
        <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">3</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>					<span class="c1">// i's not a multiple of 5, check if it's a</span>
            <span class="n">nums</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"Fizz"</span><span class="o">);</span>					<span class="c1">// multiple of 3, if so, add "Fizz"</span>
        <span class="k">else</span>
            <span class="n">nums</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">i</span><span class="o">+</span><span class="s">""</span><span class="o">);</span>						<span class="c1">// Otherwise, just add the String type of the</span>
    <span class="o">}</span>											<span class="c1">// number</span>
    <span class="k">return</span> <span class="n">nums</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="third-maximum-number"><span class="me-2"><a href="https://leetcode.com/problems/third-maximum-number/">Third maximum Number</a><a name="third-maximum-number"></a></span><a href="#third-maximum-number" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">int</span> <span class="nf">thirdMax</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>		<span class="c1">// Empty array</span>
        <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span>		<span class="c1">// Size 1 array</span>
        <span class="k">return</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">2</span><span class="o">)</span>		<span class="c1">// Size 2 array, check between 0th element or 1st element</span>
        <span class="k">return</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">nums</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">?</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">:</span> <span class="n">nums</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>
    <span class="kt">long</span> <span class="n">firstMax</span> <span class="o">=</span> <span class="nc">Long</span><span class="o">.</span><span class="na">MIN_VALUE</span><span class="o">;</span>		<span class="c1">// Lowest values for all three</span>
    <span class="kt">long</span> <span class="n">secondMax</span> <span class="o">=</span> <span class="nc">Long</span><span class="o">.</span><span class="na">MIN_VALUE</span><span class="o">;</span>
    <span class="kt">long</span> <span class="n">thirdMax</span> <span class="o">=</span> <span class="nc">Long</span><span class="o">.</span><span class="na">MIN_VALUE</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="nl">i:</span> <span class="n">nums</span><span class="o">){</span>					<span class="c1">// For each number in the array</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="n">firstMax</span><span class="o">){</span>				<span class="c1">// If num &gt; than the largest, then old largest</span>
            <span class="n">thirdMax</span> <span class="o">=</span> <span class="n">secondMax</span><span class="o">;</span>		<span class="c1">// becomes second largest and second largest becomes</span>
            <span class="n">secondMax</span> <span class="o">=</span> <span class="n">firstMax</span><span class="o">;</span>		<span class="c1">// first largest, then update the largest.</span>
            <span class="n">firstMax</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="n">secondMax</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">firstMax</span><span class="o">){</span>	<span class="c1">// If num &gt; second and num is not is the</span>
            <span class="n">thirdMax</span> <span class="o">=</span> <span class="n">secondMax</span><span class="o">;</span>					<span class="c1">// same as first, first largets becomes</span>
            <span class="n">secondMax</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>							<span class="c1">// second largest and update the second</span>
        <span class="o">}</span>
        <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="n">thirdMax</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">secondMax</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">firstMax</span><span class="o">)</span> <span class="c1">// // If num &gt; third, we</span>
            	<span class="n">thirdMax</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>						<span class="c1">// need to check that it is not the same</span>
    <span class="o">}</span>												<span class="c1">// as the first and second largest.</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">thirdMax</span> <span class="o">==</span> <span class="nc">Long</span><span class="o">.</span><span class="na">MIN_VALUE</span><span class="o">)</span>					<span class="c1">// This check allows us to make sure that</span>
        <span class="k">return</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span><span class="n">firstMax</span><span class="o">;</span>						<span class="c1">// we do indeed have a third max and is</span>
    <span class="k">return</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span><span class="n">thirdMax</span><span class="o">;</span>							<span class="c1">// not what we initialized initially.</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="add-two-strings"><span class="me-2"><a href="https://leetcode.com/problems/add-strings/">Add Two Strings</a><a name="add-two-strings"></a></span><a href="#add-two-strings" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="nc">String</span> <span class="nf">addStrings</span><span class="o">(</span><span class="nc">String</span> <span class="n">num1</span><span class="o">,</span> <span class="nc">String</span> <span class="n">num2</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">num1</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">"0"</span><span class="o">))</span>
        <span class="k">return</span> <span class="n">num2</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">num2</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">"0"</span><span class="o">))</span>
        <span class="k">return</span> <span class="n">num1</span><span class="o">;</span>
    
    <span class="cm">/** We use a char array to maintain the digit at each index. We want the array to be of
    the size of the largest string + 1 to handle carry bit if any at the end. We start
    adding each digit of the string from the end, and place it in it's correct index at the
    end of the sum array. This way, we avoid reversing it and return the answer in constant
    time. Take care to convert the digit you compute by adding '0'. Lastly, if the carry bit
    is 1, we need to make the 0th index as 1, and return the string by using the sum array.
    If it's not 1, then the sum array has a leading 0 which we don't want. So we use Java's
    String constructor that takes in the char array, startingIndex in that array and the
    number of elements of that array we want. So if the carry isn't 1, we technically want
    everything from index 1 and # of elements = sum.length - 1 because we discard 0 index.
    */</span>
    <span class="kt">char</span><span class="o">[]</span> <span class="n">sum</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="o">[</span><span class="mi">1</span> <span class="o">+</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">num1</span><span class="o">.</span><span class="na">length</span><span class="o">(),</span> <span class="n">num2</span><span class="o">.</span><span class="na">length</span><span class="o">())];</span>
    <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">sum</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="n">idx1</span> <span class="o">=</span> <span class="n">num1</span><span class="o">.</span><span class="na">length</span><span class="o">()-</span><span class="mi">1</span><span class="o">,</span> <span class="n">idx2</span> <span class="o">=</span> <span class="n">num2</span><span class="o">.</span><span class="na">length</span><span class="o">()-</span><span class="mi">1</span><span class="o">,</span> <span class="n">carry</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">n1</span><span class="o">,</span> <span class="n">n2</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">idx1</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">idx2</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">){</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="n">idx1</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">num1</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">idx1</span><span class="o">--)-</span><span class="sc">'0'</span><span class="o">;</span>
        <span class="n">n2</span> <span class="o">=</span> <span class="n">idx2</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">num2</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">idx2</span><span class="o">--)-</span><span class="sc">'0'</span><span class="o">;</span>
        <span class="n">total</span> <span class="o">=</span> <span class="n">n1</span> <span class="o">+</span> <span class="n">n2</span> <span class="o">+</span> <span class="n">carry</span><span class="o">;</span>
        <span class="n">carry</span> <span class="o">=</span> <span class="n">total</span><span class="o">/</span><span class="mi">10</span><span class="o">;</span>
        <span class="n">sum</span><span class="o">[</span><span class="n">index</span><span class="o">--]</span> <span class="o">=</span> <span class="o">(</span><span class="kt">char</span><span class="o">)(</span><span class="n">total</span> <span class="o">%</span> <span class="mi">10</span> <span class="o">+</span> <span class="sc">'0'</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">carry</span> <span class="o">==</span> <span class="mi">1</span><span class="o">){</span>
        <span class="n">sum</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="sc">'1'</span><span class="o">;</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">String</span><span class="o">(</span><span class="n">sum</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nf">String</span><span class="o">(</span><span class="n">sum</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="n">sum</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="construct-quad-tree"><span class="me-2"><a href="https://leetcode.com/problems/construct-quad-tree/">Construct Quad Tree</a><a name="construct-quad-tree"></a></span><a href="#construct-quad-tree" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre><span class="kd">private</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">grid</span><span class="o">;</span>					<span class="c1">// Store it once, instead of passing it over &amp; over.</span>
<span class="kd">public</span> <span class="nc">Node</span> <span class="nf">construct</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">_grid</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">grid</span> <span class="o">=</span> <span class="n">_grid</span><span class="o">;</span>
    <span class="k">return</span> <span class="nf">helper</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="n">grid</span><span class="o">.</span><span class="na">length</span><span class="o">);</span>		<span class="c1">// Ask helper to build the tree.</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="nc">Node</span> <span class="nf">helper</span><span class="o">(</span><span class="kt">int</span> <span class="n">top</span><span class="o">,</span> <span class="kt">int</span> <span class="n">left</span><span class="o">,</span> <span class="kt">int</span> <span class="n">len</span><span class="o">){</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">)</span>						<span class="c1">// Base case: if empty grid or if we are done</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>					<span class="c1">// checking the full grid, return null</span>
    <span class="kt">int</span> <span class="n">key</span> <span class="o">=</span> <span class="n">grid</span><span class="o">[</span><span class="n">top</span><span class="o">][</span><span class="n">left</span><span class="o">];</span>			<span class="c1">// Get the topleft value, and start checking the box</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>		<span class="c1">// of len*len. If at any point, the value doesn't</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">len</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>	<span class="c1">// match the key, we have found a breakpoint from</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">grid</span><span class="o">[</span><span class="n">top</span><span class="o">+</span><span class="n">i</span><span class="o">][</span><span class="n">left</span><span class="o">+</span><span class="n">j</span><span class="o">]</span> <span class="o">!=</span> <span class="n">key</span><span class="o">){</span>	<span class="c1">// where we need to break the grid into four</span>
                <span class="kt">int</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">len</span><span class="o">/</span><span class="mi">2</span><span class="o">;</span>		<span class="c1">// grids, each of len = len/2. The topleft grid has</span>
                <span class="k">return</span> <span class="k">new</span> <span class="nf">Node</span><span class="o">(</span><span class="kc">true</span><span class="o">,</span> <span class="kc">false</span><span class="o">,</span> 	<span class="c1">// the same top and left point, the topright</span>
                                <span class="n">helper</span><span class="o">(</span><span class="n">top</span><span class="o">,</span><span class="n">left</span><span class="o">,</span> <span class="n">offset</span><span class="o">),</span>	<span class="c1">// grid has left point shifted to</span>
                                <span class="n">helper</span><span class="o">(</span><span class="n">top</span><span class="o">,</span> <span class="n">left</span> <span class="o">+</span> <span class="n">offset</span><span class="o">,</span> <span class="n">offset</span><span class="o">),</span>	<span class="c1">// the right by offset.</span>
                                <span class="n">helper</span><span class="o">(</span><span class="n">top</span><span class="o">+</span><span class="n">offset</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">offset</span><span class="o">),</span>	<span class="c1">// The bottom left grid</span>
                                <span class="n">helper</span><span class="o">(</span><span class="n">top</span><span class="o">+</span><span class="n">offset</span><span class="o">,</span> <span class="n">left</span><span class="o">+</span><span class="n">offset</span><span class="o">,</span> <span class="n">offset</span><span class="o">));</span>	<span class="c1">// is shifted</span>
            <span class="o">}</span>	<span class="c1">// downwards by offset with the same left point. The bottom right grid will</span>
        <span class="o">}</span>		<span class="c1">// have an index where it's top is shifted down by len/2 and left by left/2.</span>
    <span class="o">}</span>			<span class="c1">// We know that the node will have a value = true if 1 else false and it won't be a leaf, so true, false, topleft, topright, bottomleft, bottomright.</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nf">Node</span><span class="o">(</span><span class="n">key</span> <span class="o">==</span> <span class="mi">1</span><span class="o">,</span> <span class="kc">true</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>	<span class="c1">// Everything passed, so we return a new Node whose value is true if key is 1, else false and it will be a leaf, with</span>
<span class="c1">// no children, so 4 nulls.</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="n-ary-tree-level-order-traversal"><span class="me-2"><a href="https://leetcode.com/problems/n-ary-tree-level-order-traversal/">N-ary Tree Level Order Traversal</a><a name="n-ary-tree-level-order-traversal"></a></span><a href="#n-ary-tree-level-order-traversal" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="nf">levelOrder</span><span class="o">(</span><span class="nc">Node</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>	<span class="c1">// Result list</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>								<span class="c1">// If root is null, return empty list.</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">Node</span><span class="o">&gt;</span> <span class="n">q</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>				<span class="c1">// BFS Queue. Add the root.</span>
    <span class="n">q</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
    <span class="k">while</span> <span class="o">(!</span><span class="n">q</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()){</span>							<span class="c1">// While q isn't empty</span>
        <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>						<span class="c1">// Check how many elements in that level</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">level</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;(</span><span class="n">size</span><span class="o">);</span><span class="c1">// level list to store elements.</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>				<span class="c1">// Remove each node for whatever the size</span>
            <span class="nc">Node</span> <span class="n">n</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>						<span class="c1">// Add that node's value and add all of</span>
            <span class="n">level</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">n</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>						<span class="c1">// its children to the queue.</span>
            <span class="k">for</span> <span class="o">(</span><span class="nc">Node</span> <span class="nl">child:</span> <span class="n">n</span><span class="o">.</span><span class="na">children</span><span class="o">)</span>
                <span class="n">q</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">child</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">level</span><span class="o">);</span>								<span class="c1">// Add the level array to the result</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">res</span><span class="o">;</span>										<span class="c1">// Return the result list.</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="number-of-segments-in-a-string"><span class="me-2"><a href="https://leetcode.com/problems/number-of-segments-in-a-string/">Number of Segments in a String</a><a name="number-of-segments-in-a-string"></a></span><a href="#number-of-segments-in-a-string" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">int</span> <span class="nf">countSegments</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>					<span class="c1">// Empty String</span>
        <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>

    <span class="kt">int</span> <span class="n">segments</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>						<span class="c1">// Record segments</span>

    <span class="kt">char</span> <span class="n">prev</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>				<span class="c1">// We will compare adjacent characters.</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>	<span class="c1">// Start looking at chars from index 0</span>
        <span class="kt">char</span> <span class="n">curr</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>			<span class="c1">// Get the current char</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">prev</span> <span class="o">!=</span> <span class="sc">' '</span> <span class="o">&amp;&amp;</span> <span class="n">curr</span> <span class="o">==</span> <span class="sc">' '</span><span class="o">)</span>		<span class="c1">// If previous char wasn't a space but the</span>
            <span class="o">++</span><span class="n">segments</span><span class="o">;</span>						<span class="c1">// current char is, we found a segment.</span>
        <span class="n">prev</span> <span class="o">=</span> <span class="n">curr</span><span class="o">;</span>						<span class="c1">// Make previous = current for next iteration</span>
    <span class="o">}</span>
<span class="cm">/**
This line is important. If prev was an empty space, that means that all we have been looking
at was empty spaces towards the end. So return whatever segments we found in the beginning
of the string. But if prev wasn't a space, that means the char next to prev might have been
an empty space or just a normal character. In any case, we would want to include that last
segment, so we return segment+1.
*/</span>
    <span class="k">return</span> <span class="n">prev</span> <span class="o">==</span> <span class="sc">' '</span> <span class="o">?</span> <span class="n">segments</span> <span class="o">:</span> <span class="n">segments</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="binary-tree-level-order-traversal"><span class="me-2"><a href="https://leetcode.com/problems/binary-tree-level-order-traversal/">Binary Tree Level Order Traversal</a><a name="binary-tree-level-order-traversal"></a></span><a href="#binary-tree-level-order-traversal" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="nf">levelOrder</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>						<span class="c1">// Empty Tree</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">TreeNode</span><span class="o">&gt;</span> <span class="n">q</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>	<span class="c1">// BFS Queue</span>
    <span class="n">q</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
    <span class="k">while</span> <span class="o">(!</span><span class="n">q</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()){</span>					<span class="c1">// While we have something to process</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">level</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>				<span class="c1">// Check how many elements at the current level</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
            <span class="nc">TreeNode</span> <span class="n">node</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>		<span class="c1">// Remove one element each time</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">node</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>				<span class="c1">// If not null, add it's val to the level list,</span>
                <span class="n">level</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>		<span class="c1">// and it's left and right children to the queue</span>
                <span class="n">q</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>			<span class="c1">// to process in order</span>
                <span class="n">q</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(!</span><span class="n">level</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span>				<span class="c1">// If level list wasn't empty,</span>
            <span class="n">result</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">level</span><span class="o">);</span>				<span class="c1">// add it to the result list.</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="path-sum-iii"><span class="me-2"><a href="https://leetcode.com/problems/path-sum-iii/submissions/">Path Sum III</a><a name="path-sum-iii"></a></span><a href="#path-sum-iii" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre><td class="rouge-code"><pre><span class="nc">HashMap</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">sumToWays</span><span class="o">;</span>			<span class="c1">// Record how many ways there are to form sum</span>
<span class="kt">int</span> <span class="n">ways</span><span class="o">;</span>										<span class="c1">// Total number of ways.</span>
<span class="kd">public</span> <span class="kt">int</span> <span class="nf">pathSum</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">,</span> <span class="kt">int</span> <span class="n">sum</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">sumToWays</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
    <span class="n">ways</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="n">sumToWays</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">);</span>							<span class="c1">// 1 way to form a sum of 0.</span>
    <span class="n">helper</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">sum</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">ways</span><span class="o">;</span>
<span class="o">}</span>

<span class="cm">/**
The idea here is as follows. Start with the root node, and keep a running total. We maintain
how many ways there to form a running sum. Then we check how many ways there are to form
(running sum) - (sum we are looking for). If there is a way to form it, then we increase the
number of ways to form sum. We then have to update the map to record how many ways can the
running sum be formed. If it's something we could form before, increment it, or else set it
to 1. Now, traverse the left side and then the right side. In the end, for each time we
incremented the count for a running sum, we need to decrement it because we are backtracking.
We are first going down, incrementing the count for runningSum, then we move up and decrement
it by 1 for each time we observed it. This is to maintain the Pre-Order traversal.
*/</span>
<span class="kd">private</span> <span class="kt">void</span> <span class="nf">helper</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">node</span><span class="o">,</span> <span class="kt">int</span> <span class="n">runningSum</span><span class="o">,</span> <span class="kt">int</span> <span class="n">sum</span><span class="o">){</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">node</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
        <span class="k">return</span><span class="o">;</span>
    <span class="n">runningSum</span> <span class="o">+=</span> <span class="n">node</span><span class="o">.</span><span class="na">val</span><span class="o">;</span>
    <span class="n">ways</span> <span class="o">+=</span> <span class="n">sumToWays</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">runningSum</span><span class="o">-</span><span class="n">sum</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
    <span class="n">sumToWays</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">runningSum</span><span class="o">,</span> <span class="n">sumToWays</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">runningSum</span><span class="o">,</span> <span class="mi">0</span><span class="o">)+</span><span class="mi">1</span><span class="o">);</span>

    <span class="n">helper</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">runningSum</span><span class="o">,</span> <span class="n">sum</span><span class="o">);</span>
    <span class="n">helper</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">runningSum</span><span class="o">,</span> <span class="n">sum</span><span class="o">);</span>

    <span class="n">sumToWays</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">runningSum</span><span class="o">,</span> <span class="n">sumToWays</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">runningSum</span><span class="o">)-</span><span class="mi">1</span><span class="o">);</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="find-all-anagrams-in-a-string"><span class="me-2"><a href="https://leetcode.com/problems/find-all-anagrams-in-a-string/">Find All Anagrams in a String</a><a name="find-all-anagrams-in-a-string"></a></span><a href="#find-all-anagrams-in-a-string" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="nf">findAnagrams</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="nc">String</span> <span class="n">p</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
    <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">end</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">slen</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">(),</span> <span class="n">plen</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">slen</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">slen</span> <span class="o">&lt;</span> <span class="n">plen</span> <span class="o">||</span> <span class="n">plen</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">freq</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">26</span><span class="o">];</span>				<span class="c1">// Store the freq of chars in p</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="nl">c:</span> <span class="n">p</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">())</span>
        <span class="n">freq</span><span class="o">[</span><span class="n">c</span><span class="o">-</span><span class="sc">'a'</span><span class="o">]++;</span>
    <span class="kt">char</span><span class="o">[]</span> <span class="n">sArr</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">();</span>			<span class="c1">// Get the chars of the string s as an array</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">end</span> <span class="o">&lt;</span> <span class="n">slen</span><span class="o">){</span>						<span class="c1">// While everything is not processed</span>
        <span class="k">if</span> <span class="o">(--</span><span class="n">freq</span><span class="o">[</span><span class="n">sArr</span><span class="o">[</span><span class="n">end</span><span class="o">]-</span><span class="sc">'a'</span><span class="o">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">)</span>		<span class="c1">// decrease the freq of the char at index end</span>
            <span class="n">plen</span><span class="o">--;</span>							<span class="c1">// if it's &gt; 0, then we matched something in p</span>
											<span class="c1">// so decrease plen by 1.</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">plen</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>					<span class="c1">// If plen goes to 0, we were able to match all</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">end</span><span class="o">-</span><span class="n">start</span><span class="o">+</span><span class="mi">1</span> <span class="o">==</span> <span class="n">p</span><span class="o">.</span><span class="na">length</span><span class="o">())</span>	<span class="c1">// chars of p. If length of the matched chars is</span>
                <span class="n">result</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">start</span><span class="o">);</span>			<span class="c1">// equal to length p, we found a start point.</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">freq</span><span class="o">[</span><span class="n">sArr</span><span class="o">[</span><span class="n">start</span><span class="o">]-</span><span class="sc">'a'</span><span class="o">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">)</span>	<span class="c1">// Check if the freq of char at start index is</span>
                <span class="n">plen</span><span class="o">++;</span>						<span class="c1">// &gt;= 0. If it is, shift the window to the right</span>
            <span class="o">++</span><span class="n">freq</span><span class="o">[</span><span class="n">sArr</span><span class="o">[</span><span class="n">start</span><span class="o">++]-</span><span class="sc">'a'</span><span class="o">];</span>		<span class="c1">// but first restore the frequency of the char</span>
        <span class="o">}</span>									<span class="c1">// at the index start.</span>

        <span class="n">end</span><span class="o">++;</span>								<span class="c1">// Get ready to inspect the new element</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="n">result</span><span class="o">;</span>							<span class="c1">// Return the answer.</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="arranging-coins"><span class="me-2"><a href="https://leetcode.com/problems/arranging-coins/">Arranging Coins</a><a name="arranging-coins"></a></span><a href="#arranging-coins" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>The idea is as follows. Sum of first n numbers is given by $\frac{n^2+n}{2}$. We need to find $n$ such that sum of $n$ numbers is closest to the number of coins we have. That is, $\frac{n^2+n}{2} = k$ where $k$ is the number of coins we have. So, everything boils down to solving the quadratic equation $n^2 + n - 2k = 0$. We use the quadratic formula where for any quadratic equation $ax^2 -bx + c$ is solved substituting for $a$, $b$ and $c$ in $x = \frac{-b \pm \sqrt{b^2 - 4ac}}{2}$. Here, $a$ and $b$ are always going to be 1, while $c$ is always going to be $2k$. Substitute those, and solve the equation.</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">int</span> <span class="nf">arrangeCoins</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// return solveQuadratic(n);</span>
    <span class="k">return</span> <span class="nf">iterative</span><span class="o">(</span><span class="n">n</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kt">int</span> <span class="nf">solveQuadratic</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">){</span>
    <span class="k">return</span> <span class="o">(</span><span class="kt">int</span><span class="o">)(</span><span class="nc">Math</span><span class="o">.</span><span class="na">sqrt</span><span class="o">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">8</span><span class="o">*(</span><span class="kt">long</span><span class="o">)</span><span class="n">n</span><span class="o">)-</span><span class="mi">1</span><span class="o">)/</span><span class="mi">2</span><span class="o">;</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kt">int</span> <span class="nf">iterative</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">){</span>
    <span class="kt">int</span> <span class="n">used</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span> <span class="n">level</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>		<span class="c1">// Coins used, and level completed.</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">){</span>					<span class="c1">// While coins left are greater than 0.</span>
        <span class="n">n</span><span class="o">-=</span><span class="n">used</span><span class="o">;</span>					<span class="c1">// Calculcate remaining coins.</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span>					<span class="c1">// If there are still some coins left,</span>
            <span class="o">++</span><span class="n">level</span><span class="o">;</span>				<span class="c1">// we were able to fill the level.</span>
        <span class="o">++</span><span class="n">used</span><span class="o">;</span>						<span class="c1">// Prepare used for the next level, which is plus 1.</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">level</span><span class="o">;</span>					<span class="c1">// Return level</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="hamming-distance"><span class="me-2"><a href="https://leetcode.com/problems/hamming-distance/">Hamming Distance</a><a name="hamming-distance"></a></span><a href="#hamming-distance" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">int</span> <span class="nf">hammingDistance</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">diff</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>				<span class="c1">// Track differences</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">x</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">y</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>	<span class="c1">// While both of them aren't 0</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="n">y</span> <span class="o">%</span> <span class="mi">2</span><span class="o">)</span>		<span class="c1">// Check the bit of x and y by mod 2. If they are unequal</span>
            <span class="n">diff</span><span class="o">++;</span>				<span class="c1">// increment difference.</span>
        <span class="n">x</span> <span class="o">/=</span> <span class="mi">2</span><span class="o">;</span>					<span class="c1">// Divide x and y by 2.</span>
        <span class="n">y</span> <span class="o">/=</span> <span class="mi">2</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">diff</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="string-compression"><span class="me-2"><a href="https://leetcode.com/problems/string-compression/">String Compression</a><a name="string-compression"></a></span><a href="#string-compression" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">int</span> <span class="nf">compress</span><span class="o">(</span><span class="kt">char</span><span class="o">[]</span> <span class="n">chars</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">chars</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>			<span class="c1">// No need to reverse array of length 0 or 1</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="o">)</span>
        <span class="k">return</span> <span class="n">len</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">arrayIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>				<span class="c1">// To maintain the length of new array.</span>
    <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>					<span class="c1">// start index</span>
    <span class="kt">int</span> <span class="n">end</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>					<span class="c1">// end index</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">end</span> <span class="o">&lt;</span> <span class="n">len</span><span class="o">){</span>
        <span class="kt">char</span> <span class="n">first</span> <span class="o">=</span> <span class="n">chars</span><span class="o">[</span><span class="n">start</span><span class="o">];</span>	<span class="c1">// Record the char we are looking at.</span>
        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>				<span class="c1">// count is 0.</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">end</span> <span class="o">&lt;</span> <span class="n">len</span> <span class="o">&amp;&amp;</span> <span class="n">chars</span><span class="o">[</span><span class="n">end</span><span class="o">]</span> <span class="o">==</span> <span class="n">first</span><span class="o">){</span>	<span class="c1">// while the char is the same</span>
            <span class="o">++</span><span class="n">end</span><span class="o">;</span>					<span class="c1">// increment end to check next char</span>
            <span class="o">++</span><span class="n">count</span><span class="o">;</span>				<span class="c1">// and increment the count.</span>
        <span class="o">}</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">end</span><span class="o">;</span>				<span class="c1">// shift start to end to check next sequence of chars</span>
        <span class="n">chars</span><span class="o">[</span><span class="n">arrayIndex</span><span class="o">++]</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span>	<span class="c1">// our arrayIndex points to to the new array's </span>
        <span class="k">if</span> <span class="o">(</span><span class="n">count</span> <span class="o">!=</span> <span class="mi">1</span><span class="o">){</span>				<span class="c1">// indices. So copy the first char to arrayIndex.</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">count</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="o">)</span>	<span class="c1">//Only if count isn't 1, if count is less than 10</span>
                <span class="n">chars</span><span class="o">[</span><span class="n">arrayIndex</span><span class="o">++]</span> <span class="o">=</span> <span class="o">(</span><span class="kt">char</span><span class="o">)(</span><span class="n">count</span><span class="o">+</span><span class="sc">'0'</span><span class="o">);</span>	<span class="c1">// then we simply convert count to char and write it next to the char we just overwrote.</span>
            <span class="k">else</span>						<span class="c1">// Otherwise, it has many digits. So convert it to</span>
                <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="nl">c:</span> <span class="nc">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">count</span><span class="o">).</span><span class="na">toCharArray</span><span class="o">()){</span>	<span class="c1">// string and add all it's digit to the array one by one while increment arrayIndex.</span>
                    <span class="n">chars</span><span class="o">[</span><span class="n">arrayIndex</span><span class="o">++]</span> <span class="o">=</span> <span class="n">c</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">arrayIndex</span><span class="o">;</span>			<span class="c1">// Wherever arrayIndex is, is the new length for the array.</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="number-of-boomerangs"><span class="me-2"><a href="https://leetcode.com/problems/number-of-boomerangs/">Number of Boomerangs</a><a name="number-of-boomerangs"></a></span><a href="#number-of-boomerangs" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">int</span> <span class="nf">numberOfBoomerangs</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">points</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">boomerangs</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="nc">HashMap</span><span class="o">&lt;</span><span class="nc">Double</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>	<span class="c1">// To record points with same dist</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="nl">i:</span> <span class="n">points</span><span class="o">){</span>		<span class="c1">// Compute distance between one point and every other.</span>
        <span class="n">map</span><span class="o">.</span><span class="na">clear</span><span class="o">()</span>				<span class="c1">// clear map before each relative distance computation</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="nl">j:</span> <span class="n">points</span><span class="o">){</span>	<span class="c1">// Compute distance with other points</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="o">)</span>			<span class="c1">// Don't compare the same two points.</span>
                <span class="k">continue</span><span class="o">;</span>
            <span class="kt">double</span> <span class="n">dist</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">sqrt</span><span class="o">(</span><span class="nc">Math</span><span class="o">.</span><span class="na">pow</span><span class="o">(</span><span class="n">i</span><span class="o">[</span><span class="mi">0</span><span class="o">]-</span><span class="n">j</span><span class="o">[</span><span class="mi">0</span><span class="o">],</span><span class="mi">2</span><span class="o">)</span> <span class="o">+</span> <span class="nc">Math</span><span class="o">.</span><span class="na">pow</span><span class="o">(</span><span class="n">i</span><span class="o">[</span><span class="mi">1</span><span class="o">]-</span><span class="n">j</span><span class="o">[</span><span class="mi">1</span><span class="o">],</span><span class="mi">2</span><span class="o">));</span>
            <span class="kt">int</span> <span class="n">prevCount</span> <span class="o">=</span> <span class="n">map</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">dist</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>	<span class="c1">// Check how many points are equidistant from point i.</span>
            <span class="n">boomerangs</span> <span class="o">+=</span> <span class="n">prevCount</span> <span class="o">*</span> <span class="mi">2</span><span class="o">;</span>	<span class="c1">//  Number of boomerangs = whatever pairs there were before times 2, because you can form twice the number of different orders.</span>
            <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">dist</span><span class="o">,</span> <span class="n">prevCount</span><span class="o">+</span><span class="mi">1</span><span class="o">);</span>	<span class="c1">// Increase the count of points observed for that distance.</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">boomerangs</span><span class="o">;</span>	<span class="c1">// return number of boomerangs</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="find-all-numbers-disappeared-in-an-array"><span class="me-2"><a href="https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/">Find All Numbers Disappeared in an Array</a><a name="find-all-numbers-disappeared-in-an-array"></a></span><a href="#find-all-numbers-disappeared-in-an-array" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre><td class="rouge-code"><pre><span class="cm">/**
The idea is simple. For each number in the array, since it's gauranteed that that the values
lie are inclusive [1,n], we can look at the index value-1. So check that index, and mark
that value as negative. That is why I take the absolute value. Check value at that index, if
negative, it means we have visited it via some other duplicate value. But if it's positive,
then we are seeing it for the first time, so make it's value negative. Make a second pass.
For values that are still positive, that means those indices were never visited, hence left
positive. So add 1 to them and add it to the set. Eg:
	Given array a = [4,3,2,7,8,2,3,1],
1.	val = 4 =&gt; idx = 3 &amp; a[3] &gt; 0, therefore, a[3] *= -1
	a = [4,3,2,-7,8,2,3,1]
2.	val = 3 =&gt; idx = 2 &amp; a[2] &gt; 0, therefore a[2] *= -1
	a = [4,3,-2,-7,8,2,3,1]
3.	val = -2 =&gt; idx = abs(-2)-1 = 1 &amp; a[1] &gt; 0, therefore a[1] *= -1
	a = [4,-3,-2,-7,8,2,3,1]
4.	val = -7 =&gt; idx = abs(-7)-1 = 6 &amp; a[6] &gt; 0, therfore a[6] *= -1
	a = [4,-3,-2,-7,8,2,-3,1]
5.	val = 8 =&gt; idx = abs(8)-1 = 7 &amp; a[7] &gt; 0, therfore a[7] *= -1
	a = [4,-3,-2,-7,8,2,-3,-1]
6.	val = 2 =&gt; idx = 1 but a[2] &lt; 0. No change.
7.	val = -3 =&gt; idx = abs(-3)-1 = 2 but a[2] &lt; 0. No change.
8.	val = -1 =&gt; idx = abs(-1)-1 = 0 &amp; a[0] &gt; 0, therefore a[0] *= -1
	a = [-4,-3,-2,-7,8,2,-3,-1]
Observation: Notice index 4 and 5 have positive values, since those values were never
encountered, so the values at those indexes never became negative. Hence missing values are
5 and 6.
*/</span>
<span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="nf">findDisappearedNumbers</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="nl">i:</span> <span class="n">nums</span><span class="o">){</span>				<span class="c1">// For each number in the array</span>
        <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">i</span><span class="o">)-</span><span class="mi">1</span><span class="o">;</span>	<span class="c1">// Look at the index that the number corresponds to</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">idx</span><span class="o">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span>			<span class="c1">// If val is -ve, then it means we have encountered it.</span>
            <span class="n">nums</span><span class="o">[</span><span class="n">idx</span><span class="o">]</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>  		<span class="c1">// If not, make it -ve.</span>
    <span class="o">}</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span>			<span class="c1">// Make another pass through the array, and the indices</span>
            <span class="n">result</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">);</span>		<span class="c1">// where value was positive, index+1 was missing from</span>
    <span class="k">return</span> <span class="n">result</span><span class="o">;</span>					<span class="c1">// the array</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="assign-cookies"><span class="me-2"><a href="https://leetcode.com/problems/assign-cookies/">Assign Cookies</a><a name="assign-cookies"></a></span><a href="#assign-cookies" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="cm">/**
We will employ a greedy algorithm where we first try to content children whose requirements
are small. We do this by sorting both the arrays, so we can match the child with least
requirement with the smallest cookie available.
*/</span>
<span class="kd">public</span> <span class="kt">int</span> <span class="nf">findContentChildren</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">g</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">g</span><span class="o">);</span>
    <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
    <span class="kt">int</span> <span class="n">satisfied</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">g</span><span class="o">.</span><span class="na">length</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">){</span>	<span class="c1">// While children are left and we have cookies,</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">s</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">&gt;=</span> <span class="n">g</span><span class="o">[</span><span class="n">i</span><span class="o">]){</span>		<span class="c1">// Check if the cookie at index j &gt;= child i's requirement</span>
            <span class="n">satisfied</span><span class="o">++;</span>		<span class="c1">// If so, increment the number of content child and we will</span>
            <span class="n">i</span><span class="o">++;</span>				<span class="c1">// process the next child.</span>
        <span class="o">}</span>						<span class="c1">// If cookie j &lt; child i's demand, check the next cookie by</span>
        <span class="n">j</span><span class="o">++;</span>					<span class="c1">// incrementing j. If cookie j &gt; child i's demand, we will</span>
    <span class="o">}</span>							<span class="c1">// still need to increment j, hence outside the conditional.</span>
    <span class="k">return</span> <span class="n">satisfied</span><span class="o">;</span>			<span class="c1">// Return number of satisfied children</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="poor-pigs"><span class="me-2"><a href="https://leetcode.com/problems/poor-pigs/">Poor Pigs</a><a name="poor-pigs"></a></span><a href="#poor-pigs" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><a href="https://leetcode.com/problems/poor-pigs/discuss/94305/1-line-solution-with-detailed-problem-clarification-and-math-proof-(please-read-if-you-really-want-to-know-what-this-problem-means)">Link</a> to the solution explanation. This problem is phrased poorly and I had to read the comments by other users to understand what it required from me. The link I marked here explains the logic pretty good. But the simple logic is this: The number of rounds $r = \frac{Total Test Time}{Minutes To Die} +1$. Each pig has chances of dying in each round or staying alive till the end, so we plus 1. Now given the number of rounds $r$ and the number of samples $s$, how many volunteers $v$ will you need? $r^v = s$. Each round has some volunteers which in total at the end should be able to test out all the samples. Therefore, $v =\log_rs$.</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">int</span> <span class="nf">poorPigs</span><span class="o">(</span><span class="kt">int</span> <span class="n">buckets</span><span class="o">,</span> <span class="kt">int</span> <span class="n">minutesToDie</span><span class="o">,</span> <span class="kt">int</span> <span class="n">minutesToTest</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">base</span> <span class="o">=</span> <span class="n">minutesToTest</span><span class="o">/</span><span class="n">minutesToDie</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span>		<span class="c1">// How many rounds can you perform?</span>
    <span class="k">return</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span><span class="nc">Math</span><span class="o">.</span><span class="na">ceil</span><span class="o">(</span><span class="nc">Math</span><span class="o">.</span><span class="na">log</span><span class="o">(</span><span class="n">buckets</span><span class="o">)/</span><span class="nc">Math</span><span class="o">.</span><span class="na">log</span><span class="o">(</span><span class="n">base</span><span class="o">));</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="find-pivot-index"><span class="me-2"><a href="https://leetcode.com/problems/find-pivot-index/">Find Pivot Index</a><a name="find-pivot-index"></a></span><a href="#find-pivot-index" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">int</span> <span class="nf">pivotIndex</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">leftSum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>		<span class="c1">// We will test each index as a pivot by sliding it -&gt;</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="nl">i:</span> <span class="n">nums</span><span class="o">)</span>				<span class="c1">// Precalculate the sum of the array</span>
        <span class="n">sum</span> <span class="o">+=</span> <span class="n">i</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>	<span class="c1">// Check if the sum of the leftSide of i is</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">leftSum</span> <span class="o">==</span> <span class="n">sum</span> <span class="o">-</span> <span class="n">leftSum</span> <span class="o">-</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">])</span>	<span class="c1">// equal to totalSum - leftSideSum - pivot</span>
            <span class="k">return</span> <span class="n">i</span><span class="o">;</span>							<span class="c1">// which is i. If so, return i.</span>
        <span class="n">leftSum</span> <span class="o">+=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>						<span class="c1">// Otherwise add nums[i] to the leftSum and</span>
    <span class="o">}</span>											<span class="c1">// slide pivot to the -&gt;.</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>								<span class="c1">// No pivot found. Return -1.</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="squares-of-a-sorted-array"><span class="me-2"><a href="https://leetcode.com/problems/squares-of-a-sorted-array/">Squares of a Sorted Array</a><a name="squares-of-a-sorted-array"></a></span><a href="#squares-of-a-sorted-array" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">sortedSquares</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="no">A</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="no">A</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>		<span class="c1">// Length of array A</span>
    <span class="kt">int</span> <span class="n">pivot</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>			<span class="c1">// Pivot is the index where values goes from -ve to +ve.</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">pivot</span> <span class="o">&lt;</span> <span class="n">len</span> <span class="o">&amp;&amp;</span> <span class="no">A</span><span class="o">[</span><span class="n">pivot</span><span class="o">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="c1">// While values are -ve.</span>
        <span class="o">++</span><span class="n">pivot</span><span class="o">;</span>			<span class="c1">// increment pivot. We exit when we find a positive.</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">squares</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">len</span><span class="o">];</span>	<span class="c1">// Result array</span>
    <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>			<span class="c1">// Keeps track of where to where to put elements in result array</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">pivot</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>			<span class="c1">// pivot = 0 means pivot didn't shift, there are only +ve values</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="nl">i:</span> <span class="no">A</span><span class="o">)</span>		<span class="c1">// So fill in the array with squares of numbers.</span>
            <span class="n">squares</span><span class="o">[</span><span class="n">index</span><span class="o">++]</span> <span class="o">=</span> <span class="n">i</span><span class="o">*</span><span class="n">i</span><span class="o">;</span>
    <span class="k">else</span><span class="o">{</span>					<span class="c1">// Otherwise we have a negative somewhere.</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="n">pivot</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span>	<span class="c1">// So we will compare values left and right of the pivot</span>
        <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">pivot</span><span class="o">;</span>	<span class="c1">// and whichever's smaller fills up the array first.</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">right</span> <span class="o">&lt;</span> <span class="n">len</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">lsquare</span> <span class="o">=</span> <span class="no">A</span><span class="o">[</span><span class="n">left</span><span class="o">]</span> <span class="o">*</span> <span class="no">A</span><span class="o">[</span><span class="n">left</span><span class="o">];</span>
            <span class="kt">int</span> <span class="n">rsquare</span> <span class="o">=</span> <span class="no">A</span><span class="o">[</span><span class="n">right</span><span class="o">]</span> <span class="o">*</span> <span class="no">A</span><span class="o">[</span><span class="n">right</span><span class="o">];</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">lsquare</span> <span class="o">&lt;</span> <span class="n">rsquare</span><span class="o">){</span>		<span class="c1">// left &lt; right, so add left square. decrement left</span>
                <span class="n">squares</span><span class="o">[</span><span class="n">index</span><span class="o">++]</span> <span class="o">=</span> <span class="n">lsquare</span><span class="o">;</span>
                <span class="o">--</span><span class="n">left</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">rsquare</span> <span class="o">&lt;</span> <span class="n">lsquare</span><span class="o">){</span>	<span class="c1">// right &lt; left, add right square and increment.</span>
                <span class="n">squares</span><span class="o">[</span><span class="n">index</span><span class="o">++]</span> <span class="o">=</span> <span class="n">rsquare</span><span class="o">;</span>
                <span class="o">++</span><span class="n">right</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">else</span><span class="o">{</span>
                <span class="n">squares</span><span class="o">[</span><span class="n">index</span><span class="o">++]</span> <span class="o">=</span> <span class="n">lsquare</span><span class="o">;</span>	<span class="c1">// both are equal. add both square and</span>
                <span class="n">squares</span><span class="o">[</span><span class="n">index</span><span class="o">++]</span> <span class="o">=</span> <span class="n">rsquare</span><span class="o">;</span>	<span class="c1">// decrement left, increment right.</span>
                <span class="o">--</span><span class="n">left</span><span class="o">;</span>						<span class="c1">// Continue doing this until we hit either end</span>
                <span class="o">++</span><span class="n">right</span><span class="o">;</span>					<span class="c1">// of the array.</span>
            <span class="o">}</span>								<span class="c1">// In the end we need to check if elements on</span>
        <span class="o">}</span>									<span class="c1">// either side are left to be filled in.</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span>					<span class="c1">// Left side elements remain, so fill their</span>
            <span class="n">squares</span><span class="o">[</span><span class="n">index</span><span class="o">++]</span> <span class="o">=</span> <span class="no">A</span><span class="o">[</span><span class="n">left</span><span class="o">]</span> <span class="o">*</span> <span class="no">A</span><span class="o">[</span><span class="n">left</span><span class="o">--];</span> <span class="c1">// squares one by one till none left.</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">right</span> <span class="o">&lt;</span> <span class="n">len</span><span class="o">)</span>					<span class="c1">// Right side elements remain, so fill their</span>
            <span class="n">squares</span><span class="o">[</span><span class="n">index</span><span class="o">++]</span> <span class="o">=</span> <span class="no">A</span><span class="o">[</span><span class="n">right</span><span class="o">]</span> <span class="o">*</span> <span class="no">A</span><span class="o">[</span><span class="n">right</span><span class="o">++];</span>	<span class="c1">// squares in</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">squares</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="repeated-substring-pattern"><span class="me-2"><a href="https://leetcode.com/problems/repeated-substring-pattern/submissions/">Repeated Substring Pattern</a><a name="repeated-substring-pattern"></a></span><a href="#repeated-substring-pattern" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>We use the <a href="https://www.geeksforgeeks.org/kmp-algorithm-for-pattern-searching/">KMP Algorithm</a> that allows us to match a string ‘s’ with another string ‘p’ to find the longest sequence of characters in ‘s’ that match ‘p’. We can use a Naive Pattern match where we start from the beginning of the string and start comparing the characters of ‘s’ with ‘p’. Initially, we keep the partition at index 0. If the character’s match, we move partition to the right by 1 till we get to the end of the string. If something doesn’t match, we don’t move the partition but look at the next character to match. In the end, wherever the partition is, that’s our longest length we could match with string ‘p’. The complexity of that is <i>O(len(p)(len(s)-len(p)+1))</i>.</p><p>KMP fixes it by skipping characters that we know already match. In this problem, we aren’t matching with any other string but itself. So, we start from index 1 of the string and compare it from the beginning. If they match, we increase j by 1, note it down in lps array and then increase i by 1 to check the next character. j basically measures the longest chain of characters we were able to match. If we couldn’t match character at index i and if streak was greater than 0, then our new streak becomes whatever it was in the previous round of matching characters. If the streak is 0, then we simply note down at index i in our lps array 0, meaning longest length measured upto index i was 0.</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">repeatedSubstringPattern</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">maxLength</span> <span class="o">=</span> <span class="n">lps</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">maxLength</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">%</span> <span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="n">maxLength</span><span class="o">)</span> <span class="o">==</span> <span class="mi">0</span><span class="o">;</span>
    <span class="o">}</span>

<span class="kd">private</span> <span class="kt">int</span> <span class="nf">lps</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">){</span>
    <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">lps</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">len</span><span class="o">];</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>		<span class="c1">// To match the string with itself.</span>
    <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="o">){</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">==</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">)){</span>	<span class="c1">// if the chars match</span>
            <span class="n">lps</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="o">++</span><span class="n">j</span><span class="o">;</span>					<span class="c1">// we record that # of matches at index i was</span>
            <span class="o">++</span><span class="n">i</span><span class="o">;</span>							<span class="c1">// 1+j and increment i to check next character</span>
        <span class="o">}</span>
        <span class="k">else</span><span class="o">{</span>								<span class="c1">// character did not match</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">j</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span>						<span class="c1">// If our matching streak &gt; 0</span>
                <span class="n">j</span> <span class="o">=</span> <span class="n">lps</span><span class="o">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">];</span>				<span class="c1">// our new streak becomes the previous round's streak</span>
            <span class="k">else</span>							<span class="c1">// Otherwise, streak is already 0.</span>
                <span class="n">lps</span><span class="o">[</span><span class="n">i</span><span class="o">++]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>				<span class="c1">// So we record that # of matches made at i is 0</span>
        <span class="o">}</span>									<span class="c1">// We increment i to check next index.</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">lps</span><span class="o">[</span><span class="n">len</span><span class="o">-</span><span class="mi">1</span><span class="o">];</span>						<span class="c1">// Longest prefix length that was also a suffix</span>
<span class="o">}</span>											<span class="c1">// is whatever was recorded at the end of array.</span>
</pre></table></code></div></div><h3 id="island-perimeter"><span class="me-2"><a href="https://leetcode.com/problems/island-perimeter/">Island Perimeter</a><a name="island-perimeter"></a></span><a href="#island-perimeter" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>The idea is simple. Count the number of cells with value 1 which denotes the land. Check towards the left and up to that cell and check if it shares any edge with another cell with value 1. If it does record that. In the end, the formula for perimeter is 4 * (the number of land cells) - 2 * (overlapping edges).</p><p><strong>Reasoning:</strong> Perimeter of a square is 4 times the length of it’s side. Here all squares are of length 1. So total perimeter is 4*(number of cells with value = 1). But we also need to account the edges that are common between two adjacent land cells. If one square shares an edge with another, we just lost one side from both the square, resulting in a loss of two sides. Therefore, we need to subtract twice the number of overlapping edges from the total perimeter to get the total perimeter.</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">int</span> <span class="nf">islandPerimeter</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">grid</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">land</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">overlap</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">row</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">row</span> <span class="o">&lt;</span> <span class="n">grid</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">row</span><span class="o">)</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">col</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">col</span> <span class="o">&lt;</span> <span class="n">grid</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">col</span><span class="o">){</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">grid</span><span class="o">[</span><span class="n">row</span><span class="o">][</span><span class="n">col</span><span class="o">]</span> <span class="o">==</span> <span class="mi">1</span><span class="o">){</span>
                <span class="o">++</span><span class="n">land</span><span class="o">;</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">row</span><span class="o">-</span><span class="mi">1</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">grid</span><span class="o">[</span><span class="n">row</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">col</span><span class="o">]</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span>	<span class="c1">// Check above the current cell.</span>
                    <span class="o">++</span><span class="n">overlap</span><span class="o">;</span>		<span class="c1">// If it's a land, we need to record one overlap.</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">col</span><span class="o">-</span><span class="mi">1</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">grid</span><span class="o">[</span><span class="n">row</span><span class="o">][</span><span class="n">col</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span>	<span class="c1">// Similarly, check to the left.</span>
                    <span class="o">++</span><span class="n">overlap</span><span class="o">;</span>		<span class="c1">// If it's a land, we need to increment overlap</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="k">return</span> <span class="mi">4</span><span class="o">*</span><span class="n">land</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">overlap</span><span class="o">;</span>		<span class="c1">// Check the reasoning above.</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="number-complement"><span class="me-2"><a href="https://leetcode.com/problems/number-complement/">Number Complement</a><a name="number-complement"></a></span><a href="#number-complement" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">int</span> <span class="nf">findComplement</span><span class="o">(</span><span class="kt">int</span> <span class="n">num</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">pow2</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>				<span class="c1">// Easily keep track of power of 2.</span>
    <span class="kt">int</span> <span class="n">comp</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>				<span class="c1">// Complement number</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">num</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">){</span>			<span class="c1">// Since num gets divided by 2, it will be 0 in the end.</span>
        <span class="kt">int</span> <span class="n">bit</span> <span class="o">=</span> <span class="n">num</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="o">;</span>	<span class="c1">// If bit is 0 then complement is 1 &amp; vice versa.</span>
        <span class="n">comp</span> <span class="o">+=</span> <span class="n">bit</span> <span class="o">*</span> <span class="n">pow2</span><span class="o">;</span>		<span class="c1">// Multiply it by the appropriate power of 2 and add to comp</span>
        <span class="n">pow2</span> <span class="o">*=</span> <span class="mi">2</span><span class="o">;</span>				<span class="c1">// Update power of 2 for next iteration.</span>
        <span class="n">num</span> <span class="o">/=</span> <span class="mi">2</span><span class="o">;</span>				<span class="c1">// Divide num by 2 to get the next bit.</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">comp</span><span class="o">;</span>				<span class="c1">// Comp is now the complement.</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="binary-watch"><span class="me-2"><a href="https://leetcode.com/problems/binary-watch/">Binary Watch</a><a name="binary-watch"></a></span><a href="#binary-watch" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>The idea is as follows. We have 10 lights. First 4 represent hours. Namely 1, 2, 4 and 8, which are the first four powers of 2. The next 6 lights, represent minutes. Those are 1, 2, 4, 8, 16 and 32. These are powers of 2 from 0-5. So if we iterate from 1 to 9, powers of numbers 1-3 gives us hours and powers of numbers 4-9 minus 4 gives us minutes. So, if we have, let’s say 2 lights, we need to find every combination of 2 lights. So in our helper function, we iterate from 1-9 to check every hour and minute combination. We also need to keep a track of the lights that we used, so we don’t use the same light again. If hours are &gt; 11 or minutes are &gt; 59, we have an invalid time and we can abort. If the number of lights are 0, that means we found a valid time and we should add it to the result. Now, if the lights are not 0, then we need to check every possible combination from the last light used to 9. If i &lt; 4, then we are looking at an hourly combination, otherwise it’s a minute combination. So we recurse with updated lights used, decrease the numOfLights since we used one, update respective hours or minutes until we hit base case.</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">result</span><span class="o">;</span>

<span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="nf">readBinaryWatch</span><span class="o">(</span><span class="kt">int</span> <span class="n">num</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
    <span class="n">helper</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">num</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kt">void</span> <span class="nf">helper</span><span class="o">(</span><span class="kt">int</span> <span class="n">lightsUsed</span><span class="o">,</span> <span class="kt">int</span> <span class="n">numOfLights</span><span class="o">,</span> <span class="kt">int</span> <span class="n">hrs</span><span class="o">,</span> <span class="kt">int</span> <span class="n">min</span><span class="o">){</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">hrs</span> <span class="o">&gt;</span> <span class="mi">11</span> <span class="o">||</span> <span class="n">min</span> <span class="o">&gt;</span> <span class="mi">59</span><span class="o">)</span>		<span class="c1">// Base case. Invalid time</span>
        <span class="k">return</span><span class="o">;</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">numOfLights</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>			<span class="c1">// All lights used, so add time to the list.</span>
        <span class="n">result</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">hrs</span> <span class="o">+</span> <span class="s">":"</span> <span class="o">+</span> <span class="o">(</span><span class="n">min</span> <span class="o">&lt;</span> <span class="mi">10</span> <span class="o">?</span> <span class="s">"0"</span> <span class="o">+</span> <span class="n">min</span> <span class="o">:</span> <span class="n">min</span><span class="o">));</span>
        <span class="k">return</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">lightsUsed</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>	<span class="c1">// Otherwise start recursing from number of prev</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="o">)</span>							<span class="c1">// light used. i &lt; 4 means hours</span>
            <span class="n">helper</span><span class="o">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">numOfLights</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="n">hrs</span> <span class="o">+</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span><span class="nc">Math</span><span class="o">.</span><span class="na">pow</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="n">i</span><span class="o">),</span> <span class="n">min</span><span class="o">);</span>
        <span class="k">else</span>								<span class="c1">// i = [4,9] means minute. So recurse.</span>
            <span class="n">helper</span><span class="o">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">numOfLights</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="n">hrs</span><span class="o">,</span> <span class="n">min</span> <span class="o">+</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span><span class="nc">Math</span><span class="o">.</span><span class="na">pow</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span><span class="n">i</span><span class="o">-</span><span class="mi">4</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="minimum-moves-to-equal-array-elements"><span class="me-2"><a href="https://leetcode.com/problems/minimum-moves-to-equal-array-elements/">Minimum Moves to Equal Array Elements</a><a name="minimum-moves-to-equal-array-elements"></a></span><a href="#minimum-moves-to-equal-array-elements" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>This was an interesting problem. But after working out a few examples by hand, you can notice that it is always a question of bringing the minimum element in par with everyone. So if you know the minimum of the array, we can check how many steps it will take to bring the minimum in par with other element by calculating the distance between them. For example,</p><blockquote><p>Let the array be [1,2,3]</p><p>We can observe that the minimum here is 1. Let us list down all steps to make all elements equal.</p><ol><li>[2,2,4], Keeping the second element fixed. Notice that distance between the element where 1 was and where 3 was is till the same.<li>[3,3,4], Keeping the last element fixed.<li>[4,4,4], Keeping last element fixed.</ol><p>Here, we first tried to make 1 equal to it’s neighbor, which required us 1 step. Now, once it becomes equal to 1, the problem is how to make the last element in the original array, which is 3 equal to 1. It requires 2 steps, resulting in a total of of 3. The reason is that the moment you decide to increment the minimum element to match the next element, you fix the neighboring element and have to increment everything else. This will make the minimum and its neighbor the same, but it will also keep the distance between the minimum and all other elements the same because we just incremented everything.</p><p>So, the total number of moves required is the distance between the elements of the array and the minimum.</p></blockquote><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">int</span> <span class="nf">minMoves</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">){</span>
    <span class="kt">int</span> <span class="n">min</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="nl">i:</span> <span class="n">nums</span><span class="o">)</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">min</span><span class="o">)</span>
            <span class="n">min</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">moves</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="nl">i:</span> <span class="n">nums</span><span class="o">)</span>
        <span class="n">moves</span> <span class="o">+=</span> <span class="n">i</span><span class="o">-</span><span class="n">min</span><span class="o">;</span>
    <span class="k">return</span> <span class="n">moves</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><blockquote><p>Now the above solution required two passes of the array. Can we do even better? Notice that in the end, all we are doing is finding the min and subtracting min from all the elements in the array. That means we are subtracting min <em>n</em> times where n is the length of the array. Why <em>n</em> times? Because there are <em>n</em> elements in the array. Shouldn’t it be <em>(n-1)</em> times? No, because the distance of the min from min is 0. So we need to subtract min from itself too, so <em>n</em> times. We can achieve this by first calculating the total of the array while simultaneously keeping track of the minimum. Once done, all we need to do is subtract min <em>n</em> times from the sum, which is equivalent to subtracting min from each element. This results in a much overall better algorithm, requiring only 1 pass of the array.</p></blockquote><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">int</span> <span class="nf">minMoves</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">min</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="nl">i:</span> <span class="n">nums</span><span class="o">){</span>
        <span class="n">sum</span> <span class="o">+=</span> <span class="n">i</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">min</span><span class="o">)</span>
            <span class="n">min</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">sum</span> <span class="o">-</span> <span class="n">min</span><span class="o">*</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="license-key-formatting"><span class="me-2"><a href="https://leetcode.com/problems/license-key-formatting/">License Key Formatting</a><a name="license-key-formatting"></a></span><a href="#license-key-formatting" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>The idea is simple.</p><ol><li>I maintain a temporary array <em>s</em> that contains only the characters in string <em>S</em> after converting them to uppercase.<li>I maintain a variable <em>length</em> that counts how many characters I found in the string <em>S</em>. If length is 0, that means it contains only dashes (-).<li>Then I record the <em>offset</em>. <em>Offset</em> basically measures how many characters of the String <em>S</em> will be grouped unevenly in the beginning part of the string. I can check that by using the modulus operator and finding out the remainder. That many characters (of <em>length &lt; K</em>) will be in the beginning part of the string.<li>Next step is to calculate how many dashes I will need. It’s basically <em>length / K</em>.<li>Then I create the char array that will hold the characters of the formatted key. It’s length will be number of characters + the dashes we will need. We need to take care of a special case here. If the <em>offset</em> is 0, meaning I was able to divide characters in equal group, I need to subtract 1. Eg, let’s say we had 8 characters and <em>K</em> was 4. dashes = 8 / 4 = 2. We can divide 8 characters equally into 2 groups using only 1 dash. But since dashes was 2, it is clearly off by 1. This is the case when <em>offset</em> is 0.<li><em>kIndex</em> tracks where character is to be inserted in the key array.<li><em>used</em> tracks how many characters of the array <em>s</em>, which indirectly holds the characters of String <em>S</em>, are used.<li>First I copy down the characters of length <em>offset</em>. Because those are the ones of uneven length. <em>kIndex</em> and <em>used</em> variables are updated.<li>Last thing to do is to use all the remaining characters in array <em>s</em>, but we take <em>K</em> characters at a time, because we know that the segments are going to be of equal length. We also need to insert ‘-‘ after each segment, but only if <em>kIndex</em> is not at the beginning or at the end of the key array, because inserting it at those points is invalid.<li>Create a new string and return it.</ol><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="nc">String</span> <span class="nf">licenseKeyFormatting</span><span class="o">(</span><span class="nc">String</span> <span class="no">S</span><span class="o">,</span> <span class="kt">int</span> <span class="no">K</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">char</span><span class="o">[]</span> <span class="n">s</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="o">[</span><span class="no">S</span><span class="o">.</span><span class="na">length</span><span class="o">()];</span>
    <span class="kt">int</span> <span class="n">length</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="nl">c:</span> <span class="no">S</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">())</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">c</span> <span class="o">!=</span> <span class="sc">'-'</span><span class="o">)</span>
        <span class="n">s</span><span class="o">[</span><span class="n">length</span><span class="o">++]</span> <span class="o">=</span> <span class="nc">Character</span><span class="o">.</span><span class="na">toUpperCase</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
        <span class="k">return</span> <span class="s">""</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">length</span> <span class="o">%</span> <span class="no">K</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">dashes</span> <span class="o">=</span> <span class="n">length</span> <span class="o">/</span> <span class="no">K</span><span class="o">;</span> 
    <span class="kt">char</span><span class="o">[]</span> <span class="n">key</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="o">[</span><span class="n">length</span> <span class="o">+</span> <span class="n">dashes</span> <span class="o">+</span> <span class="o">(</span><span class="n">offset</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="o">)];</span>
    <span class="kt">int</span> <span class="n">kIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">used</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">used</span> <span class="o">&lt;</span> <span class="n">offset</span><span class="o">)</span>
      <span class="n">key</span><span class="o">[</span><span class="n">kIndex</span><span class="o">++]</span> <span class="o">=</span> <span class="n">s</span><span class="o">[</span><span class="n">used</span><span class="o">++];</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">used</span> <span class="o">&lt;</span> <span class="n">index</span><span class="o">){</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">kIndex</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">kIndex</span> <span class="o">&lt;</span> <span class="n">key</span><span class="o">.</span><span class="na">length</span><span class="o">)</span>
        <span class="n">key</span><span class="o">[</span><span class="n">kIndex</span><span class="o">++]</span> <span class="o">=</span> <span class="sc">'-'</span><span class="o">;</span>
      <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="no">K</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span>
        <span class="n">key</span><span class="o">[</span><span class="n">kIndex</span><span class="o">++]</span> <span class="o">=</span> <span class="n">s</span><span class="o">[</span><span class="n">used</span><span class="o">++];</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nf">String</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="max-consecutive-ones"><span class="me-2"><a href="https://leetcode.com/problems/max-consecutive-ones/">Max Consecutive Ones</a><a name="max-consecutive-ones"></a></span><a href="#max-consecutive-ones" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Solution 1: I came up with this solution initially. 4 ms runtime and passes 99.97% submissions.</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">int</span> <span class="nf">findMaxConsecutiveOnes</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>					<span class="c1">// Keep track of start of a streak, if any</span>
    <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>					<span class="c1">// max length of the streak</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">start</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">){</span>	<span class="c1">// While we are not at the end of the array</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">start</span><span class="o">]</span> <span class="o">==</span> <span class="mi">1</span><span class="o">){</span>		<span class="c1">// Check if we have a 1 at start, if so</span>
            <span class="kt">int</span> <span class="n">streak</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>			<span class="c1">// initialize streak and check how long can we continue</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">start</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">start</span><span class="o">]</span> <span class="o">==</span> <span class="mi">1</span><span class="o">){</span>	<span class="c1">// that streak.</span>
                <span class="o">++</span><span class="n">streak</span><span class="o">;</span>			<span class="c1">// Increment streak and left for each consecutive 1</span>
                <span class="o">++</span><span class="n">start</span><span class="o">;</span>			<span class="c1">// make sure you don't forget that start &lt; nums.length</span>
            <span class="o">}</span>						<span class="c1">// before checking nums[start] to prevent out-of-bounds</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">streak</span> <span class="o">&gt;</span> <span class="n">max</span><span class="o">)</span>		<span class="c1">// Check if the current streak is better than the</span>
                <span class="n">max</span> <span class="o">=</span> <span class="n">streak</span><span class="o">;</span>		<span class="c1">// previous streak.</span>
        <span class="o">}</span>
        <span class="o">++</span><span class="n">start</span><span class="o">;</span>					<span class="c1">// Increment start in either case to check for new</span>
    <span class="o">}</span>								<span class="c1">// streaks.</span>
    <span class="k">return</span> <span class="n">max</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><p>Solution 2: After analyzing the problem further, I noticed that 0 denotes the end of a streak. If we observe 1, we increment streak by 1. But if I see a 0, I reset my streak to 0. This solution too had a 4 ms runtime and passed 99.97% submissions.</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">int</span> <span class="nf">findMaxConsecutiveOnes</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>				<span class="c1">// Global max streak</span>
    <span class="kt">int</span> <span class="n">streak</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>				<span class="c1">// Local max streak.</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="nl">i:</span> <span class="n">nums</span><span class="o">){</span>			<span class="c1">// For each number in nums</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="o">){</span>			<span class="c1">// If we see a 1</span>
            <span class="o">++</span><span class="n">streak</span><span class="o">;</span>			<span class="c1">// increment our ongoing streak.</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">streak</span> <span class="o">&gt;</span> <span class="n">max</span><span class="o">)</span>	<span class="c1">// If the local streak &gt; global max</span>
                <span class="n">max</span> <span class="o">=</span> <span class="n">streak</span><span class="o">;</span>	<span class="c1">// update global max streak.</span>
        <span class="o">}</span>
        <span class="k">else</span>					<span class="c1">// otherwise we just saw a 0.</span>
            <span class="n">streak</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>			<span class="c1">// So our streak resets to 0.</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">max</span><span class="o">;</span>					<span class="c1">// return the global max streak.</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="permutations"><span class="me-2"><a href="https://leetcode.com/problems/permutations/">Permutations</a><a name="permutations"></a></span><a href="#permutations" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>The idea is as follows. Given an array a = {1,2,3}, we want to generate all it’s possible combinations. What we are trying to do here is that we first take the element at index 0, and find permutations of the remaining thing. When we do that, we insert the element at index 0 in front of the list to get 1 permutation. Similarly, we then take the element at index 1, and permute the remaining contents of the array and insert the element at index 1 in the beginning of the array to get another permutation and so on. In this problem, we are asked to return a list of list, so we first copy the numbers of the array into an ArrayList. Let’s run this code for the above example.</p><blockquote><p>Given nums = {1,2,3}, our ArrayList will be the same, al = [1,2,3]. Our result list is empty, result = [] and index = 0.</p><p><strong>helper([1,2,3], 0)</strong></p><blockquote><p>swap (0, 0) → al = [1,2,3]</p><p><strong>helper(1,2,3, 1)</strong></p><blockquote><p>swap(1, 1) → al = [1,2,3]</p><p><strong>helper([1,2,3], 2)</strong></p><blockquote><p>swap(2, 2) → [1,2,3]</p><p><strong>helper([1,2,3], 3)</strong></p><blockquote><p>We update our result list now, because index == length. Therefore, result = [[1,2,3]]. Our recursive stack collapses and we move on to the next instruction, which is undo the step, al = [1,2,3].</p></blockquote></blockquote><p>swap(1, 2) → al = [1,3,2]</p><p><strong>helper([1,3,2], 3)</strong></p><blockquote><p>Again, index == length, add it to the list. result = [[1,2,3], [1,3,2]]. Recursion stack collapses, we undo the swap, al = [1,2,3]</p></blockquote></blockquote><p>swap(0, 1) → al = [2,1,3]</p><p><strong>helper([2,1,3], 1)</strong></p><blockquote><p>swap(1,1) → al = [2,1,3]</p><p><strong>helper([2,1,3], 2)</strong></p><blockquote><p>swap(2, 2) → al = [2,1,3]</p><p><strong>helper([2,1,3], 3)</strong></p><blockquote><p>index == length, add the current order to the list. result = [[1,2,3], [1,3,2], [2,1,3]]</p></blockquote></blockquote><p>swap(1, 2) → al = [2,3,1]</p><p><strong>helper([2,3,1], 3)</strong></p><blockquote><p>index == length, add the order to the list. Result = [[1,2,3], [1,3,2], [2,1,3], [2,3,1]]</p></blockquote></blockquote><p>swap(0, 2) → al = [3,2,1]</p><p><strong>helper([3,2,1], 2)</strong></p><blockquote><p>swap(2,2) → al = [3,2,1]</p><p><strong>helper([3,2,1], 3)</strong></p><blockquote><p>index == length, add the order to the list. Result = [[1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,2,1]]</p></blockquote></blockquote><p>swap(1,2) → al = [3,1,2]</p><p><strong>helper([3,1,2], 3)</strong></p><blockquote><p>index == length, add the order to the list. Result = [[1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,2,1], [3,1,2]]</p></blockquote></blockquote><p>All branches have been explored now, since the iteration ends and we return the result list.</p></blockquote><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="n">len</span><span class="o">;</span>						<span class="c1">// To store the length of the input array</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">result</span><span class="o">;</span>		<span class="c1">// Result list</span>

<span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="nf">permute</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">numList</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>	<span class="c1">// Creating a copy of the nums array</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="nl">i:</span> <span class="n">nums</span><span class="o">)</span>			<span class="c1">// because it's easier to create a list from a list.</span>
        <span class="n">numList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>			<span class="c1">// Add everything to the list.</span>
    <span class="n">len</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
    <span class="n">helper</span><span class="o">(</span><span class="n">numList</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>			<span class="c1">// Call the aux function.</span>
    <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kt">void</span> <span class="nf">helper</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">order</span><span class="o">,</span> <span class="kt">int</span> <span class="n">index</span><span class="o">){</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">index</span> <span class="o">==</span> <span class="n">len</span><span class="o">)</span>			<span class="c1">// If we have checked all the numbers in the array, add a</span>
        <span class="n">result</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;(</span><span class="n">order</span><span class="o">));</span>	<span class="c1">// clone of the list to the array.</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">index</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>	<span class="c1">// Otherwise from index to the end of the array,</span>
        <span class="n">swap</span><span class="o">(</span><span class="n">order</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">index</span><span class="o">);</span>	<span class="c1">// take one element, swap it with itself, then the next and</span>
        <span class="n">helper</span><span class="o">(</span><span class="n">order</span><span class="o">,</span> <span class="n">index</span><span class="o">+</span><span class="mi">1</span><span class="o">);</span>	<span class="c1">// so on. Recurse again, but on the next index we just swapped.</span>
        <span class="n">swap</span><span class="o">(</span><span class="n">order</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">index</span><span class="o">);</span>	<span class="c1">// Undo the swap so that it helps us in generating the next</span>
    <span class="o">}</span>							<span class="c1">// permutation.</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kt">void</span> <span class="nf">swap</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">,</span> <span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">j</span><span class="o">){</span>	<span class="c1">// Swap elements in a list.</span>
    <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
    <span class="n">list</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">j</span><span class="o">));</span>
    <span class="n">list</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">j</span><span class="o">,</span> <span class="n">temp</span><span class="o">);</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="construct-the-rectangle"><span class="me-2"><a href="https://leetcode.com/problems/construct-the-rectangle/">Construct the Rectangle</a><a name="construct-the-rectangle"></a></span><a href="#construct-the-rectangle" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>The idea is very simple. We just need to iterate from width = sqrt(area) to 1 and check if area is perfectly divisible by width. If at any point, width is divisible, then that must be our minimum difference length and width, because we are diverging from the center on both sides. Width decreases while length keeps increasing. Think of it like this, for area = 24, we have many factors of 24, namely 1, 2, 3,4, 6, 8, 12, 24. It’s sqrt when rounded down is 4. So we check for width = 4, is 24 perfectly divisible by 4? Yes, so divide it and whatever you get is going to be the minimal difference values. Suppose 4 and 6 weren’t the factors for 24. In that case we decrease width by 1, which is 3. Check again, is 24 divisible by 3. Yes? Then that must be our answer. We are diverging away from the center on both sides equally, width to the left towards 1 and length to the right towards area . Therefore the moment we find one value that divides area perfectly, that’s our required values.</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">constructRectangle</span><span class="o">(</span><span class="kt">int</span> <span class="n">area</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">dimensions</span> <span class="o">=</span> <span class="o">{</span><span class="n">area</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>		<span class="c1">// We know that if nothing works out, n*1 is always</span>
    <span class="kt">boolean</span> <span class="n">done</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>				<span class="c1">// going to be the answer</span>
    <span class="kt">int</span> <span class="n">width</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span><span class="nc">Math</span><span class="o">.</span><span class="na">sqrt</span><span class="o">(</span><span class="n">area</span><span class="o">);</span>	<span class="c1">// We only need to check width from sqrt(area)</span>
    <span class="k">while</span> <span class="o">(!</span><span class="n">done</span><span class="o">){</span>						<span class="c1">// While not done</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">area</span> <span class="o">%</span> <span class="n">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>		<span class="c1">// check if area is perfectly divisible by width</span>
            <span class="n">dimensions</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">width</span><span class="o">;</span>		<span class="c1">// if so, we found our width and the length.</span>
            <span class="n">dimensions</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">area</span><span class="o">/</span><span class="n">width</span><span class="o">;</span>
            <span class="n">done</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>				<span class="c1">// mark done as false</span>
        <span class="o">}</span>
        <span class="o">--</span><span class="n">width</span><span class="o">;</span>						<span class="c1">// otherwise decrease the length</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">dimensions</span><span class="o">;</span>					<span class="c1">// return the dimensions found.</span>
</pre></table></code></div></div><h3 id="merge-intervals"><span class="me-2"><a href="https://leetcode.com/problems/merge-intervals/">Merge Intervals</a><a name="merge-intervals"></a></span><a href="#merge-intervals" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Interval</span><span class="o">&gt;</span> <span class="nf">merge</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Interval</span><span class="o">&gt;</span> <span class="n">intervals</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">intervals</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">intervals</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="o">)</span>
        <span class="k">return</span> <span class="n">intervals</span><span class="o">;</span>
    <span class="nc">Collections</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">intervals</span><span class="o">,</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">.</span><span class="na">start</span><span class="o">-</span><span class="n">b</span><span class="o">.</span><span class="na">start</span><span class="o">);</span>	<span class="c1">// Sort the list so we can </span>
													<span class="c1">// compare adjacent intervals.</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Interval</span><span class="o">&gt;</span> <span class="n">merged</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
    <span class="n">merged</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">intervals</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">));</span>					<span class="c1">// Add the initial interval.</span>

    <span class="k">for</span> <span class="o">(</span><span class="nc">Interval</span> <span class="nl">i:</span> <span class="n">intervals</span><span class="o">){</span>					<span class="c1">// For each interval</span>
        <span class="nc">Interval</span> <span class="n">last</span> <span class="o">=</span> <span class="n">merged</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">merged</span><span class="o">.</span><span class="na">size</span><span class="o">()-</span><span class="mi">1</span><span class="o">);</span><span class="c1">// Get the last added time.</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">i</span><span class="o">.</span><span class="na">start</span> <span class="o">&gt;</span> <span class="n">last</span><span class="o">.</span><span class="na">end</span><span class="o">)</span>						<span class="c1">// If it's time is greater than the last</span>
            <span class="n">merged</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>							<span class="c1">// interval's end, it doesn't overlap</span>
        <span class="k">else</span><span class="o">{</span>										<span class="c1">// otherwise it does.</span>
            <span class="n">last</span><span class="o">.</span><span class="na">end</span> <span class="o">=</span> <span class="n">last</span><span class="o">.</span><span class="na">end</span> <span class="o">&gt;</span> <span class="n">i</span><span class="o">.</span><span class="na">end</span> <span class="o">?</span> <span class="n">last</span><span class="o">.</span><span class="na">end</span> <span class="o">:</span> <span class="n">i</span><span class="o">.</span><span class="na">end</span><span class="o">;</span>	<span class="c1">// So check which has greater end time, and make the last added interval's time equals that</span>
            <span class="n">merged</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">merged</span><span class="o">.</span><span class="na">size</span><span class="o">()-</span><span class="mi">1</span><span class="o">,</span> <span class="n">last</span><span class="o">);</span>		<span class="c1">// And set it as the last added interval</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="n">merged</span><span class="o">;</span>									<span class="c1">// Return the merged list.</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="merged-sorted-lists"><span class="me-2"><a href="https://leetcode.com/problems/merge-sorted-array/">Merged sorted lists</a><a name="merged-sorted-lists"></a></span><a href="#merged-sorted-lists" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ol><li>counterA keeps track of which element we are looking at in array ‘a’. Same with counterB<li>counterK keeps track of where to insert the element in array ‘a’, since a has enough space. The problem states that it might have more than enough space, so we use only the spaces we need, which is the total of both their sizes. Since indexing in an array is 0-based, we subtract 1.<li>We insert elements from the end, since the end part of ‘a’ is empty. We can insert from the front, but then we would need to shift elements to the right after each insertion from ‘b’.<li>If array values are equal, add them to the end, and decrease both their counter to check new values in the next iteration<li>If not equal, then check which one is greater, since the last part of the array should contain larger values. Whichever’s greater, put it in ‘a’ at index ‘counterA’ and decrement the respective counter.<li>In the end, we might have some leftover elements either from ‘a’ or ‘b’ because we only process elements that are equal to the <strong>min(size(a), size(b))</strong>, until we run out of elements in one of the array. So, whichever array has elements pending, add it to the front of the array and return a.</ol><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">merge</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">sizeA</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">b</span><span class="o">,</span> <span class="kt">int</span> <span class="n">sizeB</span><span class="o">)</span>
<span class="o">{</span>
    <span class="kt">int</span> <span class="n">counterA</span> <span class="o">=</span> <span class="n">sizeA</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="n">counterB</span> <span class="o">=</span> <span class="n">sizeB</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="n">counterK</span> <span class="o">=</span> <span class="n">sizeA</span><span class="o">+</span><span class="n">sizeB</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">counterA</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">counterB</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="o">){</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="n">counterA</span><span class="o">]</span> <span class="o">==</span> <span class="n">b</span><span class="o">[</span><span class="n">counterB</span><span class="o">]){</span>
            <span class="n">a</span><span class="o">[</span><span class="n">counterK</span><span class="o">--]</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">counterA</span><span class="o">--];</span>
            <span class="n">a</span><span class="o">[</span><span class="n">counterK</span><span class="o">--]</span> <span class="o">=</span> <span class="n">b</span><span class="o">[</span><span class="n">counterB</span><span class="o">--];</span>
        <span class="o">}</span>
        <span class="k">else</span>
            <span class="n">a</span><span class="o">[</span><span class="n">counterK</span><span class="o">--]</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">counterA</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">b</span><span class="o">[</span><span class="n">counterB</span><span class="o">]</span> <span class="o">?</span> <span class="n">a</span><span class="o">[</span><span class="n">counterA</span><span class="o">--]</span> <span class="o">:</span> <span class="n">b</span><span class="o">[</span><span class="n">counterB</span><span class="o">--];</span>
    <span class="o">}</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">counterA</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span>
        <span class="n">a</span><span class="o">[</span><span class="n">counterK</span><span class="o">--]</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">counterA</span><span class="o">--];</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">counterB</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span>
        <span class="n">a</span><span class="o">[</span><span class="n">counterK</span><span class="o">--]</span> <span class="o">=</span> <span class="n">b</span><span class="o">[</span><span class="n">counterB</span><span class="o">--];</span>
    <span class="k">return</span> <span class="n">a</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="next-greater-element-i"><span class="me-2"><a href="https://leetcode.com/problems/next-greater-element-i/">Next Greater Element I</a><a name="next-greater-element-i"></a></span><a href="#next-greater-element-i" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">nextGreaterElement</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">HashMap</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">index</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>	<span class="c1">// We use the hashmap to keep a</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums2</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span>				<span class="c1">// track of the index of each value</span>
        <span class="n">index</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">nums2</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">i</span><span class="o">);</span>							<span class="c1">// in nums 2. That way, when we want</span>
								<span class="c1">// to look for a value greater than a val in nums1, we know</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">nums1</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>	<span class="c1">// which index to start iterating from.</span>

    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums1</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>	<span class="c1">// So for each val in nums1</span>
        <span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="n">nums1</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">val</span><span class="o">);</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">nums2</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>	<span class="c1">// Iterate from that value's</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">nums2</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">val</span><span class="o">){</span>			<span class="c1">// index in nums2 to the end, and see if you can</span>
                <span class="n">result</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums2</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>		<span class="c1">// find any val &gt; nums1[i]. If you do, save it</span>
                <span class="k">break</span><span class="o">;</span>						<span class="c1">// in the result array and break the loop.</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">result</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>		<span class="c1">// Now if we didn't find any value, then result[i] would be</span>
            <span class="n">result</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>		<span class="c1">// 0, so we set that index to -1 in our result array.</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">result</span><span class="o">;</span>				<span class="c1">// simply return the result array.</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="string-without-aaa-or-bbb"><span class="me-2"><a href="https://leetcode.com/problems/string-without-aaa-or-bbb/">String Without AAA or BBB</a><a name="string-without-aaa-or-bbb"></a></span><a href="#string-without-aaa-or-bbb" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="nc">String</span> <span class="nf">strWithout3a3b</span><span class="o">(</span><span class="kt">int</span> <span class="no">A</span><span class="o">,</span> <span class="kt">int</span> <span class="no">B</span><span class="o">)</span> <span class="o">{</span>				
    <span class="kt">char</span><span class="o">[]</span> <span class="n">ch</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="o">[</span><span class="no">A</span><span class="o">+</span><span class="no">B</span><span class="o">];</span>		<span class="c1">// We create an char array to store string chars</span>
    <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="kt">char</span> <span class="n">max</span> <span class="o">=</span> <span class="no">A</span> <span class="o">&gt;</span> <span class="no">B</span> <span class="o">?</span> <span class="sc">'a'</span> <span class="o">:</span> <span class="sc">'b'</span><span class="o">;</span>	<span class="c1">// record the most frequent occurring element</span>
    <span class="kt">char</span> <span class="n">min</span> <span class="o">=</span> <span class="n">max</span> <span class="o">==</span> <span class="sc">'a'</span> <span class="o">?</span> <span class="sc">'b'</span> <span class="o">:</span> <span class="sc">'a'</span><span class="o">;</span>	<span class="c1">// and the least frequent occurring element</span>
    <span class="k">while</span> <span class="o">(</span><span class="no">A</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="no">B</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">){</span>			<span class="c1">// While we haven't added all of the elements</span>
    <span class="c1">// We check that if our current index &gt; 1 and our previoud two characters in the array</span>
    <span class="c1">// are the same, then we must have written the max occurring char, so it's time to write</span>
    <span class="c1">// the minimum occurring element. We write it, and then decrement the specific A or B.</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">index</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">max</span> <span class="o">==</span> <span class="n">ch</span><span class="o">[</span><span class="n">index</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="n">max</span> <span class="o">==</span> <span class="n">ch</span><span class="o">[</span><span class="n">index</span><span class="o">-</span><span class="mi">2</span><span class="o">]){</span>
            <span class="n">ch</span><span class="o">[</span><span class="n">index</span><span class="o">++]</span> <span class="o">=</span> <span class="n">min</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">min</span> <span class="o">==</span> <span class="sc">'a'</span><span class="o">)</span>		<span class="c1">// If the minimum freq element is 'a', decrement A</span>
                <span class="no">A</span><span class="o">--;</span>
            <span class="k">else</span>
                <span class="no">B</span><span class="o">--;</span>			<span class="c1">// otherwise decrement B</span>
        <span class="o">}</span>
        <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="no">B</span> <span class="o">&gt;</span> <span class="no">A</span><span class="o">){</span>		<span class="c1">// Otherwise, if B occurs more than A, then set char to B</span>
            <span class="n">ch</span><span class="o">[</span><span class="n">index</span><span class="o">++]</span> <span class="o">=</span> <span class="sc">'b'</span><span class="o">;</span>	<span class="c1">// decrement B and increment index</span>
            <span class="no">B</span><span class="o">--;</span>
        <span class="o">}</span>
        <span class="k">else</span><span class="o">{</span>					<span class="c1">// A occurs more, so add A to the char array.</span>
            <span class="n">ch</span><span class="o">[</span><span class="n">index</span><span class="o">++]</span> <span class="o">=</span> <span class="sc">'a'</span><span class="o">;</span>	<span class="c1">// Increment index, decrement A count</span>
            <span class="no">A</span><span class="o">--;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="k">new</span> <span class="nf">String</span><span class="o">(</span><span class="n">ch</span><span class="o">);</span>		<span class="c1">// Create a string from the char array and return it.</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="keyboard-row"><span class="me-2"><a href="https://leetcode.com/problems/keyboard-row/">Keyboard Row</a><a name="keyboard-row"></a></span><a href="#keyboard-row" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="c1">// Maps each character to the row in the keyboard in which it occurs.</span>
<span class="kd">private</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">map</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">3</span><span class="o">};</span>

<span class="kd">public</span> <span class="nc">String</span><span class="o">[]</span> <span class="nf">findWords</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">words</span><span class="o">)</span> <span class="o">{</span>

    <span class="nc">String</span><span class="o">[]</span> <span class="n">w</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">[</span><span class="n">words</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>	<span class="c1">// Store filtered words</span>
    <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>							<span class="c1">// Where to insert the filtered words</span>
    <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="nl">s:</span> <span class="n">words</span><span class="o">)</span>					<span class="c1">// for each word in words</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">checkWord</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">toLowerCase</span><span class="o">()))</span>		<span class="c1">// convert it to lowercase and check if all char</span>
            <span class="n">w</span><span class="o">[</span><span class="n">index</span><span class="o">++]</span> <span class="o">=</span> <span class="n">s</span><span class="o">;</span>					<span class="c1">// occurs in the same row, if it does, add it</span>
    <span class="k">return</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">copyOfRange</span><span class="o">(</span><span class="n">w</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">index</span><span class="o">);</span>	<span class="c1">// Simply return a copy of the array from 0</span>
<span class="o">}</span>											<span class="c1">// index</span>

<span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">checkWord</span><span class="o">(</span><span class="nc">String</span> <span class="n">word</span><span class="o">){</span>		<span class="c1">// Check if all chars in the word belong in the</span>
    <span class="kt">int</span> <span class="n">row</span> <span class="o">=</span> <span class="n">map</span><span class="o">[</span><span class="n">word</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="mi">0</span><span class="o">)-</span><span class="sc">'a'</span><span class="o">];</span>		<span class="c1">// same row. Check first chars row</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="nl">c:</span> <span class="n">word</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">()){</span>		<span class="c1">// For all the chars in the word</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">map</span><span class="o">[</span><span class="n">c</span><span class="o">-</span><span class="sc">'a'</span><span class="o">]</span> <span class="o">!=</span> <span class="n">row</span><span class="o">)</span>				<span class="c1">// if that char belongs to a different row,</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>					<span class="c1">// return false</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>							<span class="c1">// All chars in same row, return true.</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="find-mode-in-binary-search-tree"><span class="me-2"><a href="https://leetcode.com/problems/find-mode-in-binary-search-tree/">Find Mode in Binary Search Tree</a><a name="find-mode-in-binary-search-tree"></a></span><a href="#find-mode-in-binary-search-tree" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
</pre><td class="rouge-code"><pre><span class="kd">private</span> <span class="nc">TreeNode</span> <span class="n">parent</span><span class="o">;</span>		<span class="c1">// Keep track of parent at each node</span>
<span class="kd">private</span> <span class="kt">int</span> <span class="n">maxMode</span><span class="o">;</span>			<span class="c1">// maxMode we found</span>
<span class="kd">private</span> <span class="kt">int</span> <span class="n">currentMode</span><span class="o">;</span>		<span class="c1">// mode recorded at each node</span>
<span class="kd">private</span> <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">modes</span><span class="o">;</span>		<span class="c1">// keep distinct modes found</span>

<span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">findMode</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">){</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>			<span class="c1">// node is null, so return empty array</span>
        <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
    <span class="n">maxMode</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>				<span class="c1">// we have just seen the root, so maxMode so far is 1.</span>
    <span class="n">currentMode</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>			<span class="c1">// so is the current mode</span>
    <span class="n">modes</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>
    <span class="n">modes</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>		<span class="c1">// add the root to our modes set</span>
    <span class="n">traverse</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>				<span class="c1">// start traversing it's left and right branches</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">modes</span><span class="o">.</span><span class="na">size</span><span class="o">()];</span>	<span class="c1">// We have found all the modes</span>
    <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>				<span class="c1">// keep track of where to insert elements in result array</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="nl">i:</span> <span class="n">modes</span><span class="o">)</span>			<span class="c1">// add all the distinct modes one by one</span>
        <span class="n">result</span><span class="o">[</span><span class="n">idx</span><span class="o">++]</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
    <span class="k">return</span> <span class="n">result</span><span class="o">;</span>				<span class="c1">// and return it.</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kt">void</span> <span class="nf">traverse</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">node</span><span class="o">){</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">node</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>			<span class="c1">// if node is null, stop</span>
        <span class="k">return</span><span class="o">;</span>					<span class="c1">// otherwise traverse the left branch</span>
    <span class="n">traverse</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>		<span class="c1">// Once we hit the null, we start backtracking to the leaf</span>
    <span class="n">updateMode</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>			<span class="c1">// then we call updateMode with the node</span>
    <span class="n">parent</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span>				<span class="c1">// once it's done, we update parent as the current node, so </span>
    <span class="n">traverse</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>		<span class="c1">// when we backtrack, we can easily check that node and it's</span>
<span class="o">}</span>								<span class="c1">// next node's value for similarity. Then traverse right.</span>

<span class="kd">private</span> <span class="kt">void</span> <span class="nf">updateMode</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">node</span><span class="o">){</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">parent</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">parent</span><span class="o">.</span><span class="na">val</span> <span class="o">==</span> <span class="n">node</span><span class="o">.</span><span class="na">val</span><span class="o">){</span>	<span class="c1">// If parent node isn't null and the</span>
        <span class="o">++</span><span class="n">currentMode</span><span class="o">;</span>			<span class="c1">// node's value is the same as parent, we update currentMode</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">currentMode</span> <span class="o">&gt;=</span> <span class="n">maxMode</span><span class="o">){</span>	<span class="c1">// If the currentMode is greater or equal to maxMode</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">currentMode</span> <span class="o">&gt;</span> <span class="n">maxMode</span><span class="o">)</span>	<span class="c1">// just check if it's greater. If it is, remove all </span>
                <span class="n">modes</span><span class="o">.</span><span class="na">clear</span><span class="o">();</span>			<span class="c1">// previously recorded modes</span>
            <span class="n">modes</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>		<span class="c1">// Add the current node to the set and update the </span>
            <span class="n">maxMode</span> <span class="o">=</span> <span class="n">currentMode</span><span class="o">;</span>		<span class="c1">// maxMode</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">else</span><span class="o">{</span>						<span class="c1">// otherwise, value's aren't the same. so our currentMode</span>
        <span class="n">currentMode</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>		<span class="c1">// becomes 1. If maxMode is also 1, then all we have been </span>
        <span class="k">if</span> <span class="o">(</span><span class="n">maxMode</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span>		<span class="c1">// seeing are distinct values, so add that node's value to</span>
            <span class="n">modes</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">val</span><span class="o">);</span><span class="c1">// to the mode's set.</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="base-7"><span class="me-2"><a href="https://leetcode.com/problems/base-7/">Base 7</a><a name="base-7"></a></span><a href="#base-7" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Solution 1 without StringBuilder (Beats 100%, 7ms)</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre>    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">convertToBase7</span><span class="o">(</span><span class="kt">int</span> <span class="n">num</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">num</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
            <span class="k">return</span> <span class="s">"0"</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)(</span><span class="nc">Math</span><span class="o">.</span><span class="na">log</span><span class="o">(</span><span class="nc">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">num</span><span class="o">))/</span><span class="nc">Math</span><span class="o">.</span><span class="na">log</span><span class="o">(</span><span class="mi">7</span><span class="o">))+</span><span class="mi">1</span><span class="o">;</span>	<span class="c1">// Calculate # of bits</span>
        <span class="kt">int</span> <span class="n">idx</span><span class="o">;</span>		<span class="c1">// where to start inserting from</span>
        <span class="kt">char</span><span class="o">[]</span> <span class="n">digits</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">num</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>	<span class="c1">// If num is negative</span>
            <span class="n">num</span> <span class="o">=</span> <span class="o">-</span><span class="n">num</span><span class="o">;</span>	<span class="c1">// Make it positive</span>
            <span class="n">digits</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="o">[</span><span class="n">len</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>	<span class="c1">// We need one more space for -ve sign in the front</span>
            <span class="n">digits</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="sc">'-'</span><span class="o">;</span>			<span class="c1">// Put the -ve sign</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">len</span><span class="o">;</span>					<span class="c1">// and index is now len</span>
        <span class="o">}</span>
        <span class="k">else</span><span class="o">{</span>
            <span class="n">digits</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="o">[</span><span class="n">len</span><span class="o">];</span>		<span class="c1">// otherwise we only need "len" spaces</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">len</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span>				<span class="c1">// index is len-1</span>
        <span class="o">}</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">num</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>				<span class="c1">// While num != 0, calculate remainder and add it.</span>
            <span class="n">digits</span><span class="o">[</span><span class="n">idx</span><span class="o">--]</span> <span class="o">=</span> <span class="o">(</span><span class="kt">char</span><span class="o">)(</span><span class="n">num</span> <span class="o">%</span> <span class="mi">7</span> <span class="o">+</span> <span class="sc">'0'</span><span class="o">);</span>	<span class="c1">// Divide number by 7</span>
            <span class="n">num</span> <span class="o">/=</span> <span class="mi">7</span><span class="o">;</span>
        <span class="o">}</span>     
        <span class="k">return</span> <span class="k">new</span> <span class="nf">String</span><span class="o">(</span><span class="n">digits</span><span class="o">);</span>		<span class="c1">// Just create a string and return it.</span>
    <span class="o">}</span>
</pre></table></code></div></div><p>Solution 2 with StringBuilder</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="nc">String</span> <span class="nf">convertToBase7</span><span class="o">(</span><span class="kt">int</span> <span class="n">num</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">StringBuilder</span> <span class="n">sb</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>
    <span class="kt">boolean</span> <span class="n">isNegative</span> <span class="o">=</span> <span class="n">num</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">;</span>	<span class="c1">// Just so we can know if we need to add the "-" sign</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">num</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span>					<span class="c1">// Take the absolute value of num</span>
        <span class="n">num</span> <span class="o">=</span> <span class="o">-</span><span class="n">num</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">num</span> <span class="o">&gt;</span> <span class="mi">6</span><span class="o">)</span> <span class="o">{</span>				<span class="c1">// Keep adding the remainder, and dividing num by 7.</span>
        <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">num</span> <span class="o">%</span> <span class="mi">7</span><span class="o">);</span>
        <span class="n">num</span> <span class="o">/=</span> <span class="mi">7</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">num</span><span class="o">);</span>					<span class="c1">// Add whatever is left at the end.</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">isNegative</span><span class="o">)</span>					<span class="c1">// If num was negative, add the minus sign.</span>
        <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="sc">'-'</span><span class="o">);</span>

    <span class="k">return</span> <span class="n">sb</span><span class="o">.</span><span class="na">reverse</span><span class="o">().</span><span class="na">toString</span><span class="o">();</span>	<span class="c1">// Reverse the builder and return the toString()</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="relative-ranks"><span class="me-2"><a href="https://leetcode.com/problems/relative-ranks/">Relative Ranks</a><a name="relative-ranks"></a></span><a href="#relative-ranks" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>The idea employed here is simple. We need to store the relative ranks in sorted order. We can sort the array for that, but that is O(n log n). We can do better than that by finding the relative rank in linear time. First we find the maximum score in the array and create another array of length = maxScore + 1. We add 1 so that when we see the maxScore in the nums, we can assign it to maxScore index. Once we have done that, now we iterate over the nums array. Variable i keeps track of what rank to assign. We check a value in the array and at that index in our reverse sorted array, we put i+1, which basically marks it’s rank based on it’s position in the rankings. Some of then indexes would be default, that is a score of 0. We then check each value in the descend array and if it’s not 0, we assign it a rank, but not if the ranks are 1, 2 or 3. In that case, we assign it a special value of Gold, SIlver or Bronze.</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="nc">String</span><span class="o">[]</span> <span class="nf">findRelativeRanks</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">maxScore</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="nl">n:</span> <span class="n">nums</span><span class="o">)</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="n">maxScore</span><span class="o">)</span>
            <span class="n">maxScore</span> <span class="o">=</span> <span class="n">n</span><span class="o">;</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">descend</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">maxScore</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span>
        <span class="n">descend</span><span class="o">[</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]]</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span>
    <span class="nc">String</span><span class="o">[]</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">[</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>
    <span class="kt">int</span> <span class="n">rank</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">descend</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span> <span class="o">--</span><span class="n">i</span><span class="o">){</span>
        <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">descend</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">descend</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">){</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">rank</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span>
                <span class="n">result</span><span class="o">[</span><span class="n">idx</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="s">"Gold Medal"</span><span class="o">;</span>
            <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">rank</span> <span class="o">==</span> <span class="mi">2</span><span class="o">)</span>
                <span class="n">result</span><span class="o">[</span><span class="n">idx</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="s">"Silver Medal"</span><span class="o">;</span>
            <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">rank</span> <span class="o">==</span> <span class="mi">3</span><span class="o">)</span>
                <span class="n">result</span><span class="o">[</span><span class="n">idx</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="s">"Bronze Medal"</span><span class="o">;</span>
            <span class="k">else</span>
                <span class="n">result</span><span class="o">[</span><span class="n">idx</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">rank</span> <span class="o">+</span> <span class="s">""</span><span class="o">;</span>
            <span class="o">++</span><span class="n">rank</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="perfect-number"><span class="me-2"><a href="https://leetcode.com/problems/perfect-number/">Perfect Number</a><a name="perfect-number"></a></span><a href="#perfect-number" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">checkPerfectNumber</span><span class="o">(</span><span class="kt">int</span> <span class="n">num</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">num</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span>		<span class="c1">// 1 is a special case, where it's only factor is itself.</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">total</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>		<span class="c1">// We know our total will atleast be 1, 1 is everyone's factor</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">sqrt</span><span class="o">(</span><span class="n">num</span><span class="o">);</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span>	<span class="c1">// Only loop through num's sqrt</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">num</span> <span class="o">%</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>				<span class="c1">// If i divides num perfectly</span>
            <span class="kt">int</span> <span class="n">otherFactor</span> <span class="o">=</span> <span class="n">num</span><span class="o">/</span><span class="n">i</span><span class="o">;</span>	<span class="c1">// Calculate the other factor</span>
            <span class="n">total</span> <span class="o">+=</span> <span class="n">i</span> <span class="o">+</span> <span class="o">(</span><span class="n">otherFactor</span> <span class="o">==</span> <span class="n">i</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">otherFactor</span><span class="o">);</span>	<span class="c1">// If i and other factor are</span>
        <span class="o">}</span>								<span class="c1">// different, add them both, otherwise just i.</span>
    <span class="k">return</span> <span class="n">total</span> <span class="o">==</span> <span class="n">num</span><span class="o">;</span>				<span class="c1">// Check in the end if your total is the same as num</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="detect-capital"><span class="me-2"><a href="https://leetcode.com/problems/detect-capital/">Detect Capital</a><a name="detect-capital"></a></span><a href="#detect-capital" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">detectCapitalUse</span><span class="o">(</span><span class="nc">String</span> <span class="n">word</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">word</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="o">)</span>			<span class="c1">// Empty or size 1 words are ok.</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="kt">char</span><span class="o">[]</span> <span class="n">chars</span> <span class="o">=</span> <span class="n">word</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">();</span>	<span class="c1">// Get the char array</span>
    <span class="kt">boolean</span> <span class="n">isUpper</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>	<span class="c1">// by default we let isUpper to false</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">chars</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">&gt;=</span> <span class="sc">'A'</span> <span class="o">&amp;&amp;</span> <span class="n">chars</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="sc">'Z'</span><span class="o">)</span>		<span class="c1">// Check if first two letters are uppercase</span>
        <span class="n">isUpper</span> <span class="o">=</span> <span class="n">chars</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">&gt;=</span> <span class="sc">'A'</span> <span class="o">&amp;&amp;</span> <span class="n">chars</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="sc">'Z'</span><span class="o">;</span> <span class="c1">// If first was upper and second wasnt</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>	<span class="c1">// isUpper = false, otherwise true.</span>
        <span class="kt">boolean</span> <span class="n">isAlsoUpper</span> <span class="o">=</span> <span class="n">chars</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;=</span> <span class="sc">'A'</span> <span class="o">&amp;&amp;</span> <span class="n">chars</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="sc">'Z'</span><span class="o">;</span> <span class="c1">// We check onwards 1 char</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">isUpper</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">isAlsoUpper</span><span class="o">)</span>	<span class="c1">// If that char is lower and previous part was</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>				<span class="c1">// not lower, invalid use.</span>
        <span class="k">if</span> <span class="o">(!</span><span class="n">isUpper</span> <span class="o">&amp;&amp;</span> <span class="n">isAlsoUpper</span><span class="o">)</span>	<span class="c1">// Or if previous part was lower and current letter</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>				<span class="c1">// is upper, we return false.</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>				<span class="c1">// Everything proceeded smoothly. So return true.</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="longest-uncommon-subsequence-i"><span class="me-2"><a href="https://leetcode.com/problems/longest-uncommon-subsequence-i/">Longest Uncommon Subsequence I</a><a name="longest-uncommon-subsequence-i"></a></span><a href="#longest-uncommon-subsequence-i" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>This is those kind of problems that shouldn’t be up there. The problem is stated rather poorly and the solution is even stupider. All you are checking for is if the two string’s aren’t the same, then whichever one has a larger length is essentially the longest uncommon subsequence because the other string cannot form the full string. I know, it’s stupid.</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">findLUSlength</span><span class="o">(</span><span class="nc">String</span> <span class="n">a</span><span class="o">,</span> <span class="nc">String</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">a</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">b</span><span class="o">))</span>
          <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
      <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&gt;</span> <span class="n">b</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">?</span> <span class="n">a</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">:</span> <span class="n">b</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
  <span class="o">}</span>
</pre></table></code></div></div><h3 id="course-schedule-ii"><span class="me-2"><a href="https://leetcode.com/problems/course-schedule-ii/">Course Schedule II</a><a name="course-schedule-ii"></a></span><a href="#course-schedule-ii" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>This is a graph problem where we require to sort the vertices topologically. There are two choices we have for sorting topologically - Depth First Search approach based on finshing times or the Kahn’s Algorithm. I have used Kahn’s algorithm in this solution. Runtime is 2ms [beats 100%] and uses 45.3 MB space [beats than 90.16%]. The idea for Kahn’s is simple - Enqueue all the nodes which has 0 incoming edges because those are the ones that can be started first. Then while the queue isn’t empty, remove one node at a time, process it’s outgoing nodes and decrease their indegrees by one. The reasoning behind that is let’s say Node 2 has two prerequisites, Node 0 and Node 1. Node 0 and Node 1 have 0 indegrees. So our first two nodes would be Node 1 and Node 0 and if they are finished, then their outgoing Nodes can be started, that is Node 2. Now when you decrease any node’s indegree and they become zero, add them to the queue because they can now be started. Keep doing this until the queue is empty.</p><p>In my approach, I’m avoiding any unnecessary data structure and using only the most basic ones like array’s. So instead of using the queue, what I do is fill the array <code class="language-plaintext highlighter-rouge">order</code> which also stores the topological order. <code class="language-plaintext highlighter-rouge">idx</code> keeps track of the last index available to fill in the array. <code class="language-plaintext highlighter-rouge">start</code> mimics the <code class="language-plaintext highlighter-rouge">poll</code> behaviour of a queue. <code class="language-plaintext highlighter-rouge">while (start != idx)</code> makes sure that while we still have nodes to process, remove the one that can be started and decrease all the indegrees of outgoing edges.</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">findOrder</span><span class="o">(</span><span class="kt">int</span> <span class="n">numCourses</span><span class="o">,</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">prerequisites</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">indegrees</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">numCourses</span><span class="o">];</span>				<span class="c1">// We maintain each node's indegree</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;[]</span> <span class="n">graph</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">[</span><span class="n">numCourses</span><span class="o">];</span>	<span class="c1">// Each node's outgoing edges</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="nl">edge:</span> <span class="n">prerequisites</span><span class="o">)</span> <span class="o">{</span>					<span class="c1">// Process each edge</span>
        <span class="n">indegrees</span><span class="o">[</span><span class="n">edge</span><span class="o">[</span><span class="mi">0</span><span class="o">]]++;</span>							<span class="c1">// Update indegrees</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">graph</span><span class="o">[</span><span class="n">edge</span><span class="o">[</span><span class="mi">1</span><span class="o">]]</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>						<span class="c1">// Also store the edge in graph</span>
            <span class="n">graph</span><span class="o">[</span><span class="n">edge</span><span class="o">[</span><span class="mi">1</span><span class="o">]]</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;();</span>
        <span class="n">graph</span><span class="o">[</span><span class="n">edge</span><span class="o">[</span><span class="mi">1</span><span class="o">]].</span><span class="na">add</span><span class="o">(</span><span class="n">edge</span><span class="o">[</span><span class="mi">0</span><span class="o">]);</span>
    <span class="o">}</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">order</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">numCourses</span><span class="o">];</span>		    <span class="c1">// We don't technically need a queue.</span>
    <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numCourses</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span>        <span class="c1">// Find all nodes who indegree is 0</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">indegrees</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>                  <span class="c1">// and put them in the order array</span>
            <span class="n">order</span><span class="o">[</span><span class="n">idx</span><span class="o">++]</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>                              <span class="c1">// start tracks node to be polled.</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">start</span> <span class="o">!=</span> <span class="n">idx</span><span class="o">)</span> <span class="o">{</span>                      <span class="c1">// while we can poll the queue</span>
        <span class="kt">int</span> <span class="n">u</span> <span class="o">=</span> <span class="n">order</span><span class="o">[</span><span class="n">start</span><span class="o">++];</span>                 <span class="c1">// poll the node u</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">graph</span><span class="o">[</span><span class="n">u</span><span class="o">]</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>                   <span class="c1">// If node u has outgoing edges </span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="nl">out:</span> <span class="n">graph</span><span class="o">[</span><span class="n">u</span><span class="o">])</span>             <span class="c1">// Then for each of those nodes</span>
                <span class="k">if</span> <span class="o">(--</span><span class="n">indegrees</span><span class="o">[</span><span class="n">out</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>      <span class="c1">// decrease their indegrees and check if it's 0</span>
                    <span class="n">order</span><span class="o">[</span><span class="n">idx</span><span class="o">++]</span> <span class="o">=</span> <span class="n">out</span><span class="o">;</span>         <span class="c1">// if it's 0, add it to our queue (order)</span>
    <span class="o">}</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">idx</span> <span class="o">!=</span> <span class="n">numCourses</span><span class="o">)</span>						<span class="c1">// Cycle check. If our idx != numCourses then</span>
        <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]</span> <span class="o">{};</span>					<span class="c1">// not all nodes could be processed. So we have</span>
    <span class="k">return</span> <span class="n">order</span><span class="o">;</span>								<span class="c1">// a cycle. Otherwise return our order array.</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="letter-combinations-of-a-phone-number"><span class="me-2"><a href="https://leetcode.com/problems/letter-combinations-of-a-phone-number/">Letter Combinations of a Phone Number</a><a name="letter-combinations-of-a-phone-number"></a></span><a href="#letter-combinations-of-a-phone-number" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Runtime: 0 ms, faster than 100.00% of Java online submissions for Letter Combinations of a Phone Number.</p><p>Memory Usage: 35.9 MB, less than 98.63% of Java online submissions for Letter Combinations of a Phone Number.</p><hr /><p>How do we count numbers? 16, 17, 18, 19 and then what? 20 right? We see that the last number is 19, we can’t go past 9 so we set it to 0 and then increment the precedding digit to get 20. The idea is the same for this problem too. We keep a <code class="language-plaintext highlighter-rouge">levels</code> array to keep track of which character do we take from which number’s allowed alphabet letters. For example, let’s say the input string is <code class="language-plaintext highlighter-rouge">23</code>. Our <code class="language-plaintext highlighter-rouge">levels</code> array would <code class="language-plaintext highlighter-rouge">[0, 0]</code> in the beginning. This says pick characters at index 0 and 0 from alphabet characters corresponding to 2 and 3 which gives us <code class="language-plaintext highlighter-rouge">ad</code>. Then, we increase the last most counter in our levels array by 1 giving us <code class="language-plaintext highlighter-rouge">[0, 1]</code>. This allows us to get <code class="language-plaintext highlighter-rouge">ae</code> in the next iteration and levels array would be <code class="language-plaintext highlighter-rouge">[0, 2]</code>. We get <code class="language-plaintext highlighter-rouge">af</code> and levels array becomes <code class="language-plaintext highlighter-rouge">[0, 3]</code>. Now this is where it becomes interesting. We are only allowed three letters for the digit corresponding to 3 and since we already used all of them , we now need to shift to the next character for digit 2, which is <code class="language-plaintext highlighter-rouge">b</code>. Level array looks like <code class="language-plaintext highlighter-rouge">[1, 0]</code>. This will allow us to get <code class="language-plaintext highlighter-rouge">[b,e]</code>. So you get the rough idea now. Only thing now is we watch out when to stop. We stop when we have utilized all available characters from the 0th index’s number’s allowed alphabet letters. In this case, we stop when levels array look like <code class="language-plaintext highlighter-rouge">[3, 0]</code>.</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
	<span class="kd">private</span> <span class="kt">char</span><span class="o">[][]</span> <span class="n">map</span> <span class="o">=</span> <span class="o">{</span>
            <span class="o">{</span><span class="sc">'a'</span><span class="o">,</span> <span class="sc">'b'</span><span class="o">,</span> <span class="sc">'c'</span><span class="o">},</span>        <span class="c1">// 2</span>
            <span class="o">{</span><span class="sc">'d'</span><span class="o">,</span> <span class="sc">'e'</span><span class="o">,</span> <span class="sc">'f'</span><span class="o">},</span>        <span class="c1">// 3</span>
            <span class="o">{</span><span class="sc">'g'</span><span class="o">,</span> <span class="sc">'h'</span><span class="o">,</span> <span class="sc">'i'</span><span class="o">},</span>        <span class="c1">// 4</span>
            <span class="o">{</span><span class="sc">'j'</span><span class="o">,</span> <span class="sc">'k'</span><span class="o">,</span> <span class="sc">'l'</span><span class="o">},</span>        <span class="c1">// 5</span>
            <span class="o">{</span><span class="sc">'m'</span><span class="o">,</span> <span class="sc">'n'</span><span class="o">,</span> <span class="sc">'o'</span><span class="o">},</span>        <span class="c1">// 6</span>
            <span class="o">{</span><span class="sc">'p'</span><span class="o">,</span> <span class="sc">'q'</span><span class="o">,</span> <span class="sc">'r'</span><span class="o">,</span> <span class="sc">'s'</span><span class="o">},</span>   <span class="c1">// 7</span>
            <span class="o">{</span><span class="sc">'t'</span><span class="o">,</span> <span class="sc">'u'</span><span class="o">,</span> <span class="sc">'v'</span><span class="o">},</span>        <span class="c1">// 8</span>
            <span class="o">{</span><span class="sc">'w'</span><span class="o">,</span> <span class="sc">'x'</span><span class="o">,</span> <span class="sc">'y'</span><span class="o">,</span> <span class="sc">'z'</span><span class="o">}</span>    <span class="c1">// 9</span>
    <span class="o">};</span>

    <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>                <span class="c1">// Maintain the list of combinations</span>
    <span class="kd">private</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">numbers</span><span class="o">;</span>                                          <span class="c1">// numbers parsed from input</span>
    <span class="kd">private</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">levels</span><span class="o">;</span>                                           <span class="c1">// utility array to keep track of next character in string</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">n</span><span class="o">;</span>                                                  <span class="c1">// number of input digits.</span>

    <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="nf">solution</span><span class="o">(</span><span class="nc">String</span> <span class="n">digits</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">digits</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">digits</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>                 <span class="c1">// stop if null or empty string</span>
            <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">digits</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="n">numbers</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
        <span class="n">levels</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">digits</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>                 <span class="c1">// parse all the digits from the string as int</span>
            <span class="k">if</span> <span class="o">((</span><span class="n">numbers</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">digits</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'0'</span><span class="o">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="o">)</span>          <span class="c1">// stop if any of them is 0 or 1</span>
                <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">helper</span><span class="o">();</span>                                                   <span class="c1">// start recursion</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">helper</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">levels</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">==</span> <span class="n">map</span><span class="o">[</span><span class="n">numbers</span><span class="o">[</span><span class="mi">0</span><span class="o">]-</span><span class="mi">2</span><span class="o">].</span><span class="na">length</span><span class="o">)</span>                  <span class="c1">// if we are done iterating over all possible combinations,</span>
            <span class="k">return</span><span class="o">;</span>                                                 <span class="c1">// stop recursion.</span>
        <span class="kt">char</span><span class="o">[]</span> <span class="n">s</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>                                     <span class="c1">// stores all the characters of the string</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span>                                 <span class="c1">// loop through levels array. The value at each index</span>
            <span class="n">s</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">map</span><span class="o">[</span><span class="n">numbers</span><span class="o">[</span><span class="n">i</span><span class="o">]-</span><span class="mi">2</span><span class="o">][</span><span class="n">levels</span><span class="o">[</span><span class="n">i</span><span class="o">]];</span>                    <span class="c1">// tells us which character to keep from which map index</span>
        <span class="n">levels</span><span class="o">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">]++;</span>                                              <span class="c1">// Increase the entry at the end of the levels array</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">levels</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">;</span> <span class="o">--</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>                 <span class="c1">// Now loop through the levels array from the end</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">levels</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="n">map</span><span class="o">[</span><span class="n">numbers</span><span class="o">[</span><span class="n">i</span><span class="o">]-</span><span class="mi">2</span><span class="o">].</span><span class="na">length</span><span class="o">)</span> <span class="o">{</span>            <span class="c1">// If the value = total number of characters allowed for that number</span>
                <span class="n">levels</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>                                      <span class="c1">// then we set it to 0 and increment the previous level entry</span>
                <span class="n">levels</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]++;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="n">result</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">s</span><span class="o">));</span>                                  <span class="c1">// Add the string and induce next recursive call.</span>
        <span class="n">helper</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="sudoku-solver"><span class="me-2"><a href="https://leetcode.com/problems/sudoku-solver/">Sudoku Solver</a><a name="sudoku-solver"></a></span><a href="#sudoku-solver" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Runtime: 4 ms, faster than 90.01% of Java online submissions for Sudoku Solver.</p><p>Memory Usage: 35.1 MB, less than 71.93% of Java online submissions for Sudoku Solver.</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
</pre><td class="rouge-code"><pre><span class="kd">private</span> <span class="kt">char</span><span class="o">[][]</span> <span class="n">board</span><span class="o">;</span>

<span class="kd">public</span> <span class="kt">void</span> <span class="nf">solveSudoku</span><span class="o">(</span><span class="kt">char</span><span class="o">[][]</span> <span class="n">board</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">board</span> <span class="o">=</span> <span class="n">board</span><span class="o">;</span>
    <span class="n">solve</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">solve</span><span class="o">(</span><span class="kt">int</span> <span class="n">row</span><span class="o">,</span> <span class="kt">int</span> <span class="n">col</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">col</span> <span class="o">==</span> <span class="mi">9</span><span class="o">)</span> <span class="o">{</span>                                 <span class="c1">// If col is 9, make it 0 and shift to the next row</span>
        <span class="n">col</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="n">row</span> <span class="o">+=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">row</span> <span class="o">==</span> <span class="mi">9</span><span class="o">)</span>                               <span class="c1">// If row is also 9 now, then it means we have successfully filled all cells</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>                            <span class="c1">// So return true and end backtracking.</span>
    <span class="o">}</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>                  <span class="c1">// Otherwise, we start picking values from 1-9</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">board</span><span class="o">[</span><span class="n">row</span><span class="o">][</span><span class="n">col</span><span class="o">]</span> <span class="o">==</span> <span class="sc">'.'</span><span class="o">)</span> <span class="o">{</span>               <span class="c1">// And try to plug it into empty cells</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">isValid</span><span class="o">(</span><span class="n">row</span><span class="o">,</span> <span class="n">col</span><span class="o">,</span> <span class="n">i</span><span class="o">))</span> <span class="o">{</span>             <span class="c1">// If that value is valid in that cell</span>
                <span class="n">board</span><span class="o">[</span><span class="n">row</span><span class="o">][</span><span class="n">col</span><span class="o">]</span> <span class="o">=</span> <span class="o">(</span><span class="kt">char</span><span class="o">)(</span><span class="n">i</span><span class="o">+</span><span class="sc">'0'</span><span class="o">);</span>    <span class="c1">// fill it</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">solve</span><span class="o">(</span><span class="n">row</span><span class="o">,</span> <span class="n">col</span><span class="o">+</span><span class="mi">1</span><span class="o">))</span>          <span class="c1">// and move on to fill the next cell via recursive call</span>
                    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>                    <span class="c1">// If the recursion ended by returning true, then return true to signal success</span>
                <span class="k">else</span>                                <span class="c1">// Otherwise, we were not able to put an value in that cell</span>
                    <span class="n">board</span><span class="o">[</span><span class="n">row</span><span class="o">][</span><span class="n">col</span><span class="o">]</span> <span class="o">=</span> <span class="sc">'.'</span><span class="o">;</span>          <span class="c1">// so change it back to 0 and the backtracking would try the next higher value in that cell.</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">else</span>
            <span class="k">return</span> <span class="nf">solve</span><span class="o">(</span><span class="n">row</span><span class="o">,</span> <span class="n">col</span><span class="o">+</span><span class="mi">1</span><span class="o">);</span>           <span class="c1">// That cell wasn't empty, so move on to the next empty cell.</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>                                   <span class="c1">// No solution found.</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">isValid</span><span class="o">(</span><span class="kt">int</span> <span class="n">row</span><span class="o">,</span> <span class="kt">int</span> <span class="n">col</span><span class="o">,</span> <span class="kt">int</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// row check</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="mi">9</span><span class="o">;</span> <span class="o">++</span><span class="n">c</span><span class="o">)</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">board</span><span class="o">[</span><span class="n">row</span><span class="o">][</span><span class="n">c</span><span class="o">]</span> <span class="o">-</span> <span class="sc">'0'</span> <span class="o">==</span> <span class="n">val</span><span class="o">)</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>

    <span class="c1">// column check</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="mi">9</span><span class="o">;</span> <span class="o">++</span><span class="n">r</span><span class="o">)</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">board</span><span class="o">[</span><span class="n">r</span><span class="o">][</span><span class="n">col</span><span class="o">]</span> <span class="o">-</span> <span class="sc">'0'</span> <span class="o">==</span> <span class="n">val</span><span class="o">)</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>

    <span class="c1">// box check</span>
    <span class="kt">int</span> <span class="n">top</span> <span class="o">=</span> <span class="n">row</span> <span class="o">/</span> <span class="mi">3</span> <span class="o">*</span> <span class="mi">3</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="n">col</span> <span class="o">/</span> <span class="mi">3</span> <span class="o">*</span> <span class="mi">3</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">board</span><span class="o">[</span><span class="n">top</span><span class="o">+</span><span class="n">i</span><span class="o">][</span><span class="n">left</span><span class="o">+</span><span class="n">j</span><span class="o">]</span> <span class="o">-</span> <span class="sc">'0'</span> <span class="o">==</span> <span class="n">val</span><span class="o">)</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>

        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="bulls-and-cows"><span class="me-2"><a href="https://leetcode.com/problems/bulls-and-cows/">Bulls and Cows</a><a name="bulls-and-cows"></a></span><a href="#bulls-and-cows" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Runtime: 1 ms, faster than 100.00% of Java online submissions for Bulls and Cows.</p><p>Memory Usage: 36.3 MB, less than 100.00% of Java online submissions for Bulls and Cows.</p><p>The idea is simple, first record the frequency of the digits of the secret number. Then we first find number of <code class="language-plaintext highlighter-rouge">bulls</code> by checking for exact indices match. After that we start to record the number of <code class="language-plaintext highlighter-rouge">cows</code>. The way we do is by again iterating over the <code class="language-plaintext highlighter-rouge">guess</code> string; only if there was a character mismatch and we still have the character available from <code class="language-plaintext highlighter-rouge">freq</code> table, we have a <code class="language-plaintext highlighter-rouge">cow</code>. Update it and decrement the frequency of the number we just used up.</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="nc">String</span> <span class="nf">getHint</span><span class="o">(</span><span class="nc">String</span> <span class="n">secret</span><span class="o">,</span> <span class="nc">String</span> <span class="n">guess</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">bulls</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">cows</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">freq</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">10</span><span class="o">];</span>							<span class="c1">// Freq of available digits from secret</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">guess</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">char</span> <span class="n">s</span> <span class="o">=</span> <span class="n">secret</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
        <span class="n">freq</span><span class="o">[</span><span class="n">s</span> <span class="o">-</span> <span class="sc">'0'</span><span class="o">]++;</span>								<span class="c1">// Record the freq of the digit</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">s</span> <span class="o">==</span> <span class="n">guess</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">))</span> <span class="o">{</span>						<span class="c1">// If it's a match, we have a bulls.</span>
            <span class="n">bulls</span><span class="o">++;</span>
            <span class="n">freq</span><span class="o">[</span><span class="n">s</span> <span class="o">-</span> <span class="sc">'0'</span><span class="o">]--;</span>							<span class="c1">// We just used the character, so decrement it.</span>
        <span class="o">}</span>
    <span class="o">}</span>
    
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">guess</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="n">secret</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'0'</span><span class="o">;</span>					<span class="c1">// Convert the chars into int</span>
        <span class="kt">int</span> <span class="n">g</span> <span class="o">=</span> <span class="n">guess</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'0'</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">s</span> <span class="o">!=</span> <span class="n">g</span> <span class="o">&amp;&amp;</span> <span class="n">freq</span><span class="o">[</span><span class="n">g</span><span class="o">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>					<span class="c1">// Only if they are a mismtach and we have a number g available in freq table</span>
            <span class="n">cows</span><span class="o">++;</span>										<span class="c1">// then it's a cow.</span>
            <span class="n">freq</span><span class="o">[</span><span class="n">g</span><span class="o">]--;</span>									<span class="c1">// We used up the number, so decrement it's freq.</span>
        <span class="o">}</span>
    <span class="o">}</span>
    
    <span class="k">return</span> <span class="k">new</span> <span class="nf">StringBuilder</span><span class="o">().</span><span class="na">append</span><span class="o">(</span><span class="n">bulls</span><span class="o">).</span><span class="na">append</span><span class="o">(</span><span class="s">"A"</span><span class="o">).</span><span class="na">append</span><span class="o">(</span><span class="n">cows</span><span class="o">).</span><span class="na">append</span><span class="o">(</span><span class="s">"B"</span><span class="o">).</span><span class="na">toString</span><span class="o">();</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="n-queens-i"><span class="me-2"><a href="https://leetcode.com/problems/n-queens/">N-Queens I</a><a name="n-queens-1"></a></span><a href="#n-queens-i" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Runtime: 3 ms, faster than 73.76% of Java online submissions for N-Queens. Memory Usage: 37.6 MB, less than 100.00% of Java online submissions for N-Queens.</p><p>The idea is same as sudoku, but insteading of scanning rows, we scan columns. Start with row 0, column 0 and see if we can place a queen there, if yes place it and try the next cell of row 0 by recursing. We can’t put the queen in the same row again, so we keep changing rows with column 1 until we find somewhere to place it. Keep doing this until you were successfully able to place all the queens as checked by the condition <code class="language-plaintext highlighter-rouge">col == n</code>. If so, add that solution to our list of accepted solutions.</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">NQueens</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">board</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">n</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;&gt;</span> <span class="n">result</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;&gt;</span> <span class="nf">solveNQueens</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">;</span>
        <span class="n">board</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">][</span><span class="n">n</span><span class="o">];</span>
        <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="n">solve</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">solve</span><span class="o">(</span><span class="kt">int</span> <span class="n">col</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">col</span> <span class="o">==</span> <span class="n">n</span><span class="o">)</span>
            <span class="n">addToList</span><span class="o">();</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">row</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">row</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">row</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">canPlaceQueen</span><span class="o">(</span><span class="n">row</span><span class="o">,</span> <span class="n">col</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">board</span><span class="o">[</span><span class="n">row</span><span class="o">][</span><span class="n">col</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">solve</span><span class="o">(</span><span class="n">col</span><span class="o">+</span><span class="mi">1</span><span class="o">))</span> <span class="o">{</span>
                    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="k">else</span>
                    <span class="n">board</span><span class="o">[</span><span class="n">row</span><span class="o">][</span><span class="n">col</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">addToList</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
        <span class="nc">StringBuilder</span> <span class="n">sb</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="nl">r:</span> <span class="n">board</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">sb</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="nl">i:</span> <span class="n">r</span><span class="o">)</span>
                <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">?</span> <span class="sc">'Q'</span> <span class="o">:</span> <span class="sc">'.'</span><span class="o">);</span>
            <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">sb</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
        <span class="o">}</span>
        <span class="n">result</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">list</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">canPlaceQueen</span><span class="o">(</span><span class="kt">int</span> <span class="n">row</span><span class="o">,</span> <span class="kt">int</span> <span class="n">col</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Check all rows for the same column</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">col</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">board</span><span class="o">[</span><span class="n">row</span><span class="o">][</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>
        
        <span class="c1">// Check upper left diagonal of the cell</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">row</span><span class="o">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">col</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">--,</span> <span class="n">j</span><span class="o">--)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">board</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>
        
        <span class="c1">// Check lower left diagonal of the cell.</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">row</span><span class="o">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">col</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">++,</span> <span class="n">j</span><span class="o">--)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">board</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="k-diff-pairs-in-an-array"><span class="me-2"><a href="https://leetcode.com/problems/k-diff-pairs-in-an-array/">K-diff pairs in an Array</a><a name="k-diff-pairs-in-an-array"></a></span><a href="#k-diff-pairs-in-an-array" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Pretty intuitive solution. Build a frequency HashMap for all the numbers in the array. In a special case where <code class="language-plaintext highlighter-rouge">diff</code> is 0, just count occurences in our <code class="language-plaintext highlighter-rouge">freq</code> map whose values are 2 or more. In other case, just loop through all the keys and make sure it’s supplement exists to count the number of K-diff pairs.</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">int</span> <span class="nf">findPairs</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">k</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span>
        <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">pairs</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="nc">HashMap</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">freq</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="nl">i:</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">freq</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">freq</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="mi">0</span><span class="o">)+</span><span class="mi">1</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="nl">i:</span> <span class="n">freq</span><span class="o">.</span><span class="na">values</span><span class="o">())</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="o">)</span>
                <span class="n">pairs</span><span class="o">++;</span>
        <span class="k">return</span> <span class="n">pairs</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="nl">i:</span> <span class="n">freq</span><span class="o">.</span><span class="na">keySet</span><span class="o">())</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">freq</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">i</span><span class="o">+</span><span class="n">k</span><span class="o">))</span>
            <span class="n">pairs</span><span class="o">++;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">pairs</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="is-subsequence"><span class="me-2"><a href="https://leetcode.com/problems/is-subsequence/submissions/">Is Subsequence</a><a name="is-subsequence"></a></span><a href="#is-subsequence" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Runtime: 0 ms, faster than 100.00% of Java online submissions for Is Subsequence. Memory Usage: 49.6 MB, less than 100.00% of Java online submissions for Is Subsequence.</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isSubsequence</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="nc">String</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>								<span class="c1">// Set it to 0 to start check for 0th index</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="nl">c:</span> <span class="n">s</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">())</span> <span class="o">{</span>				<span class="c1">// For all the characters in String s</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="na">indexOf</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="n">idx</span><span class="o">+</span><span class="mi">1</span><span class="o">);</span>				<span class="c1">// Find it's index in String t from index one more than the last index matched</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span>							<span class="c1">// idx &lt; 0 means not found</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="minimum-absolute-difference-in-bst"><span class="me-2"><a href="https://leetcode.com/problems/minimum-absolute-difference-in-bst/">Minimum Absolute Difference in BST</a><a name="minimum-absolute-difference-in-bst"></a></span><a href="#minimum-absolute-difference-in-bst" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>The idea is to use the Inorder traversal of a BST. We repeatively iterate over the left branch to find the minimum diff and then do the same for the right branch, but this time we already know that the parent of the right branch has to be its minimum, so first set it and then traverse the right branch to find the minimum difference.</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>								<span class="c1">// Hold the minimum difference.</span>
<span class="kt">int</span> <span class="n">prev</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>								<span class="c1">// Holds the minimum value observed for the right branch</span>

<span class="kd">public</span> <span class="kt">int</span> <span class="nf">getMinimumDifference</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">traverse</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>											<span class="c1">// Start iterating from the root.</span>
    <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kt">void</span> <span class="nf">traverse</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">node</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>										<span class="c1">// Null node, so stop recursion</span>
        <span class="k">return</span><span class="o">;</span>
    <span class="n">traverse</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>									<span class="c1">// Keep traversing till the end of the tree</span>
    <span class="n">res</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="nc">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">val</span><span class="o">-</span><span class="n">prev</span><span class="o">),</span> <span class="n">res</span><span class="o">);</span>			<span class="c1">// Check if we have a minimum, if so set it.</span>
    <span class="n">prev</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">val</span><span class="o">;</span>										<span class="c1">// The smallest value for the right branch is it's parent</span>
    <span class="n">traverse</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>									<span class="c1">// Set it first and then traverse.</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="bst-tree-to-greater-tree"><span class="me-2"><a href="https://leetcode.com/problems/convert-bst-to-greater-tree/">BST Tree to Greater Tree</a><a name="bst-tree-to-greater-tree"></a></span><a href="#bst-tree-to-greater-tree" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>The idea is simple. In a BST, we know everything on the right side of a node is greater than it and it’s left side. So when we are at any node, it’s value would be its value + sum of everything on its right side. So, we first compute the node’s value and then notice that the value for the node on the left is nothing but its value + parents value. So the node’s value is computed, do the same thing for the left side, but this time, the starting sum would be the parent’s value.</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="nc">TreeNode</span> <span class="nf">convertBST</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">traverse</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">root</span><span class="o">;</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kt">int</span> <span class="nf">traverse</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">node</span><span class="o">,</span> <span class="kt">int</span> <span class="n">sum</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">node</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
        <span class="k">return</span> <span class="n">sum</span><span class="o">;</span>
    <span class="n">node</span><span class="o">.</span><span class="na">val</span> <span class="o">+=</span> <span class="n">traverse</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">sum</span><span class="o">);</span>
    <span class="k">return</span> <span class="nf">traverse</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">node</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="student-attendance-record-i"><span class="me-2"><a href="https://leetcode.com/problems/student-attendance-record-i/">Student Attendance Record I</a><a name="student-attendance-record-I"></a></span><a href="#student-attendance-record-i" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">checkRecord</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
      <span class="kt">int</span> <span class="no">A</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>												<span class="c1">// Count number of A's seen</span>
      <span class="kt">int</span> <span class="no">L</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>												<span class="c1">// Count number of consecutive L's seen</span>
      <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="nl">c:</span> <span class="n">s</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">())</span> <span class="o">{</span>		<span class="c1">// Loop through each character</span>
          <span class="k">if</span> <span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">'A'</span><span class="o">)</span> <span class="o">{</span>								<span class="c1">// If c is A, increment A</span>
              <span class="no">A</span><span class="o">++;</span>
              <span class="k">if</span> <span class="o">(</span><span class="no">A</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="o">)</span>								<span class="c1">// If A is more than 1, return false</span>
                  <span class="k">return</span> <span class="kc">false</span>
              <span class="no">L</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>										<span class="c1">// Always set L count to 0</span>
          <span class="o">}</span>
          <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">'L'</span><span class="o">)</span> <span class="o">{</span>					<span class="c1">// If c is L,</span>
              <span class="no">L</span><span class="o">++;</span>											<span class="c1">// We might have consecutive L's, so start counting</span>
              <span class="k">if</span> <span class="o">(</span><span class="no">L</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="o">)</span> <span class="o">{</span>							<span class="c1">// If we have more than 2 consecutive L's</span>
                  <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>					<span class="c1">// return false</span>
              <span class="o">}</span>
          <span class="o">}</span>
          <span class="k">else</span>													<span class="c1">// Lastly, we might have a P, that will reset our</span>
              <span class="no">L</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>										<span class="c1">// consecutive L streak.</span>
      <span class="o">}</span>
      <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>											<span class="c1">// Everything passed, so return true.</span>
  <span class="o">}</span>
</pre></table></code></div></div><h3 id="reverse-words-in-string-iii"><span class="me-2"><a href="https://leetcode.com/problems/reverse-words-in-a-string-iii/">Reverse Words in String III</a><a name="reverse-words-in-string-iii"></a></span><a href="#reverse-words-in-string-iii" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Runtime: 2 ms, faster than 99.34% of Java online submissions for Reverse Words in a String III.</p><p>Memory Usage: 37.9 MB, less than 100.00% of Java online submissions for Reverse Words in a String III.</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="nc">String</span> <span class="nf">reverseWords</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
      <span class="kt">char</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">();</span>
      <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
      <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
      <span class="kt">int</span> <span class="n">end</span><span class="o">;</span>
      <span class="k">while</span> <span class="o">(</span><span class="n">start</span> <span class="o">&lt;</span> <span class="n">len</span><span class="o">)</span> <span class="o">{</span>											<span class="c1">// Check the whole string</span>
          <span class="n">end</span> <span class="o">=</span> <span class="n">start</span><span class="o">;</span>													<span class="c1">// find the index of the first whitespace</span>
          <span class="k">while</span><span class="o">(</span><span class="n">end</span> <span class="o">&lt;</span> <span class="n">len</span> <span class="o">&amp;&amp;</span> <span class="n">arr</span><span class="o">[</span><span class="n">end</span><span class="o">]</span> <span class="o">!=</span> <span class="sc">' '</span><span class="o">)</span>		<span class="c1">// denoting end of the word</span>
              <span class="n">end</span><span class="o">++;</span>
          <span class="n">reverseWord</span><span class="o">(</span><span class="n">arr</span><span class="o">,</span> <span class="n">start</span><span class="o">,</span> <span class="n">end</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>				<span class="c1">// reverse that specific word</span>
          <span class="n">start</span> <span class="o">=</span> <span class="n">end</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span>												<span class="c1">// update start to the new word beginning</span>
      <span class="o">}</span>
      <span class="k">return</span> <span class="k">new</span> <span class="nf">String</span><span class="o">(</span><span class="n">arr</span><span class="o">);</span>										<span class="c1">// create a new string out of the array</span>
  <span class="o">}</span>

	<span class="cm">/*
	Reverses a word in-place by iterating n/2 times where n = len of the word.
	Traverse upto the middle point of the word while swapping each word from start+offset to end-	 offset.
	**/</span>
  <span class="kd">private</span> <span class="kt">void</span> <span class="nf">reverseWord</span><span class="o">(</span><span class="kt">char</span><span class="o">[]</span> <span class="n">arr</span><span class="o">,</span> <span class="kt">int</span> <span class="n">start</span><span class="o">,</span> <span class="kt">int</span> <span class="n">stop</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="o">(</span><span class="n">stop</span><span class="o">-</span><span class="n">start</span><span class="o">)/</span><span class="mi">2</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
          <span class="kt">char</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">start</span><span class="o">+</span><span class="n">i</span><span class="o">];</span>
          <span class="n">arr</span><span class="o">[</span><span class="n">start</span><span class="o">+</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">stop</span><span class="o">-</span><span class="n">i</span><span class="o">];</span>
          <span class="n">arr</span><span class="o">[</span><span class="n">stop</span><span class="o">-</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>
      <span class="o">}</span>
  <span class="o">}</span>
</pre></table></code></div></div><h3 id="quad-tree-intersection"><span class="me-2"><a href="https://leetcode.com/problems/quad-tree-intersection/">Quad Tree Intersection</a><a name="quad-tree-intersection"></a></span><a href="#quad-tree-intersection" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="nc">Node</span> <span class="nf">intersect</span><span class="o">(</span><span class="nc">Node</span> <span class="n">qt1</span><span class="o">,</span> <span class="nc">Node</span> <span class="n">qt2</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">qt1</span><span class="o">.</span><span class="na">isLeaf</span><span class="o">)</span>										<span class="c1">// If only a leaf, then return the one with true val</span>
          <span class="k">return</span> <span class="n">qt1</span><span class="o">.</span><span class="na">val</span> <span class="o">?</span> <span class="n">qt1</span> <span class="o">:</span> <span class="n">qt2</span><span class="o">;</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">qt2</span><span class="o">.</span><span class="na">isLeaf</span><span class="o">)</span>
          <span class="k">return</span> <span class="n">qt2</span><span class="o">.</span><span class="na">val</span> <span class="o">?</span> <span class="n">qt2</span> <span class="o">:</span> <span class="n">qt1</span><span class="o">;</span>
      <span class="nc">Node</span> <span class="n">n</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">();</span>							<span class="c1">// Prepare for recursion</span>
      <span class="n">n</span><span class="o">.</span><span class="na">val</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>											<span class="c1">// By default, each level node is not a leaf with </span>
      <span class="n">n</span><span class="o">.</span><span class="na">isLeaf</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>									<span class="c1">// value = true</span>
  
  		<span class="c1">// Keep traversing all the way to a terminal node and then store it.</span>
      <span class="n">n</span><span class="o">.</span><span class="na">topLeft</span> <span class="o">=</span> <span class="n">intersect</span><span class="o">(</span><span class="n">qt1</span><span class="o">.</span><span class="na">topLeft</span><span class="o">,</span> <span class="n">qt2</span><span class="o">.</span><span class="na">topLeft</span><span class="o">);</span>
      <span class="n">n</span><span class="o">.</span><span class="na">topRight</span> <span class="o">=</span> <span class="n">intersect</span><span class="o">(</span><span class="n">qt1</span><span class="o">.</span><span class="na">topRight</span><span class="o">,</span> <span class="n">qt2</span><span class="o">.</span><span class="na">topRight</span><span class="o">);</span>
      <span class="n">n</span><span class="o">.</span><span class="na">bottomLeft</span> <span class="o">=</span> <span class="n">intersect</span><span class="o">(</span><span class="n">qt1</span><span class="o">.</span><span class="na">bottomLeft</span><span class="o">,</span> <span class="n">qt2</span><span class="o">.</span><span class="na">bottomLeft</span><span class="o">);</span>
      <span class="n">n</span><span class="o">.</span><span class="na">bottomRight</span> <span class="o">=</span> <span class="n">intersect</span><span class="o">(</span><span class="n">qt1</span><span class="o">.</span><span class="na">bottomRight</span><span class="o">,</span> <span class="n">qt2</span><span class="o">.</span><span class="na">bottomRight</span><span class="o">);</span>
  
  		<span class="c1">// Check now if you're at the base case. If n's children are leaves and all their values are same, then make n a leaf and it's value the same as it's child.</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">n</span><span class="o">.</span><span class="na">topLeft</span><span class="o">.</span><span class="na">isLeaf</span> <span class="o">&amp;&amp;</span> <span class="n">n</span><span class="o">.</span><span class="na">topRight</span><span class="o">.</span><span class="na">isLeaf</span> <span class="o">&amp;&amp;</span> <span class="n">n</span><span class="o">.</span><span class="na">bottomLeft</span><span class="o">.</span><span class="na">isLeaf</span> <span class="o">&amp;&amp;</span> <span class="n">n</span><span class="o">.</span><span class="na">bottomRight</span><span class="o">.</span><span class="na">isLeaf</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">n</span><span class="o">.</span><span class="na">topLeft</span><span class="o">.</span><span class="na">val</span> <span class="o">==</span> <span class="n">n</span><span class="o">.</span><span class="na">topRight</span><span class="o">.</span><span class="na">val</span> <span class="o">&amp;&amp;</span> <span class="n">n</span><span class="o">.</span><span class="na">topRight</span><span class="o">.</span><span class="na">val</span> <span class="o">==</span> <span class="n">n</span><span class="o">.</span><span class="na">bottomLeft</span><span class="o">.</span><span class="na">val</span> <span class="o">&amp;&amp;</span> <span class="n">n</span><span class="o">.</span><span class="na">bottomLeft</span><span class="o">.</span><span class="na">val</span> <span class="o">==</span> <span class="n">n</span><span class="o">.</span><span class="na">bottomRight</span><span class="o">.</span><span class="na">val</span><span class="o">))</span> <span class="o">{</span>
          <span class="n">n</span><span class="o">.</span><span class="na">isLeaf</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
          <span class="n">n</span><span class="o">.</span><span class="na">val</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="na">topLeft</span><span class="o">.</span><span class="na">val</span><span class="o">;</span>
      <span class="o">}</span>
      <span class="k">return</span> <span class="n">n</span><span class="o">;</span>
  <span class="o">}</span>
</pre></table></code></div></div><h3 id="long-pressed-name"><span class="me-2"><a href="https://leetcode.com/problems/long-pressed-name/">Long Pressed Name</a><a name="long-pressed-name"></a></span><a href="#long-pressed-name" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Runtime: 0 ms, faster than 100.00% of Java online submissions for Long Pressed Name.</p><p>Memory Usage: 34.2 MB, less than 100.00% of Java online submissions for Long Pressed Name.</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isLongPressedName</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="nc">String</span> <span class="n">typed</span><span class="o">)</span> <span class="o">{</span>
      <span class="kt">char</span><span class="o">[]</span> <span class="n">n</span> <span class="o">=</span> <span class="n">name</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">();</span>						<span class="c1">// Arrays are much nicer to work with</span>
      <span class="kt">char</span><span class="o">[]</span> <span class="n">t</span> <span class="o">=</span> <span class="n">typed</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">();</span>						<span class="c1">// Record start and stop points for both</span>
      <span class="kt">int</span> <span class="n">startN</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">endN</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="na">length</span><span class="o">,</span> <span class="n">startT</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">endT</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
      <span class="k">while</span> <span class="o">(</span><span class="n">startT</span> <span class="o">&lt;</span> <span class="n">endT</span><span class="o">)</span> <span class="o">{</span>										<span class="c1">// While we haven't looked at the whole string</span>
          <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">startN</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span>									<span class="c1">// Let's first count same consecutive letters</span>
          <span class="kt">int</span> <span class="n">countN</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>												<span class="c1">// in String name</span>
          <span class="k">while</span> <span class="o">(</span><span class="n">temp</span> <span class="o">&lt;</span> <span class="n">endN</span> <span class="o">&amp;&amp;</span> <span class="n">n</span><span class="o">[</span><span class="n">startN</span><span class="o">]</span> <span class="o">==</span> <span class="n">n</span><span class="o">[</span><span class="n">temp</span><span class="o">])</span> <span class="o">{</span>
              <span class="n">temp</span><span class="o">++;</span>
              <span class="n">countN</span><span class="o">++;</span>
          <span class="o">}</span>
          <span class="kt">int</span> <span class="n">countT</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>												<span class="c1">// Do the same for typed string</span>
          <span class="k">while</span> <span class="o">(</span><span class="n">startT</span> <span class="o">&lt;</span> <span class="n">endT</span> <span class="o">&amp;&amp;</span> <span class="n">n</span><span class="o">[</span><span class="n">startN</span><span class="o">]</span> <span class="o">==</span> <span class="n">t</span><span class="o">[</span><span class="n">startT</span><span class="o">])</span> <span class="o">{</span>
              <span class="n">startT</span><span class="o">++;</span>
              <span class="n">countT</span><span class="o">++;</span>
          <span class="o">}</span>																			<span class="c1">// If consecutive letters in typed string are</span>
          <span class="k">if</span> <span class="o">(</span><span class="n">countT</span> <span class="o">&lt;</span> <span class="n">countN</span><span class="o">)</span>									<span class="c1">// less than the ones in original name</span>
              <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>											<span class="c1">// return false</span>
          <span class="n">startN</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>												<span class="c1">// Otherwise, prepare for next character</span>
      <span class="o">}</span>
      <span class="k">return</span> <span class="n">startN</span> <span class="o">==</span> <span class="n">endN</span><span class="o">;</span>										<span class="c1">// Lastly, check if we were able to match</span>
  <span class="o">}</span>																							<span class="c1">// all character of the name string</span>
</pre></table></code></div></div><h3 id="binary-tree-zigzag-level-order-traversal"><span class="me-2"><a href="https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/">Binary Tree Zigzag Level Order Traversal</a><a name="binary-tree-zigzag-level-order-traversal"></a></span><a href="#binary-tree-zigzag-level-order-traversal" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>The idea here is simple. We perform a BFS as usual using a Queue but I maintain a variable called <code class="language-plaintext highlighter-rouge">dir</code> to check which side do I add from. <code class="language-plaintext highlighter-rouge">dir=1</code> means add from Right-&gt;Left and <code class="language-plaintext highlighter-rouge">dir=-1</code> means add from usual Left-&gt;Right. I am also using LinkedList because of easy addition of elements in both direction. When I need to add from Right-&gt;Left, I use the <code class="language-plaintext highlighter-rouge">addFirst(E e)</code> method of LinkedList to add to the head, otherwise normal add to the tail. One important thing to take care of at each iteration is to know how many nodes to dequeue, hence the usage of the variable <code class="language-plaintext highlighter-rouge">children</code>. This allows me to keep track of how many children were added to the queue at each stage so I dequeue exactly that many children in the next stage. Apart from that, everything is straightforward.</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="nf">zigzagLevelOrder</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
      <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
          <span class="k">return</span> <span class="n">list</span><span class="o">;</span>
      <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">TreeNode</span><span class="o">&gt;</span> <span class="n">q</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
      <span class="n">q</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>										<span class="c1">// Children = 1 because only root is added.</span>
      <span class="kt">int</span> <span class="n">dir</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span> <span class="n">children</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>			<span class="c1">// Added the root, so next time dir = 1 (Right-&gt;Left)</span>
      <span class="k">while</span><span class="o">(!</span><span class="n">q</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
          <span class="kt">int</span> <span class="n">pushed</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
          <span class="nc">LinkedList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">l</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
          <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">children</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>		<span class="c1">// Poll only those nodes that were queued in</span>
              <span class="nc">TreeNode</span> <span class="n">u</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>							<span class="c1">// the previous stage.</span>
              <span class="k">if</span> <span class="o">(</span><span class="n">dir</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span>
                  <span class="n">l</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">u</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>
              <span class="k">else</span>
                  <span class="n">l</span><span class="o">.</span><span class="na">addFirst</span><span class="o">(</span><span class="n">u</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>							<span class="c1">// Left-&gt;Right add</span>
              <span class="k">if</span> <span class="o">(</span><span class="n">u</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>								<span class="c1">// Add children, notice I am counting here</span>
                  <span class="n">q</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">u</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>									<span class="c1">// how many children I am pushing/queuing</span>
                  <span class="o">++</span><span class="n">pushed</span><span class="o">;</span>												<span class="c1">// to the queue</span>
              <span class="o">}</span>
              <span class="k">if</span> <span class="o">(</span><span class="n">u</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>							<span class="c1">// Same thing for right child.</span>
                  <span class="n">q</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">u</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
                  <span class="o">++</span><span class="n">pushed</span><span class="o">;</span>
              <span class="o">}</span>
          <span class="o">}</span>
          <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">l</span><span class="o">);</span>														<span class="c1">// Add this list to main list</span>
          <span class="n">children</span> <span class="o">=</span> <span class="n">pushed</span><span class="o">;</span>											<span class="c1">// update # of children pushed</span>
          <span class="n">dir</span> <span class="o">=</span> <span class="n">dir</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">?</span> <span class="o">-</span><span class="mi">1</span><span class="o">:</span> <span class="mi">1</span><span class="o">;</span>									<span class="c1">// update dir for next iteration</span>

      <span class="o">}</span>
      <span class="k">return</span> <span class="n">list</span><span class="o">;</span>
  <span class="o">}</span>
</pre></table></code></div></div><h3 id="array-partition-i"><span class="me-2"><a href="https://leetcode.com/problems/array-partition-i/">Array Partition I</a><a name="array-partition-I"></a></span><a href="#array-partition-i" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Runtime: 3 ms, faster than 99.90% of Java online submissions for Array Partition I.</p><p>Memory Usage: 40.1 MB, less than 100.00% of Java online submissions for Array Partition I.</p><p>I originally came up with the sorting solution where you sort the array and look at two numbers at a time and keep the smaller number out of them and add to the sum. It was way slower, so I checked the fastest submission and this one is pretty smart. The idea is really good. We know there are going to be 20,001 numbers, so reserve an array for it. Now let’s say we had duplicates in our array, ex [1,2,1,4,1,1], if we were to sort it, we would get [1,1,1,1,2,4]. Notice that those four 1’s don’t really matter because each of them pairs up with the other to give you a one 1. That is why we mark those particular indices as true and false. Notice that in our variable <code class="language-plaintext highlighter-rouge">sum</code> we would have counted them individually, making <code class="language-plaintext highlighter-rouge">sum = 4</code> when in fact it should be 2 since we only take one of them from two pairs. If we have even occurrence of any number, they would be false, meaning we don’t need to account them in the <code class="language-plaintext highlighter-rouge">diff</code> calculation. Now coming to <code class="language-plaintext highlighter-rouge">diff</code> how do we compute it? First we have the <code class="language-plaintext highlighter-rouge">seen</code> array to know which elements we need to look at. If that particular index is true, then we check if it’s the first element of the pair which we maintain via the boolean value <code class="language-plaintext highlighter-rouge">firstElemOfPair</code>. If its true, then <code class="language-plaintext highlighter-rouge">first</code> becomes that value. Otherwise, we know that we’re looking at the second element so we update the <code class="language-plaintext highlighter-rouge">diff</code> which is basically that value subtract <code class="language-plaintext highlighter-rouge">first</code>. Notice that if we look at a pair in our example as (2,4), we would pick 2 and the <code class="language-plaintext highlighter-rouge">diff</code> would be 2. This needs to be subtracted from our <code class="language-plaintext highlighter-rouge">sum</code>, hence the reason to maintain both of them. At the end, we finally subtract sum and diff and divide the result by 2 because we were doubling our diff’s too.</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">int</span> <span class="nf">arrayPairSum</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
      <span class="kt">boolean</span><span class="o">[]</span> <span class="n">seen</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="mi">20001</span><span class="o">];</span>
      <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
      <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="nl">n:</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
          <span class="n">seen</span><span class="o">[</span><span class="n">n</span> <span class="o">+</span> <span class="mi">10000</span><span class="o">]</span> <span class="o">=</span> <span class="o">!</span><span class="n">seen</span><span class="o">[</span><span class="n">n</span><span class="o">+</span><span class="mi">10000</span><span class="o">];</span>
          <span class="n">sum</span> <span class="o">+=</span> <span class="n">n</span><span class="o">;</span>
      <span class="o">}</span>
      <span class="kt">int</span> <span class="n">diff</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
      <span class="kt">int</span> <span class="n">first</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
      <span class="kt">boolean</span> <span class="n">firstElemOfPair</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
      <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">seen</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
          <span class="k">if</span> <span class="o">(</span><span class="n">seen</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">{</span>
              <span class="k">if</span> <span class="o">(</span><span class="n">firstElemOfPair</span><span class="o">)</span>
                  <span class="n">first</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
              <span class="k">else</span>
                  <span class="n">diff</span> <span class="o">+=</span> <span class="n">i</span><span class="o">-</span><span class="n">first</span><span class="o">;</span>
              <span class="n">firstElemOfPair</span> <span class="o">=</span> <span class="o">!</span><span class="n">firstElemOfPair</span><span class="o">;</span>
          <span class="o">}</span>
      <span class="o">}</span>
      <span class="k">return</span> <span class="o">(</span><span class="n">sum</span><span class="o">-</span><span class="n">diff</span><span class="o">)/</span><span class="mi">2</span><span class="o">;</span>
  <span class="o">}</span>
</pre></table></code></div></div><h3 id="reshape-the-matrix"><span class="me-2"><a href="https://leetcode.com/problems/reshape-the-matrix/">Reshape the Matrix</a><a name="reshape-the-matrix"></a></span><a href="#reshape-the-matrix" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Runtime: 1 ms, faster than 100.00% of Java online submissions for Reshape the Matrix.</p><p>Memory Usage: 38.4 MB, less than 100.00% of Java online submissions for Reshape the Matrix.</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">int</span><span class="o">[][]</span> <span class="nf">matrixReshape</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">r</span><span class="o">,</span> <span class="kt">int</span> <span class="n">c</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">numsR</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>				                    <span class="c1">// Get rows and col of nums</span>
    <span class="kt">int</span> <span class="n">numsC</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">numsR</span> <span class="o">*</span> <span class="n">numsC</span> <span class="o">!=</span> <span class="n">r</span><span class="o">*</span><span class="n">c</span> <span class="o">||</span> <span class="o">(</span><span class="n">numsR</span> <span class="o">==</span> <span class="n">r</span> <span class="o">&amp;&amp;</span> <span class="n">numsC</span> <span class="o">==</span> <span class="n">c</span><span class="o">))</span>	<span class="c1">// If can't reshape or problems</span>
        <span class="k">return</span> <span class="n">nums</span><span class="o">;</span>									        <span class="c1">// asks to reshape in the same dimensions, return the same array</span>
    <span class="kt">int</span><span class="o">[][]</span> <span class="n">mat</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">r</span><span class="o">][</span><span class="n">c</span><span class="o">];</span>			                    <span class="c1">// New matrix to be returned</span>
    <span class="kt">int</span> <span class="n">row</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">col</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">nR</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">nC</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> 	                <span class="c1">// To keep track of which element to consume and where to place it in the new matrix</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">row</span> <span class="o">!=</span> <span class="n">r</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">mat</span><span class="o">[</span><span class="n">row</span><span class="o">][</span><span class="n">col</span><span class="o">++]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">nR</span><span class="o">][</span><span class="n">nC</span><span class="o">++];</span>	                    <span class="c1">// Increment only the column value for both</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">col</span> <span class="o">==</span> <span class="n">c</span><span class="o">)</span> <span class="o">{</span>								        <span class="c1">// Check if we are at boundary, if so, increment row</span>
            <span class="n">col</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>									        <span class="c1">// and set col to 0 for both cases.</span>
            <span class="o">++</span><span class="n">row</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">nC</span> <span class="o">==</span> <span class="n">numsC</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">nC</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="o">++</span><span class="n">nR</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">mat</span><span class="o">;</span>
  <span class="o">}</span>
</pre></table></code></div></div><h3 id="swap-nodes-in-pairs"><span class="me-2"><a href="https://leetcode.com/problems/swap-nodes-in-pairs/">Swap Nodes in Pairs</a><a name="swap-nodes-in-pairs"></a></span><a href="#swap-nodes-in-pairs" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Runtime: 0 ms, faster than 100.00% of Java online submissions for Swap Nodes in Pairs.</p><p>Memory Usage: 34.5 MB, less than 100.00% of Java online submissions for Swap Nodes in Pairs.</p><p>The idea is simple. We add a dummy node in front for simplicity as it allows us to generalize the concept of getting two nodes at a time. We maintain a current pointer that points to the node in the actual LinkedList. Then, we get it’s next and it’s next.next and store it into n1 and n2. Now notice that before making n2’s next = n1, we need to store n2’s next into n1’s next. After we do that, we need to make sure that current’s next is n2 which is now working with the actual LinkedList. Then, we need to make sure that current.next.next is n1 which we just fixed and update current which is basically n1.</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="nc">ListNode</span> <span class="nf">swapPairs</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">ListNode</span> <span class="n">dummy</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
    <span class="n">dummy</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
    <span class="nc">ListNode</span> <span class="n">curr</span> <span class="o">=</span> <span class="n">dummy</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">curr</span><span class="o">.</span><span class="na">next</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">curr</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">next</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">ListNode</span> <span class="n">n1</span> <span class="o">=</span> <span class="n">curr</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="nc">ListNode</span> <span class="n">n2</span> <span class="o">=</span> <span class="n">n1</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="n">n1</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">n2</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="n">curr</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">n2</span><span class="o">;</span>
        <span class="n">curr</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">n1</span><span class="o">;</span>
        <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">dummy</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="generate-parentheses"><span class="me-2"><a href="https://leetcode.com/problems/generate-parentheses/">Generate Parentheses</a><a name="generate-parentheses"></a></span><a href="#generate-parentheses" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Iterative Approach 1: This one is very slow.</p><p>Runtime: 4 ms, faster than 8.87% of Java online submissions for Generate Parentheses.</p><p>Memory Usage: 36.1 MB, less than 100.00% of Java online submissions for Generate Parentheses.</p><p>The idea is simple. We basically do a BFS and keep track of the parentheses combination we have obtained so far. Poll the queue and check if it’s length is 2*n (for a given n, we would have # of open brackets = # of closed brackets), add it to the list and check next combination. If not, then check if we can add an open bracket, add it and update number of open bracket count and add this combination to the queue. Then try to see if we can add a closed bracket, if you can add it, then update closed bracket count add that combination to the queue. Keep doing this until the queue becomes empty. This is the first approach I came up with which is naive as you can see since it’s doing an exhaustive search for all valid combination.</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre><td class="rouge-code"><pre><span class="kd">private</span> <span class="kd">class</span> <span class="nc">Node</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">data</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">open</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">close</span><span class="o">;</span>

    <span class="nc">Node</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="kt">int</span> <span class="n">o</span><span class="o">,</span> <span class="kt">int</span> <span class="n">c</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">s</span><span class="o">;</span>
        <span class="n">open</span> <span class="o">=</span> <span class="n">o</span><span class="o">;</span>
        <span class="n">close</span> <span class="o">=</span> <span class="n">c</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="nf">generateParenthesis</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
    <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">Node</span><span class="o">&gt;</span> <span class="n">q</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
    <span class="n">q</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="s">"("</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">));</span>
    <span class="k">while</span> <span class="o">(!</span><span class="n">q</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
        <span class="nc">Node</span> <span class="n">u</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">u</span><span class="o">.</span><span class="na">data</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">==</span> <span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="o">)</span>
            <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">u</span><span class="o">.</span><span class="na">data</span><span class="o">);</span>
        <span class="k">else</span> <span class="o">{</span>
            <span class="nc">Node</span> <span class="n">n1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="n">u</span><span class="o">.</span><span class="na">data</span><span class="o">,</span> <span class="n">u</span><span class="o">.</span><span class="na">open</span><span class="o">,</span> <span class="n">u</span><span class="o">.</span><span class="na">close</span><span class="o">);</span>
            <span class="nc">Node</span> <span class="n">n2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="n">u</span><span class="o">.</span><span class="na">data</span><span class="o">,</span> <span class="n">u</span><span class="o">.</span><span class="na">open</span><span class="o">,</span> <span class="n">u</span><span class="o">.</span><span class="na">close</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">n1</span><span class="o">.</span><span class="na">open</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">n1</span><span class="o">.</span><span class="na">data</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="na">data</span> <span class="o">+</span> <span class="sc">'('</span><span class="o">;</span>
                <span class="o">++</span><span class="n">n1</span><span class="o">.</span><span class="na">open</span><span class="o">;</span>
                <span class="n">q</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">n1</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">n2</span><span class="o">.</span><span class="na">close</span> <span class="o">&lt;</span> <span class="n">u</span><span class="o">.</span><span class="na">open</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">n2</span><span class="o">.</span><span class="na">data</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="na">data</span> <span class="o">+</span> <span class="sc">')'</span><span class="o">;</span>
                <span class="o">++</span><span class="n">n2</span><span class="o">.</span><span class="na">close</span><span class="o">;</span>
                <span class="n">q</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">n2</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">list</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><p>Recursive Solution 2: This one is much more faster. I generalized the above idea into the fact that I am adding only valid combinations and any invalid combinations are automatically discarded. The logic is as follows: We know for a given n, the string length should be 2*n. So that forms our base case for recursion, if the length of String <code class="language-plaintext highlighter-rouge">s</code> is <code class="language-plaintext highlighter-rouge">2n</code>, we want to add it to the list. Otherwise, we check if the number of open brackets we have so far is less than <code class="language-plaintext highlighter-rouge">n</code>. If so, we can add an open bracket. Then check if number of close bracket is less than <code class="language-plaintext highlighter-rouge">open</code>, if so that sequence would be valid and add a close bracket and recurse.</p><p>Runtime: 1 ms, faster than 95.16% of Java online submissions for Generate Parentheses. Memory Usage: 36.1 MB, less than 100.00% of Java online submissions for Generate Parentheses.</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="nf">generateParenthesis</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
    <span class="n">helper</span><span class="o">(</span><span class="n">list</span><span class="o">,</span> <span class="s">"("</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">n</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">list</span><span class="o">;</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kt">void</span> <span class="nf">helper</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">,</span> <span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="kt">int</span> <span class="n">open</span><span class="o">,</span> <span class="kt">int</span> <span class="n">close</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">==</span> <span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="o">)</span>
        <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
    <span class="k">else</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">open</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">)</span>
            <span class="n">helper</span><span class="o">(</span><span class="n">list</span><span class="o">,</span> <span class="n">s</span><span class="o">+</span><span class="sc">'('</span><span class="o">,</span> <span class="n">open</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">close</span><span class="o">,</span> <span class="n">n</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">close</span> <span class="o">&lt;</span> <span class="n">open</span><span class="o">)</span>
            <span class="n">helper</span><span class="o">(</span><span class="n">list</span><span class="o">,</span> <span class="n">s</span><span class="o">+</span><span class="sc">')'</span><span class="o">,</span> <span class="n">open</span><span class="o">,</span> <span class="n">close</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">n</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>###<a href="https://leetcode.com/problems/distribute-candies/">Distribute Candies</a><a name="distribute-candies"></a></p><p>Pretty simple solution. We want to give maximize the number of unique candies to give to the sister. So we maintain a hashset to collect all the unique candies first. Both of them get half the candies, so let <code class="language-plaintext highlighter-rouge">s = number of candies they get</code>. Now, if the size of the set is greater than or equal to <code class="language-plaintext highlighter-rouge">s</code>, then the sister only gets <code class="language-plaintext highlighter-rouge">s</code> candies out of it. Otherwise, the maximum amount of unique candies she can get is equal to the set size.</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">int</span> <span class="nf">distributeCandies</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">candies</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;(</span><span class="n">candies</span><span class="o">.</span><span class="na">length</span><span class="o">);</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="nl">i:</span> <span class="n">candies</span><span class="o">)</span>
        <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
    <span class="kt">int</span> <span class="n">share</span> <span class="o">=</span> <span class="n">candies</span><span class="o">.</span><span class="na">length</span><span class="o">/</span><span class="mi">2</span><span class="o">;</span>
    <span class="k">return</span> <span class="n">set</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&gt;=</span> <span class="n">share</span> <span class="o">?</span> <span class="nl">share:</span> <span class="n">set</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="maximum-subproduct-subarray"><span class="me-2"><a href="https://leetcode.com/problems/maximum-product-subarray/">Maximum subproduct subarray</a><a name="maximum-subproduct-subarray"></a></span><a href="#maximum-subproduct-subarray" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Credits for this simplistic solution to LeetCode user <a href="https://leetcode.com/problems/maximum-product-subarray/discuss/48230/Possibly-simplest-solution-with-O(n)-time-complexity">mzchen</a>. The approach is very clever. Notice that if this problem was about finding maximum sum subarray, then a negative number would break the contiguous array. Here, what it does is that it makes our maximum product minimum when we see a negative number and vice versa. We keep track of maximum and minimum we have so far and check if we have a negative number. If so swap our max and min. Then, find the local maximum and minimum between current number and multiplying that number with our current max or min. After that, update our global max value and keep doing this for all values in the array.</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">int</span> <span class="nf">maxProduct</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span> <span class="n">imax</span> <span class="o">=</span> <span class="n">max</span><span class="o">,</span> <span class="n">imin</span> <span class="o">=</span> <span class="n">max</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">imax</span><span class="o">;</span>
            <span class="n">imax</span> <span class="o">=</span> <span class="n">imin</span><span class="o">;</span>
            <span class="n">imin</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="n">imax</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">imax</span> <span class="o">*</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
        <span class="n">imin</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">imin</span> <span class="o">*</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
        <span class="n">max</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">max</span><span class="o">,</span> <span class="n">imax</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">max</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="binary-tree-right-side-view"><span class="me-2"><a href="https://leetcode.com/problems/binary-tree-right-side-view/">Binary Tree Right Side View</a><a name="binary-tree-right-side-view"></a></span><a href="#binary-tree-right-side-view" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Runtime: 1 ms, faster than 95.45% of Java online submissions for Binary Tree Right Side View.</p><p>Memory Usage: 36.3 MB, less than 100.00% of Java online submissions for Binary Tree Right Side View.</p><p>This is an interesting problem cause initially, I thought we would always have a complete binary tree and I made my initial solution oriented towards it. But then I saw that it doesn’t say that anywhere and it could be any kind of binary tree. So it got me thinking towards a more generalized approach. Notice that to get a right side view of the binary tree, we only need the last value at any given level and put it into the list. So we maintain a queue and also the number of elements we enqueue at each stage. Initially, we put the root node in our queue and our enqueue count is 1. We dequeue exactly that many elements and again enqueue each of those dequeued node’s children. Notice that I am using the variable <code class="language-plaintext highlighter-rouge">newEnqueued</code> to keep track of newly enqueued elements. Lastly, we need to check if we dequeued the last element. If so, that must be a part of the solution since it has to be the rightmost element at that level, so I add it to the list. Update <code class="language-plaintext highlighter-rouge">enqueued</code> to the new value and repeat until our queue isn’t empty.</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="nf">rightSideView</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
        <span class="k">return</span> <span class="n">list</span><span class="o">;</span>
    <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">TreeNode</span><span class="o">&gt;</span> <span class="n">q</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
    <span class="n">q</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
    <span class="kt">int</span> <span class="n">enqueued</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(!</span><span class="n">q</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">newEnqueued</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">enqueued</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">TreeNode</span> <span class="n">u</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">u</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">q</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">u</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
                <span class="o">++</span><span class="n">newEnqueued</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">u</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">q</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">u</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
                <span class="o">++</span><span class="n">newEnqueued</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">enqueued</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span>
                <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">u</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="n">enqueued</span> <span class="o">=</span> <span class="n">newEnqueued</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">list</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="find-minimum-in-rotated-sorted-array"><span class="me-2"><a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/submissions/">Find Minimum in Rotated Sorted Array</a><a name="find-minimum-in-rotated-sorted-array"></a></span><a href="#find-minimum-in-rotated-sorted-array" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Runtime: 0 ms, faster than 100.00% of Java online submissions for Find Minimum in Rotated Sorted Array.</p><p>Memory Usage: 38.6 MB, less than 77.27% of Java online submissions for Find Minimum in Rotated Sorted Array.</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">int</span> <span class="nf">findMin</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span>									<span class="c1">// Base case.</span>
        <span class="k">return</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
    <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">mid</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">left</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">nums</span><span class="o">[</span><span class="n">right</span><span class="o">])</span> <span class="o">{</span>		<span class="c1">// While we are in the ascending order half,</span>
        <span class="n">mid</span> <span class="o">=</span> <span class="o">(</span><span class="n">left</span> <span class="o">+</span> <span class="n">right</span><span class="o">)/</span><span class="mi">2</span><span class="o">;</span>						<span class="c1">// Find the middle element</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">mid</span><span class="o">]</span> <span class="o">&gt;=</span> <span class="n">nums</span><span class="o">[</span><span class="n">left</span><span class="o">])</span>			<span class="c1">// If mid element &gt;= left element, then our min</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>								<span class="c1">// must be in the right half.</span>
        <span class="k">else</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span><span class="o">;</span>									<span class="c1">// otherwise min in the left half.</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">nums</span><span class="o">[</span><span class="n">left</span><span class="o">];</span>										<span class="c1">// left points to minimum element.</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="binary-search-tree-iterator"><span class="me-2"><a href="https://leetcode.com/problems/binary-search-tree-iterator/">Binary Search Tree Iterator</a><a name="binary-search-tree-iterator"></a></span><a href="#binary-search-tree-iterator" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Runtime: 15 ms, faster than 99.74% of Java online submissions for Binary Search Tree Iterator.</p><p>Memory Usage: 49.9 MB, less than 93.83% of Java online submissions for Binary Search Tree Iterator.</p><p>Logic is same as your In-Order traversal of any Binary Tree, but store the node values you visit in any data structure. Here I am using an ArrayList for storing each of the visited node’s value. Maintain <code class="language-plaintext highlighter-rouge">idx</code> value to keep track of which value to return. <code class="language-plaintext highlighter-rouge">hasNext()</code> method returns true as long as <code class="language-plaintext highlighter-rouge">idx &lt; list.size()</code>.</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">BSTIterator</span> <span class="o">{</span>
    
    <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">BSTIterator</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="n">traverse</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">traverse</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">node</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="n">traverse</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
        <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>
        <span class="n">traverse</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="cm">/** @return the next smallest number */</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">next</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">idx</span><span class="o">++);</span>
    <span class="o">}</span>
    
    <span class="cm">/** @return whether we have a next smallest number */</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">hasNext</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">idx</span> <span class="o">!=</span> <span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="find-peak-element"><span class="me-2"><a href="https://leetcode.com/problems/find-peak-element/">Find Peak Element</a><a name="find-peak-element"></a></span><a href="#find-peak-element" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>This question was asked to me for my internship at Yahoo! The idea is simple, we want any one of the peak. So to achieve <code class="language-plaintext highlighter-rouge">O(log n)</code> time, we have to mimic binary search algorithm. We look at the middle element and check it’s neighbor, if it’s greater than the middle element, then we know we will have atleast one peak on the right side. Why? Think what could happen. We know that the element next to middle is greater than it, so there are two possibilities on the right side, either elements keep increasing to the right of the middle’s next element or we might go up till a particular index and then go down. So in any case, we will have a peak on the right side. On the other case, if the element on the right side is smaller than the middle, then we know that the left half including the middle will have the peak cause middle is already greater than middle’s right, so we might have middle as the peak itself.</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">int</span> <span class="nf">findPeakElement</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span>
        <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">low</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">],</span> <span class="n">high</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">mid</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">low</span> <span class="o">&lt;</span> <span class="n">high</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">mid</span> <span class="o">=</span> <span class="o">(</span><span class="n">low</span> <span class="o">+</span> <span class="n">high</span><span class="o">)/</span><span class="mi">2</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">mid</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">[</span><span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="o">])</span>
            <span class="n">low</span> <span class="o">=</span> <span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span>
        <span class="k">else</span>
            <span class="n">high</span> <span class="o">=</span> <span class="n">mid</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">low</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="next-permutation"><span class="me-2"><a href="https://leetcode.com/problems/next-permutation/">Next Permutation</a><a name="next-permutation"></a></span><a href="#next-permutation" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Runtime: 0 ms, faster than 100.00% of Java online submissions for Next Permutation.</p><p>Memory Usage: 40.3 MB, less than 47.00% of Java online submissions for Next Permutation.</p><p>This one was quite interesting in the sense it seems difficult but is very simple once you try out a few example. If we want to find the next lexicographical greater number, then we need to find a particular index from the right side of the array such that the number after it is greater than itself, because by swapping them would give us a next larger number. So what I first do is find the index of the number such that <code class="language-plaintext highlighter-rouge">num[idx] &gt; num[idx-1]</code>. We know at this point that all the numbers after that index are reverse sorted, so we need to fix it and sort them in increasing order because lexicographical order demands all the numbers in increasing manner. Example, say <code class="language-plaintext highlighter-rouge">nums = [2,3,1,4,2,1,0]</code>. You can see that that the next number should be <code class="language-plaintext highlighter-rouge">[2,3,2,0,1,1,4]</code>. Notice that I replaced the number at index 2 with the first number which is greater than it if the array after index 2 was sorted. This gaurantees us a larger lexicographical number. So the first while loop finds us that index number and then I reverse the array after it. Once you reverse it, we should expect the <code class="language-plaintext highlighter-rouge">nums</code> array to look like <code class="language-plaintext highlighter-rouge">[2,3,1,0,1,2,4]</code>. Note that now we need to find the number larger than the number at index 2, which is 1 in this case. The first number greater than 1 is 2, so the second while loop finds it and then we simply swap them to give us the next larger lexicographically greater number =&gt; <code class="language-plaintext highlighter-rouge">[2,3,2,0,1,1,4].</code></p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">void</span> <span class="nf">nextPermutation</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="o">)</span>
        <span class="k">return</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">idx</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">idx</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">nums</span><span class="o">[</span><span class="n">idx</span><span class="o">-</span><span class="mi">1</span><span class="o">])</span>
        <span class="o">--</span><span class="n">idx</span><span class="o">;</span>
    <span class="n">reverse</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">idx</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">idx</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
        <span class="k">return</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">idx</span><span class="o">-</span><span class="mi">1</span><span class="o">];</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">idx</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">val</span><span class="o">)</span>
        <span class="o">++</span><span class="n">i</span><span class="o">;</span>
    <span class="n">swap</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">idx</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kt">void</span> <span class="nf">swap</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">,</span> <span class="kt">int</span> <span class="n">idx1</span><span class="o">,</span> <span class="kt">int</span> <span class="n">idx2</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">idx1</span><span class="o">];</span>
    <span class="n">arr</span><span class="o">[</span><span class="n">idx1</span><span class="o">]</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">idx2</span><span class="o">];</span>
    <span class="n">arr</span><span class="o">[</span><span class="n">idx2</span><span class="o">]</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kt">void</span> <span class="nf">reverse</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">,</span> <span class="kt">int</span> <span class="n">start</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">end</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">start</span> <span class="o">&lt;</span> <span class="n">end</span><span class="o">)</span>
        <span class="n">swap</span><span class="o">(</span><span class="n">arr</span><span class="o">,</span> <span class="n">start</span><span class="o">++,</span> <span class="n">end</span><span class="o">--);</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="search-in-rotated-sorted-array"><span class="me-2"><a href="https://leetcode.com/problems/search-in-rotated-sorted-array/">Search in Rotated Sorted Array</a><a name="search-in-rotated-sorted-array"></a></span><a href="#search-in-rotated-sorted-array" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>The idea is same as binary search except you need to keep track of which half to stay in. We compute the middle index and the value at that index. If the middle value is the target, then return that index. Otherwise, find the correct half. If the number on the left side is &lt; middle value then we know that between the left and middle index, values are increasing. We only need to now check if target is &lt; middle value, if so we need to adjust our right pointer otherwise adjust the left pointer. If left value is not &lt; middle value then we are at a shift where the array is pivoted. We again need to confirm now which half to take. There would be some index <code class="language-plaintext highlighter-rouge">i</code> such that <code class="language-plaintext highlighter-rouge">nums[left] &gt; nums[i] &lt; nums[mid]</code> and value are increasing upto <code class="language-plaintext highlighter-rouge">i</code> and shifts from index <code class="language-plaintext highlighter-rouge">i</code> onwards. In this case, we again need to adjust our index pointers and we repeat this loop until <code class="language-plaintext highlighter-rouge">left &lt;= right</code></p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">int</span> <span class="nf">search</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="o">(</span><span class="n">left</span> <span class="o">+</span> <span class="n">right</span><span class="o">)/</span><span class="mi">2</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">midVal</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">mid</span><span class="o">];</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">target</span> <span class="o">==</span> <span class="n">midVal</span><span class="o">)</span>
            <span class="k">return</span> <span class="n">mid</span><span class="o">;</span>
        <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">left</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">midVal</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">target</span> <span class="o">&lt;</span> <span class="n">midVal</span> <span class="o">&amp;&amp;</span> <span class="n">target</span> <span class="o">&gt;=</span> <span class="n">nums</span><span class="o">[</span><span class="n">left</span><span class="o">])</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
            <span class="k">else</span>
                <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">else</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">target</span> <span class="o">&gt;</span> <span class="n">midVal</span> <span class="o">&amp;&amp;</span> <span class="n">target</span> <span class="o">&lt;=</span> <span class="n">nums</span><span class="o">[</span><span class="n">right</span><span class="o">])</span>
                <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span>
            <span class="k">else</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="transpose-matrix"><span class="me-2"><a href="https://leetcode.com/problems/transpose-matrix/">Transpose Matrix</a><a name="transpose-matrix"></a></span><a href="#transpose-matrix" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Pretty straightforward. Create matrix B of opposite dimensions to those of A. We maintain <code class="language-plaintext highlighter-rouge">br</code> and <code class="language-plaintext highlighter-rouge">bc</code> which tracks row and columns of B. We iterate over each element of A and put it in <code class="language-plaintext highlighter-rouge">B[br][bc]</code> and then ideally we would increment <code class="language-plaintext highlighter-rouge">bc</code> for an exact copy, but since we want transpose, we increment <code class="language-plaintext highlighter-rouge">br</code> and then reset it to 0 if we fill all the values in a row and increment column count, giving us the tranpose of the matrix.</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">int</span><span class="o">[][]</span> <span class="nf">transpose</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="no">A</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span><span class="o">[][]</span> <span class="no">B</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="no">A</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">][</span><span class="no">A</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>
    <span class="kt">int</span> <span class="n">br</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">bc</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="no">A</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="no">A</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">)</span> <span class="o">{</span>
            <span class="no">B</span><span class="o">[</span><span class="n">br</span><span class="o">][</span><span class="n">bc</span><span class="o">]</span> <span class="o">=</span> <span class="no">A</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">];</span>
            <span class="k">if</span> <span class="o">(++</span><span class="n">br</span> <span class="o">==</span> <span class="no">B</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">br</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
                <span class="o">++</span><span class="n">bc</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="no">B</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="merge-k-sorted-lists"><span class="me-2"><a href="https://leetcode.com/problems/merge-k-sorted-lists/submissions/">Merge K Sorted Lists</a><a name="merge-k-sorted-lists"></a></span><a href="#merge-k-sorted-lists" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>This was an onsite interview question at ThousandEyes. The idea is simple. Basically, we have multiple sorted lists so we have access to one value at a time, that is head of the lists initially and the consecutive nodes. So we need to fetch the minimum element out of all of them in constant time. The easiest way for us to do this is to use a PriorityQueue and define the logic of comparision of two ListNodes. Then, we add all the nodes inside the PQ and build our resulting List. Fetch the minimum valued ListNode and add it to our list. Then we also need to update that particular list’s head, so we add that list’s next in the PQ so the next time it is fetched, we fetch the correct node of the list. Repeat this until the list is empty and return dummy’s next node.</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="nc">ListNode</span> <span class="nf">mergeKLists</span><span class="o">(</span><span class="nc">ListNode</span><span class="o">[]</span> <span class="n">lists</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">lists</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="nc">PriorityQueue</span><span class="o">&lt;</span><span class="nc">ListNode</span><span class="o">&gt;</span> <span class="n">pq</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PriorityQueue</span><span class="o">&lt;&gt;(</span><span class="n">lists</span><span class="o">.</span><span class="na">length</span><span class="o">,</span> <span class="o">(</span><span class="n">n1</span><span class="o">,</span> <span class="n">n2</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">n1</span><span class="o">.</span><span class="na">val</span> <span class="o">-</span> <span class="n">n2</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>
    <span class="k">for</span> <span class="o">(</span><span class="nc">ListNode</span> <span class="nl">ln:</span> <span class="n">lists</span><span class="o">)</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">ln</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
            <span class="n">pq</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">ln</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">pq</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="nc">ListNode</span> <span class="n">node</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(-</span><span class="mi">1</span><span class="o">);</span>
    <span class="nc">ListNode</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(!</span><span class="n">pq</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
        <span class="n">node</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">next</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
            <span class="n">pq</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">next</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="n">ret</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw me-1"></i> <a href="/categories/problem-solving/">Problem Solving</a>, <a href="/categories/leetcode/">LeetCode</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw me-1"></i> <a href="/tags/leetcode/" class="post-tag no-text-decoration" >leetcode</a> <a href="/tags/leetcode-solution/" class="post-tag no-text-decoration" >leetcode-solution</a></div><div class=" post-tail-bottom d-flex justify-content-between align-items-center mt-5 pb-2 " ><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper d-flex align-items-center"> <span class="share-label text-muted me-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Leetcode%20Solutions%20Cheatsheet%20-%20Samir%20Paul&url=https%3A%2F%2Fsamir.pages.dev%2Fposts%2Fleetcode-solutions-cheatsheet%2F" data-bs-toggle="tooltip" data-bs-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter" > <i class="fa-fw fa-brands fa-square-x-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Leetcode%20Solutions%20Cheatsheet%20-%20Samir%20Paul&u=https%3A%2F%2Fsamir.pages.dev%2Fposts%2Fleetcode-solutions-cheatsheet%2F" data-bs-toggle="tooltip" data-bs-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook" > <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https%3A%2F%2Fsamir.pages.dev%2Fposts%2Fleetcode-solutions-cheatsheet%2F&text=Leetcode%20Solutions%20Cheatsheet%20-%20Samir%20Paul" data-bs-toggle="tooltip" data-bs-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram" > <i class="fa-fw fab fa-telegram"></i> </a> <button id="copy-link" aria-label="Copy link" class="btn small" data-bs-toggle="tooltip" data-bs-placement="top" title="Copy link" data-title-succeed="Link copied successfully!" > <i class="fa-fw fas fa-link pe-none"></i> </button> </span></div></div></div></article></main><aside aria-label="Panel" id="panel-wrapper" class="col-xl-3 ps-2 mb-5 text-muted"><div class="access"><section><h2 class="panel-heading">Trending Tags</h2><div class="d-flex flex-wrap mt-3 mb-1 me-3"> <a class="post-tag btn btn-outline-primary" href="/tags/blog/">blog</a> <a class="post-tag btn btn-outline-primary" href="/tags/computer-science/">computer-science</a> <a class="post-tag btn btn-outline-primary" href="/tags/coding/">coding</a> <a class="post-tag btn btn-outline-primary" href="/tags/system-design/">system-design</a> <a class="post-tag btn btn-outline-primary" href="/tags/design-interview/">design-interview</a> <a class="post-tag btn btn-outline-primary" href="/tags/preparation/">preparation</a> <a class="post-tag btn btn-outline-primary" href="/tags/leetcode/">LeetCode</a> <a class="post-tag btn btn-outline-primary" href="/tags/project/">project</a> <a class="post-tag btn btn-outline-primary" href="/tags/projects/">projects</a> <a class="post-tag btn btn-outline-primary" href="/tags/python/">python</a></div></section></div><section id="toc-wrapper" class="ps-0 pe-4"><h2 class="panel-heading ps-3 pt-2 mb-2">Contents</h2><nav id="toc"></nav></section></aside></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 px-md-4"><aside id="related-posts" aria-labelledby="related-label"><h3 class="mb-4" id="related-label">Further Reading</h3><nav class="row row-cols-1 row-cols-md-2 row-cols-xl-3 g-4 mb-4"><article class="col"> <a href="/posts/leetcode-all-two-pointers-problems/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1679337000" data-df="ll" > Mar 21, 2023 </time><h4 class="pt-0 my-2">LeetCode all two pointers problems</h4><div class="text-muted"><p> | 1. Running from both ends of an array | | — | The first type of problems are, having two pointers at left and right end of array, then moving them to the center while processing something with t...</p></div></div></a></article><article class="col"> <a href="/posts/leetcode-greedy-for-beginners/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1679337000" data-df="ll" > Mar 21, 2023 </time><h4 class="pt-0 my-2">LeetCode Greedy for Beginners</h4><div class="text-muted"><p> Greedy for practice: Sharing good Greedy problems for practice: List: https://leetcode.com/list/xyehq5j6 Sort/Array https://leetcode.com/problems/jump-game/ https://leetcode.com/problems/jump-gam...</p></div></div></a></article></nav></aside><nav class="post-navigation d-flex justify-content-between" aria-label="Post Navigation"> <a href="/posts/curated-list-of-project-based-tutorials/" class="btn btn-outline-primary" aria-label="Older" ><p>Curated List of Project Based Tutorials</p></a> <a href="/posts/list-of-python-frameworks-libraries-software-and-resources/" class="btn btn-outline-primary" aria-label="Newer" ><p>List of Python Frameworks Libraries Software and Resources</p></a></nav><div id="disqus_thread"><p class="text-center text-muted small">Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script type="text/javascript"> var disqus_config = function () { this.page.url = 'https://samir.pages.dev/posts/leetcode-solutions-cheatsheet/'; this.page.identifier = '/posts/leetcode-solutions-cheatsheet/'; }; /* Lazy loading */ var disqus_observer = new IntersectionObserver( function (entries) { if (entries[0].isIntersecting) { (function () { var d = document, s = d.createElement('script'); s.src = 'https://samirpaul.disqus.com/embed.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); })(); disqus_observer.disconnect(); } }, { threshold: [0] } ); disqus_observer.observe(document.querySelector('#disqus_thread')); /* Auto switch theme */ function reloadDisqus() { if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { /* Disqus hasn't been loaded */ if (typeof DISQUS === 'undefined') { return; } if (document.readyState == 'complete') { DISQUS.reset({ reload: true, config: disqus_config }); } } } if (document.querySelector('.mode-toggle')) { window.addEventListener('message', reloadDisqus); } </script><footer aria-label="Site Info" class=" d-flex flex-column justify-content-center text-muted flex-lg-row justify-content-lg-between align-items-lg-center pb-lg-3 " ><p> © <time>2023</time> <a href="https://twitter.com/SamirPaulb">Samir Paul</a>. <span data-bs-toggle="tooltip" data-bs-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author." >Some rights reserved.</span></p><p>Using the <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme for <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a></p></footer></div></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-11 content"><div id="search-hints"><section><h2 class="panel-heading">Trending Tags</h2><div class="d-flex flex-wrap mt-3 mb-1 me-3"> <a class="post-tag btn btn-outline-primary" href="/tags/blog/">blog</a> <a class="post-tag btn btn-outline-primary" href="/tags/computer-science/">computer-science</a> <a class="post-tag btn btn-outline-primary" href="/tags/coding/">coding</a> <a class="post-tag btn btn-outline-primary" href="/tags/system-design/">system-design</a> <a class="post-tag btn btn-outline-primary" href="/tags/design-interview/">design-interview</a> <a class="post-tag btn btn-outline-primary" href="/tags/preparation/">preparation</a> <a class="post-tag btn btn-outline-primary" href="/tags/leetcode/">LeetCode</a> <a class="post-tag btn btn-outline-primary" href="/tags/project/">project</a> <a class="post-tag btn btn-outline-primary" href="/tags/projects/">projects</a> <a class="post-tag btn btn-outline-primary" href="/tags/python/">python</a></div></section></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><aside aria-label="Scroll to Top"> <button id="back-to-top" type="button" class="btn btn-lg btn-box-shadow"> <i class="fas fa-angle-up"></i> </button></aside></div><div id="mask"></div><aside id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-bs-animation="true" data-bs-autohide="false" ><div class="toast-header"> <button type="button" class="btn-close ms-auto" data-bs-dismiss="toast" aria-label="Close" ></button></div><div class="toast-body text-center pt-0"><p class="px-2 mb-3">A new version of content is available.</p><button type="button" class="btn btn-primary" aria-label="Update"> Update </button></div></aside><script src="https://cdn.jsdelivr.net/combine/npm/jquery@3.7.1/dist/jquery.min.js,npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js,npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js,npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.umd.min.js,npm/magnific-popup@1.1.0/dist/jquery.magnific-popup.min.js,npm/clipboard@2.0.11/dist/clipboard.min.js,npm/dayjs@1.11.10/dayjs.min.js,npm/dayjs@1.11.10/locale/en.min.js,npm/dayjs@1.11.10/plugin/relativeTime.min.js,npm/dayjs@1.11.10/plugin/localizedFormat.min.js,npm/tocbot@4.21.2/dist/tocbot.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-CP4QE6ZEV0"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-CP4QE6ZEV0'); }); </script> <script> /* Note: dependent library will be loaded in `js-selector.html` */ SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<article class="px-1 px-sm-2 px-lg-4 px-xl-0"><header><h2><a href="{url}">{title}</a></h2><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div></header><p>{snippet}</p></article>', noResultsText: '<p class="mt-5"></p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="me-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
