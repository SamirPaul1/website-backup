<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Leetcode Solutions Cheatsheet | Samir Paul</title><meta name="author" content="Samir Paul"><meta name="copyright" content="Samir Paul"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="Leetcode Solutions Cheatsheet">
<meta property="og:type" content="article">
<meta property="og:title" content="Leetcode Solutions Cheatsheet">
<meta property="og:url" content="https://samirpaul.in/posts/leetcode-solutions-cheatsheet/index.html">
<meta property="og:site_name" content="Samir Paul">
<meta property="og:description" content="Leetcode Solutions Cheatsheet">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://samirpaul.in/assets/img/leetcode-img-blogpost-leetcode-solutions-cheetsheet-md.webp">
<meta property="article:published_time" content="2023-08-15T04:24:55.000Z">
<meta property="article:modified_time" content="2023-08-08T11:08:15.746Z">
<meta property="article:author" content="Samir Paul">
<meta property="article:tag" content="LeetCode">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://samirpaul.in/assets/img/leetcode-img-blogpost-leetcode-solutions-cheetsheet-md.webp">
<meta name="twitter:creator" content="@SamirPaulb">
<meta name="twitter:site" content="SamirPaulb">
<meta property="fb:app_id" content="6800281970014175"><link rel="shortcut icon" href="/assets/img/favicon.ico"><link rel="canonical" href="https://samirpaul.in/posts/leetcode-solutions-cheatsheet/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""/><meta name="google-site-verification" content="vJAOBxbJTCK2vXG-hLFeGsoC9hXgFlCpuJJ8AcJLROQ"/><meta name="yandex-verification" content="fe6a06c57be84984"/><meta name="msvalidate.01" content="1A92FC2EC113F8616A21D76DA684A133"/><meta name="p:domain_verify" content="24bac6e1fbf1750de40d59bb788d9dd9"/><meta name="norton-safeweb-site-verification" content="j7w6winrjctu1-mcfpposj35ae-2txdr3qhqt9edmam0gf98j9qtpixft-qv452wjund2cyc9jacd71w81ee6addfggzcmr-affl9b3eblxul7768d9d5dh2fjkupp1h"/><meta name="facebook-domain-verification" content="3pkgruuk3kzlsn3jdfehgbd4sem1qb"/><link rel="manifest" href="/manifest.json"/><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"/><link rel="mask-icon" href="/assets/img/favicons/safari-pinned-tab.svg" color="#5bbad5"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="/pluginsSrc/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="/pluginsSrc/@fancyapps/ui/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script async="async" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle = window.adsbygoogle || []).push({
  google_ad_client: 'ca-pub-8274401353019049',
  enable_page_level_ads: 'true'
});</script><script async="async" src="https://www.googletagmanager.com/gtag/js?id=G-CP4QE6ZEV0"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-CP4QE6ZEV0');
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: 'days',
  dateSuffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: '/pluginsSrc/flickr-justified-gallery/dist/fjGallery.min.js',
      css: '/pluginsSrc/flickr-justified-gallery/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: true,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Leetcode Solutions Cheatsheet',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-08-08 16:38:15'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link href="/sitemap.xml" rel="sitemap" title="Sitemap" type="application/xml" /><link href="//fonts.googleapis.com" rel="preconnect dns-prefetch" /><link href="//use.fontawesome.com" rel="preconnect dns-prefetch" /><link href="//ajax.googleapis.com" rel="preconnect dns-prefetch" /><link href="//github.com" rel="preconnect dns-prefetch" /><link href="//cdn.rawgit.com" rel="preconnect dns-prefetch" /><link href="//cdnjs.cloudflare.com" rel="preconnect dns-prefetch" /><link href="//www.google-analytics.com" rel="preconnect dns-prefetch" /><link href="//themes.googleusercontent.com " rel="preconnect dns-prefetch" /><link href="//pagead2.googlesyndication.com" rel="preconnect dns-prefetch" /><link href="//googleads.g.doubleclick.net" rel="preconnect dns-prefetch" /><link href="//www.gstatic.com" rel="preconnect dns-prefetch" /><link href="//www.googletagmanager.com" rel="preconnect dns-prefetch" /><link href="//www.googletagservices.com" rel="preconnect dns-prefetch" /><link href="//static.xx.fbcdn.net" rel="preconnect dns-prefetch" /><link href="//tpc.googlesyndication.com" rel="preconnect dns-prefetch" /><link href="//apis.google.com" rel="preconnect dns-prefetch" /><link href="//www.w3.org" rel="preconnect dns-prefetch" /><link href="//www.facebook.com" rel="preconnect dns-prefetch" /><link href="//connect.facebook.net" rel="preconnect dns-prefetch" /><link href="//disqus.com" rel="preconnect dns-prefetch" /><link href="//plus.google.com" rel="preconnect dns-prefetch" /><link href="//twitter.com" rel="preconnect dns-prefetch" /><link href="//platform.twitter.com" rel="preconnect dns-prefetch" /><link href="//syndication.twitter.com" rel="preconnect dns-prefetch" /><link href="//r.twimg.com " rel="preconnect dns-prefetch" /><link href="//p.twitter.com " rel="preconnect dns-prefetch" /><link href="//cdn.api.twitter.com " rel="preconnect dns-prefetch" /><link href="//www.youtube.com" rel="preconnect dns-prefetch" /><link href="//img.youtube.com" rel="preconnect dns-prefetch" /><link href="//www.pinterest.com" rel="preconnect dns-prefetch" /><link href="//www.linkedin.com" rel="preconnect dns-prefetch" /><link href="//player.vimeo.com" rel="preconnect dns-prefetch" /><link href="//s3.amazonaws.com " rel="preconnect dns-prefetch" /><link href="//s3.buysellads.com " rel="preconnect dns-prefetch" /><link href="//stats.buysellads.com " rel="preconnect dns-prefetch" /><link href="//scdn.netlify.app " rel="preconnect dns-prefetch" /><link href="//spcdn.pages.dev " rel="preconnect dns-prefetch" /><link href="//scdn.web.app " rel="preconnect dns-prefetch" /><link href="//user-images.githubusercontent.com " rel="preconnect dns-prefetch" /><link href="//raw.githubusercontent.com " rel="preconnect dns-prefetch" /><link href="//cdn.jsdelivr.net " rel="preconnect dns-prefetch" /><link href="//res.cloudinary.com " rel="preconnect dns-prefetch" /><link href="//samirpaulb.github.io " rel="preconnect dns-prefetch" /><link href="//imgur.com " rel="preconnect dns-prefetch" /><link href="//i.imgur.com " rel="preconnect dns-prefetch" /><link href="//firebaseio.com " rel="preconnect dns-prefetch" /><link href="//translate.googleapis.com " rel="preconnect dns-prefetch" /><link href="//google.com " rel="preconnect dns-prefetch" /><link href="//analytics.google.com " rel="preconnect dns-prefetch" /><meta name="robots" content="index, follow"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/feed.xml" title="Samir Paul" type="application/atom+xml">
<link rel="alternate" href="/index.xml" title="Samir Paul" type="application/rss+xml">
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/img/avatar.webp" onerror="onerror=null;src='/assets/img/404.webp'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/posts/"><div class="headline">Articles</div><div class="length-num">1314</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">74</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">9</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-heart"></i><span> Let's Connect</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.linkedin.com/in/samirpaul"><i class="fa-fw fab fa-linkedin"></i><span> LinkedIn</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://github.com/SamirPaul1"><i class="fa-fw fab fa-github"></i><span> GitHub</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://instagram.com/SamirPaulb"><i class="fa-fw fab fa-instagram"></i><span> Instagram</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.facebook.com/SamirPaulb"><i class="fa-fw fab fa-facebook"></i><span> Facebook</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://twitter.com/SamirPaulb"><i class="fa-fw fab fa-twitter"></i><span> Twitter</span></a></li><li><a class="site-page child" href="/contact"><i class="fa-fw fa-regular fa-paper-plane"></i><span> Contact</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Samir Paul"><span class="site-name">Samir Paul</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> Search</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-heart"></i><span> Let's Connect</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.linkedin.com/in/samirpaul"><i class="fa-fw fab fa-linkedin"></i><span> LinkedIn</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://github.com/SamirPaul1"><i class="fa-fw fab fa-github"></i><span> GitHub</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://instagram.com/SamirPaulb"><i class="fa-fw fab fa-instagram"></i><span> Instagram</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.facebook.com/SamirPaulb"><i class="fa-fw fab fa-facebook"></i><span> Facebook</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://twitter.com/SamirPaulb"><i class="fa-fw fab fa-twitter"></i><span> Twitter</span></a></li><li><a class="site-page child" href="/contact"><i class="fa-fw fa-regular fa-paper-plane"></i><span> Contact</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">Leetcode Solutions Cheatsheet</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2023-08-15T04:24:55.000Z" title="Created 2023-08-15 09:54:55">2023-08-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2023-08-08T11:08:15.746Z" title="Updated 2023-08-08 16:38:15">2023-08-08</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/LeetCode/">LeetCode</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word count:</span><span class="word-count">42.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading time:</span><span>264min</span></span></div></div></div><article class="post-content" id="article-container"><h2 id="Quick-Access-Links"><a href="#Quick-Access-Links" class="headerlink" title="Quick Access Links"></a>Quick Access Links</h2><h3 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a>LeetCode</h3><ul>
<li>LeetCode - CheatSheet<ul>
<li>Getting Started<ul>
<li>Prerequisites</li>
</ul>
</li>
<li>Built With</li>
<li>Authors</li>
<li>Acknowledgments</li>
<li><a href="#quick-access-links">Quick Access Links</a><ul>
<li><a href="#leetcode">LeetCode</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#1-two-sum">1-Two Sum</a><ul>
<li><a href="#brute-force">Brute Force</a></li>
<li><a href="#one-pass-hash-table">One Pass Hash Table</a></li>
</ul>
</li>
<li><a href="#2-add-two-numbers">2-Add Two Numbers</a><ul>
<li><a href="#elementary-math-solution">Elementary Math Solution</a></li>
</ul>
</li>
<li><a href="#3-substring-no-repeat">3-Substring No Repeat</a><ul>
<li><a href="#brute-force-1">Brute Force</a></li>
<li><a href="#sliding-window">Sliding Window</a></li>
<li><a href="#sliding-window-optimized">Sliding Window Optimized</a></li>
</ul>
</li>
<li><a href="#4-median-of-two-sorted-arrays">4-Median of Two Sorted Arrays</a><ul>
<li><a href="#recursive-approach">Recursive Approach</a></li>
</ul>
</li>
<li><a href="#5-longest-palindromic-substring">5-Longest Palindromic Substring</a><ul>
<li><a href="#longest-common-substring">Longest Common Substring</a></li>
<li><a href="#brute-force-2">Brute Force</a></li>
<li><a href="#dynamic-programming">Dynamic Programming</a></li>
<li><a href="#expand-around-center">Expand Around Center</a></li>
<li><a href="#manachers-algorithm">Manacher’s Algorithm</a></li>
</ul>
</li>
<li><a href="#6-zigzag-conversion">6-ZigZag Conversion</a><ul>
<li><a href="#sort-by-row">Sort by Row</a></li>
<li><a href="#visit-by-row">Visit by Row</a></li>
</ul>
</li>
<li><a href="#7-reverse-integer">7-Reverse Integer</a><ul>
<li><a href="#pop-and-push-digits-and-check-before-overflow">Pop and Push Digits and Check Before Overflow</a></li>
</ul>
</li>
<li><a href="#8-string-to-integer-atoi">8-String to Integer (atoi)</a><ul>
<li><a href="#ascii-conversion">ASCII Conversion</a></li>
</ul>
</li>
<li><a href="#9-palindrome-number">9-Palindrome Number</a><ul>
<li><a href="#revert-half-of-the-number">Revert Half of the Number</a></li>
</ul>
</li>
<li><a href="#10-regular-expression-matching">10-Regular Expression Matching</a><ul>
<li><a href="#recursion">Recursion</a></li>
<li><a href="#dynamic-programming-1">Dynamic Programming</a></li>
<li><a href="#non-recursive">Non-Recursive</a></li>
</ul>
</li>
<li><a href="#11-container-with-the-most-water">11-Container with the Most Water</a><ul>
<li><a href="#brute-force-3">Brute Force</a></li>
<li><a href="#two-pointer-approach">Two Pointer Approach</a></li>
</ul>
</li>
<li><a href="#12-integer-to-roman">12-Integer To Roman</a><ul>
<li><a href="#string-array">String Array</a></li>
</ul>
</li>
<li><a href="#13-roman-to-integer">13-Roman to Integer</a><ul>
<li><a href="#character-array">Character Array</a></li>
</ul>
</li>
<li><a href="#14-longest-common-prefix">14-Longest Common Prefix</a><ul>
<li><a href="#horizontal-scanning">Horizontal Scanning</a></li>
<li><a href="#vertical-scanning">Vertical Scanning</a></li>
<li><a href="#divide-and-conquer">Divide and Conquer</a></li>
<li><a href="#binary-search">Binary Search</a></li>
<li><a href="#further-thoughts">Further Thoughts</a></li>
</ul>
</li>
<li><a href="#15-3sum">15-3Sum</a><ul>
<li><a href="#sorted-array">Sorted Array</a></li>
</ul>
</li>
<li><a href="#16-3sum-closest">16-3Sum Closest</a><ul>
<li><a href="#3-pointers">3 Pointers</a></li>
</ul>
</li>
<li><a href="#17-letter-combinations-of-a-phone-number">17-Letter Combinations of a Phone Number</a><ul>
<li><a href="#backtracking">Backtracking</a></li>
<li><a href="#first-in-first-out-fifo-queue">First In First Out (FIFO) Queue</a></li>
</ul>
</li>
<li><a href="#18-4sum">18-4Sum</a><ul>
<li><a href="#sorted-array-1">Sorted Array</a></li>
</ul>
</li>
<li><a href="#19-remove-nth-node-from-end-of-list">19-Remove Nth Node From End of List</a><ul>
<li><a href="#two-pass-algorithm">Two Pass Algorithm</a></li>
<li><a href="#one-pass-algorithm">One Pass Algorithm</a></li>
</ul>
</li>
<li><a href="#20-valid-parentheses">20-Valid Parentheses</a><ul>
<li><a href="#counting-method">Counting method</a></li>
<li><a href="#stacks">Stacks</a></li>
</ul>
</li>
<li><a href="#21-merge-two-sorted-lists">21-Merge Two Sorted Lists</a><ul>
<li><a href="#recursive">Recursive</a></li>
<li><a href="#non-recursive-1">Non-Recursive</a></li>
</ul>
</li>
<li><a href="#22-generate-parentheses">22-Generate Parentheses</a><ul>
<li><a href="#brute-force-4">Brute Force</a></li>
<li><a href="#backtracking-1">Backtracking</a></li>
<li><a href="#closure-number">Closure Number</a></li>
</ul>
</li>
<li><a href="#23-merge-k-sorted-lists">23-Merge k Sorted Lists</a><ul>
<li><a href="#brute-force-5">Brute Force</a></li>
</ul>
</li>
<li><a href="#146-lru-cache">146-LRU Cache</a></li>
</ul>
<p><a name="twoSum"></a></p>
<h1 id="1-Two-Sum"><a href="#1-Two-Sum" class="headerlink" title="1-Two Sum"></a>1-Two Sum</h1><p>Given an array of integers, return <strong>indices</strong> of the two numbers such that they add up to a specific target.<br>You may assume that each input would have <strong>exactly one solution</strong>, and you may not use the same element twice.</p>
<p>Example:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Given nums = [2, 7, 11, 15], target = 9,</span><br><span class="line"></span><br><span class="line">Because nums[0] + nums[1] = 2 + 7 = 9,</span><br><span class="line">return [0, 1].</span><br></pre></td></tr></table></figure>

<p><br><br><br><a name="twoSumBruteForce"></a></p>
<h2 id="Brute-Force"><a href="#Brute-Force" class="headerlink" title="Brute Force"></a>Brute Force</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;nums.size; i++)&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;nums.length;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span> (nums[j]==target-nums[i])&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;i,j&#125;;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;No two sum solution&quot;</span>);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p><strong>Complexity Analysis</strong> </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* Time complexity:   O(n^2)       we have a nested loop </span><br><span class="line">* Space complexity:  O(1) 	  we do not allocate any additional memory</span><br></pre></td></tr></table></figure>
<p><a name="twoSumOnePassHashTable"></a></p>
<h2 id="One-Pass-Hash-Table"><a href="#One-Pass-Hash-Table" class="headerlink" title="One Pass Hash Table"></a>One Pass Hash Table</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">	Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++)&#123;</span><br><span class="line">		<span class="type">int</span> complement=target-nums[i];</span><br><span class="line">		<span class="keyword">if</span> (map.containsKey(complement))&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;map.get(complement),i&#125;;</span><br><span class="line">		&#125;</span><br><span class="line">		map.put(nums[i],i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;No two sum solution&quot;</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Complexity Analysis</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* Time complexity:   O(n)		each lookup in the hash table only requires O(1) time</span><br><span class="line">* Space complexity:  O(n)		we require additional space for the hash table which stores at most n</span><br></pre></td></tr></table></figure>

<p><br><br><br></p>
<hr>
<p><a name="addTwoNumbers"></a></p>
<h1 id="2-Add-Two-Numbers"><a href="#2-Add-Two-Numbers" class="headerlink" title="2-Add Two Numbers"></a>2-Add Two Numbers</h1><p>Given two non-empty linked lists representing two non-negative integers with the digits stored in<br>reverse order and each node containing a single digit, add the two numbers and return as a linked list</p>
<p>Example: </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4) </span><br><span class="line">Output 7 -&gt; 0 -&gt; 8 </span><br><span class="line"></span><br><span class="line">342 + 465 = 807</span><br></pre></td></tr></table></figure>


<p><br><br><br><a name="addTwoNumbersElementaryMath"></a></p>
<h2 id="Elementary-Math-Solution"><a href="#Elementary-Math-Solution" class="headerlink" title="Elementary Math Solution"></a>Elementary Math Solution</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">        ListNode dummyHead= <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>); </span><br><span class="line">        ListNode p=l1, q=l2, curr=dummyHead; </span><br><span class="line">        <span class="type">int</span> carry=<span class="number">0</span>; </span><br><span class="line">        <span class="keyword">while</span> (p!=<span class="literal">null</span>||q!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">int</span> x= (p!=<span class="literal">null</span>) ? p.val :<span class="number">0</span>; <span class="comment">//if (p!=null) then x contains p.val</span></span><br><span class="line">            <span class="type">int</span> y= (q!=<span class="literal">null</span>) ? q.val :<span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> sum=carry+x+y;</span><br><span class="line">            carry=sum/<span class="number">10</span>;</span><br><span class="line">            curr.next=<span class="keyword">new</span> <span class="title class_">ListNode</span>(sum%<span class="number">10</span>);</span><br><span class="line">            curr=curr.next; </span><br><span class="line">            <span class="keyword">if</span> (p!=<span class="literal">null</span>) p=p.next; </span><br><span class="line">            <span class="keyword">if</span> (q!=<span class="literal">null</span>) q=q.next; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (carry&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            curr.next= <span class="keyword">new</span> <span class="title class_">ListNode</span>(carry);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyHead.next; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Complexity analysis</strong> </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* Time Complexity:  O(max(m,n))         depends on the lengths of the two linked lists </span><br><span class="line">* Space Complexity: O(max(m,n))		the maximum length of the new list is max(m,n)+1</span><br></pre></td></tr></table></figure>


<p><br><br><br></p>
<hr>
<p><a name="substringNoRepeat"></a></p>
<h1 id="3-Substring-No-Repeat"><a href="#3-Substring-No-Repeat" class="headerlink" title="3-Substring No Repeat"></a>3-Substring No Repeat</h1><p>Longest Substring Without Repeating Characters </p>
<p>Given a string find the length of the longest substring without repeating characters. </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Example</span><br><span class="line">Input: 		&quot;abcabcbb&quot;</span><br><span class="line">Output:		3</span><br><span class="line">Explanation:	The answer is &quot;abc&quot;, with the length of 3</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Example 2</span><br><span class="line">Input:		&quot;bbbbb&quot;</span><br><span class="line">Output:		1</span><br><span class="line">Explanation:	The answer is &quot;b&quot;, with the length of 1</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Example 3</span><br><span class="line">Input:		&quot;pwwkew&quot;</span><br><span class="line">Output:		3</span><br><span class="line">Explanation: 	The answer is &quot;wke&quot;, with the length of 3. Note that the answer must be a substring</span><br><span class="line">		&quot;pwke&quot; is a subsequence and not a substring </span><br></pre></td></tr></table></figure>

<p><br><br><br><a name="substringNoRepeatBruteForce"></a></p>
<h2 id="Brute-Force-1"><a href="#Brute-Force-1" class="headerlink" title="Brute Force"></a>Brute Force</h2><p><em>Algorithm</em> </p>
<p>Suppose we have a function “boolean allUnique(String substring)” which returns true if all the<br>characters in the substring are unique and false otherwise. We can iterate through all the possible<br>substrings of the given string s and call the function allUnique. If it turns out to be true, then we<br>update our answer of the maximum length of substring without duplicate characters. </p>
<p>To enumerate all substrings of a given string we enumerate the start and end indices of them. Suppose<br>the start and end indices are i and j respectively. Then we have 0 &lt;&#x3D; i &lt;&#x3D; j &lt;&#x3D; n. Thus using two<br>nested loops with i from 0 to n-1 and j from i+1 to n, we can enumerate all the substrings of s</p>
<p>To check if one string has duplicate characters we can use a set. We iterate through all the<br>characters in the string and put them into the set one by one. Before putting one character, we check<br>if the set already contains it. If so we return false and after the loop we return true.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">                <span class="keyword">if</span> (allUnique(s, i, j)) ans = Math.max(ans, j - i);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">allUnique</span><span class="params">(String s, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        Set&lt;Character&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; end; i++) &#123;</span><br><span class="line">            <span class="type">Character</span> <span class="variable">ch</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (set.contains(ch)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            set.add(ch);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Complexity Analysis</strong> </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">* Time Complexity:   O(n^3)		Verifying if characters in   [i,j) are unique requires us to scan all of</span><br><span class="line">					them which would cost O(j-i) time. </span><br><span class="line"></span><br><span class="line">					For a given i, the sum of time costed by each j -&gt; [i+1,n] is </span><br><span class="line">					&quot;Summation from i+1 to n O(j-1)&quot;</span><br><span class="line"></span><br><span class="line">					Thus, the sum of all the time consumption is: </span><br><span class="line">					O(summation from 0 to n-1(summation from j=i+1 to n (j-1))) </span><br><span class="line">					O(summation from i=0 to n-1(1+n-i)(n-i)/2)) = O(n^3)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">					*Note that the sum of all numbers up to n 1+2+3+...+n = n(n+1)/2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">* Space Complexity:  O(min(n,m))	We require O(k) space for checking a substring has no duplicate </span><br><span class="line">					characters, where k is the size of the set. The size of the Set is </span><br><span class="line">					upper bounded by the size of the string n amd the size of the charset</span><br><span class="line">					or alphabet m </span><br><span class="line">				</span><br><span class="line">				</span><br></pre></td></tr></table></figure>

<p><br><br><br><a name="substringNoRepeatSlidingWindow"></a></p>
<h2 id="Sliding-Window"><a href="#Sliding-Window" class="headerlink" title="Sliding Window"></a>Sliding Window</h2><p>A sliding window is an abstract concept commonly used in array&#x2F;string problems. A window is a range of<br>elements in the array&#x2F;string which usually defined by the start and end indices</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ex. [i,j) left-closed, right-open</span><br></pre></td></tr></table></figure>
<p>A sliding window is a window that slides its two boundaries in a certain direction, for example if we<br>slide [i,j) to the right by 1 element, then it becomes [i+1, j+1) - left closed, right open.</p>
<p>Sliding Window approach, whenever we are looking at a section on an array usual to perform calculations<br>we don’t need to completely recalculate everything for every section of the array. Usually we can use<br>the value obtained from another section of the array to determine something about this section of the<br>array. For example if we are calculating the sum of sections of an array we can use the previously<br>calculated value of a section to determine the sum of an adjacent section in the array. </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ex. 1 2 3 4 5 6 7 8 </span><br></pre></td></tr></table></figure>
<p>If we calculate the first section of four values we get 1+2+3+4 &#x3D; 10 , then to calculate the next section<br>2+3+4+5 we can just take our first section (window_sum) and perform the operation: </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window_sum-first entry + last entry = 10-1+5= 14</span><br></pre></td></tr></table></figure>
<p>So essentially for the window sliding technique we use what we know about an existing window to<br>determine properties for another window. </p>
<p><br><br><br><em>Algorithm</em></p>
<p>In the brute force approach, we repeatedly check a substring to see if it has duplicate characters but<br>this is unnecessary. If a substring from index i to j-1 is already checked to have no duplicate<br>characters we only need to check if s[j] is already in the substring. </p>
<p>To check if a character is already in the substring we can scan the substring which leads to an O(n^2)<br>algorithm but we can improve on this runtime using a HashSet as a sliding window to check if a<br>character exists in the current set O(1). </p>
<p>We use a HashSet to store the characters in the current window [i,j) and then we slide the index j to<br>the right, if it is not in the HashSet, we slide j further until s[j] is already in the HashSet. At<br>this point we found the maximum size of substrings without duplicate characters starting with index i.<br>If we do this for all i, then we obtain our answer. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        Set&lt;Character&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>, i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n &amp;&amp; j &lt; n) &#123;</span><br><span class="line">            <span class="comment">// try to extend the range [i, j]</span></span><br><span class="line">            <span class="keyword">if</span> (!set.contains(s.charAt(j)))&#123;</span><br><span class="line">                set.add(s.charAt(j++));</span><br><span class="line">                ans = Math.max(ans, j - i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                set.remove(s.charAt(i++));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Complexity Analysis</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Time complexity:	O(2n)=O(n)	Worst case each character will be visited twice by i and j</span><br><span class="line"></span><br><span class="line">Space complexity: 	O(min(m,n))	Same as the brute force method, we need O(k) space for the </span><br><span class="line">					sliding window where k is the size of the set. The size of the</span><br><span class="line">					set is bounded by the size of the string n and the size of the</span><br><span class="line">					charset/alphabet m</span><br></pre></td></tr></table></figure>


<p><br><br><br><a name="substringNoRepeatOptimized"></a></p>
<h2 id="Sliding-Window-Optimized"><a href="#Sliding-Window-Optimized" class="headerlink" title="Sliding Window Optimized"></a>Sliding Window Optimized</h2><p>The previously discussed sliding window approach requires at most 2n steps and this could in fact be<br>optimized even further to require only n steps. Instead of using a set to tell if a character exists or<br>not, we could define a mapping of the characters to its index. Then we can skip the characters<br>immediately when we found a repeated character </p>
<p>If s[j] has a duplicate in the range [i , j) with index j’, we don’t need to increase i little be little<br>we can just skip all the elements in the range [i , j’] and let i be j’+1 directly </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length(), ans = <span class="number">0</span>;</span><br><span class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(); <span class="comment">// current index of character</span></span><br><span class="line">        <span class="comment">// try to extend the range [i, j]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>, i = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(s.charAt(j))) &#123;</span><br><span class="line">                i = Math.max(map.get(s.charAt(j)), i);</span><br><span class="line">            &#125;</span><br><span class="line">            ans = Math.max(ans, j - i + <span class="number">1</span>);</span><br><span class="line">            map.put(s.charAt(j), j + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><br><br><br></p>
<hr>
<p><a name="medianofTwoSortedArrays"></a></p>
<h1 id="4-Median-of-Two-Sorted-Arrays"><a href="#4-Median-of-Two-Sorted-Arrays" class="headerlink" title="4-Median of Two Sorted Arrays"></a>4-Median of Two Sorted Arrays</h1><p>There are two sorted arrays num1 and num2 of size m and n respectively. Find the median of the two<br>sorted arrays. The overall run time complexity should be O(log (m+n)). You may assume nums1 and nums2<br>cannot be both empty. </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Example </span><br><span class="line"></span><br><span class="line">nums1 = [1, 3] </span><br><span class="line">nums2 = [2]</span><br><span class="line"></span><br><span class="line">The median is 2.0</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Example 2</span><br><span class="line"></span><br><span class="line">nums1= [1, 2] </span><br><span class="line">nums2= [3, 4] </span><br><span class="line"></span><br><span class="line">The median is (2+3)/2 = 2.5</span><br></pre></td></tr></table></figure>


<p><br><br><br><a name="medianofTwoSortedArraysRecursiveApproach"></a></p>
<h2 id="Recursive-Approach"><a href="#Recursive-Approach" class="headerlink" title="Recursive Approach"></a>Recursive Approach</h2><p>In statistics the median is used for dividing a set into two equal length subsets with one set being<br>always greater than the other set. To approach this problem first we cut A into two parts at a random<br>position i: </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">       left_A                |           right_A </span><br><span class="line"></span><br><span class="line">A[0], A[1], ... , A[i-1]         A[i], A[i+1], ... , A[m-1]</span><br></pre></td></tr></table></figure>

<p>Since A has m elements, there are m+1 kinds of cutting as i can range from 0-m. We can also see that<br>left_A is empty when i is zero and right_A is empty when i&#x3D;m</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">len(left_A) = i and len(right_A)= m-i</span><br></pre></td></tr></table></figure>

<p>We can similarly cut B into two parts at a random position j: </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">left_B			|	right_B</span><br><span class="line"></span><br><span class="line"> B[0], B[1], ... , B[j-1]	   B[j], B[j+1], ... , B[n-1]</span><br></pre></td></tr></table></figure>
<p>Now if we put left_A and left_B into one set and put right_A and right_B into another set and name<br>them left_part and right_part, then we get</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">left_part		|	right_part</span><br><span class="line"> A[0], A[1], ... , A[i-1]	  A[i], A[i+1], ... , A[m-1]</span><br><span class="line"> B[0], B[1], ... , B[j-1]	  B[j], B[j+1], ... , B[n-1]</span><br></pre></td></tr></table></figure>

<p>If we can ensure that </p>
<ol>
<li>the len(left_part) &#x3D; len(right_part)</li>
<li>max(left_part) &lt;&#x3D; min(right_part)</li>
</ol>
<p>then we divide all the elements in {A,B} into two parts with equal length and one part is always<br>greater than the other. Then </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">median= (max(left_part)+min(right_part))/2</span><br></pre></td></tr></table></figure>
<p>To ensure these two conditions, we need to ensure: </p>
<ol>
<li>i+j&#x3D; m-i+n-j (or: m-i+n-j+1) if n&gt;m, we just need to set i&#x3D;0~m, j&#x3D; (m+n+1)&#x2F;2 - i</li>
<li>B[j-1]&lt;&#x3D;A[i] and A[i-1]&lt;&#x3D;B[j]</li>
</ol>
<p>So, all we need to do is search for i in [0,m] to find an object i such that<br>B[j-1]&lt;&#x3D;A[i] and A[i-1]&lt;&#x3D;B[j] where j&#x3D;(m+n+1)&#x2F;2 -i</p>
<p>Then we perform a binary search following the steps described below: </p>
<ol>
<li>Set imin&#x3D;0, imax&#x3D;0, then start searching in [imin, imax]</li>
<li>Set i&#x3D;(imin+imax)&#x2F;2 , j&#x3D;(m+n+1)&#x2F;2 - i</li>
<li>Now we have len(left_part) &#x3D; len(right_part) and there are only 3 more situations which we may<br>encounter:</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- B[j-1] &lt;= A[i] and A[i-1]&lt;=B[j] </span><br><span class="line">  This means that we have found the object i, so we can stop searching</span><br><span class="line"></span><br><span class="line">- B[j-1] &gt; A[i]</span><br><span class="line">  Means A[i] is too small, we must adjust i to get B[j-1]&lt;=A[i] so we increase i because this will</span><br><span class="line">  cuase j to be decreased. We cannot decrease i because when i is decreased, j will be increased</span><br><span class="line">  so B[j-1] is increased and A[i] is decreased (B[j-1]&lt;= A[i] will never be satisfied)</span><br><span class="line"></span><br><span class="line">- A[i-1] &gt; B[j] </span><br><span class="line">  Means A[i-1] is too big and thus we must decrease i to get A[i-1]&lt;=B[j]. In order to do that we </span><br><span class="line">  must adjust the searching range to [imin, i-1] so we set imax=i-1 and go back to step 2</span><br></pre></td></tr></table></figure>
<p>When the object i is found, then the media is: </p>
<p> max(A[i-1],B[j-1]), when m+n is odd<br>(max(A[i-1],B[j-1])+min(A[i],B[j]))&#x2F;2, when m+n is even</p>
<p>Next is to consider the edge values i&#x3D;0, i&#x3D;m, j&#x3D;0, j&#x3D;n where A[i-1], B[j-1], A[i], B[j] may not exist</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findMedianSortedArrays</span><span class="params">(<span class="type">int</span>[] A, <span class="type">int</span>[] B)</span> &#123;</span><br><span class="line">		<span class="type">int</span> m=A.length;</span><br><span class="line">		<span class="type">int</span> n=B.length;</span><br><span class="line">		<span class="keyword">if</span> (m&gt;n) &#123;   	<span class="comment">//ensuring that m&lt;=n</span></span><br><span class="line">			<span class="type">int</span>[] temp=A; A=B; B=temp;</span><br><span class="line">			<span class="type">int</span> tmp=m; m=n; n=tmp;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> iMin=<span class="number">0</span>, iMax=m, halfLen=(m+n+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">while</span> (iMin&lt;=iMax) &#123;</span><br><span class="line">			<span class="type">int</span> i=(iMin+iMax)/<span class="number">2</span></span><br><span class="line">			<span class="type">int</span> j= halfLen - i;</span><br><span class="line">			<span class="keyword">if</span> (i&lt;iMax &amp;&amp; B[j-<span class="number">1</span>] &gt; A[i])&#123;</span><br><span class="line">				iMin=i+<span class="number">1</span>; <span class="comment">//i is too small</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (i&gt;iMin &amp;&amp; A[i-<span class="number">1</span>]&gt;B[j]) &#123;</span><br><span class="line">				iMax=i-<span class="number">1</span>; <span class="comment">//i is too big</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123; <span class="comment">//we have found the object i </span></span><br><span class="line">				<span class="type">int</span> maxLeft=<span class="number">0</span>; </span><br><span class="line">				<span class="keyword">if</span> (i==<span class="number">0</span>) &#123;</span><br><span class="line">					maxLeft=B[j-<span class="number">1</span>];</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (j==<span class="number">0</span>)&#123;</span><br><span class="line">					maxLeft=A[i-<span class="number">1</span>];</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span>&#123;</span><br><span class="line">					maxLeft=Math.max(A[i-<span class="number">1</span>], B[j-<span class="number">1</span>]);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> ((m+n)%<span class="number">2</span> ==<span class="number">1</span>) &#123;</span><br><span class="line">					<span class="keyword">return</span> maxLeft;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="type">int</span> minRIght=<span class="number">0</span>;</span><br><span class="line">				<span class="keyword">if</span> (i==m) &#123;</span><br><span class="line">					minRight=B[j];</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (j==n) &#123;</span><br><span class="line">					minRight=A[i];</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					minRight=Math.min(B[j], A[i]);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">return</span> (maxLeft+minRight)/<span class="number">2.0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Complexity Analysis</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Time Complexity: O(log(min(m,n)))	At first the searching range is [0,m] and the length of this </span><br><span class="line">					searching range will be reduced by half after each loop so we</span><br><span class="line">					only need log(m) loops. Since we do constant operations in </span><br><span class="line">					each loop the time complexity is O(log(m) and since m&lt;=n the</span><br><span class="line">					time complexity is O(log(min(m,n))</span><br><span class="line"></span><br><span class="line">Space Complexity: O(1)			We only need constant memory to store 9 local variables so the</span><br><span class="line">					space complexity is O(1)</span><br></pre></td></tr></table></figure>


<p><br><br><br></p>
<hr>
<p><a name="longestPalindromicSubstring"></a></p>
<h1 id="5-Longest-Palindromic-Substring"><a href="#5-Longest-Palindromic-Substring" class="headerlink" title="5-Longest Palindromic Substring"></a>5-Longest Palindromic Substring</h1><p>Given a string s, find the longest palindromic substring in s. You may assume that the maximum length<br>of s is 1000. </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Example 1: </span><br><span class="line"></span><br><span class="line">Input: &quot;babad&quot; </span><br><span class="line">Output: &quot;bab&quot; </span><br><span class="line"></span><br><span class="line">Note: &quot;aba&quot; is also a valid answer </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Example 2: </span><br><span class="line"></span><br><span class="line">Input: &quot;cbbd&quot;</span><br><span class="line">Output: &quot;bb&quot; </span><br></pre></td></tr></table></figure>

<p><br><br><br><a name="longestPalindromicSubstringLongestCommonSubstring"></a></p>
<h2 id="Longest-Common-Substring"><a href="#Longest-Common-Substring" class="headerlink" title="Longest Common Substring"></a>Longest Common Substring</h2><p>Some people will be tempted to come up with this quick solution which is unforunately flawed, “reverse<br>S and become S’. Find the longest common substring between S and S’ and that will be the longest<br>palindromic substring.” This will work with some examples but there are some cases where the longest<br>common substring is not a valid palindrome. </p>
<pre><code>Ex. S=&quot;abacdfgdcaba&quot;, S&#39;=&quot;abacdgfdcaba&quot; 	
</code></pre>
<p>The longest common substring between S and S’ is “abacd” and clearly this is not a valid<br>    palindrome</p>
<p>We can solve this problem however by checking if the substring’s indices are the same as the reversed<br>substring’s original indices each time we find a longest common substring. If it is, then we attempt<br>to update the longest palindrome found so far, if not we skip this and find the next candidate</p>
<p><strong>Complexity Analysis</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Time Complexity: O(n^2) </span><br><span class="line">Space Complexity: O(n^2) </span><br></pre></td></tr></table></figure>
<p><br><br><br><a name="longestPalindromicSubstringBruteForce"></a></p>
<h2 id="Brute-Force-2"><a href="#Brute-Force-2" class="headerlink" title="Brute Force"></a>Brute Force</h2><p>The obvious brute force solution is to pick all possible starting and ending position for a substring<br>and verify if it is a palindrome </p>
<p><strong>Complexity Analysis</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Time Complexity: O(n^3)		If n is the length of the input string, there are a total of </span><br><span class="line">				(n 2) = n(n-1)/2 substrings and since verifying each substring takes </span><br><span class="line">				O(n) time, the run time complexity is O(n^3)</span><br><span class="line"></span><br><span class="line">Space Complexity: O(1) </span><br></pre></td></tr></table></figure>
<p><br><br><br><a name="longestPalindromicSubstringDynamicProgramming"></a></p>
<h2 id="Dynamic-Programming"><a href="#Dynamic-Programming" class="headerlink" title="Dynamic Programming"></a>Dynamic Programming</h2><p>We can improve on the brute force solution by avoid some unnecessary re-computation while validating<br>palidromes. Consider the word “ababa”, if we already know that “bab” is a palindrome then we can<br>determine that ababa is a palindrome by noticing that the two left and right letters connected to bab<br>are the same. </p>
<p>This yields a straight forward dynamic programming solution where we initialize the one and two letters<br>palindromes and then work our way up finding all three letters palindromes and so on.</p>
<p><strong>Complexity Analysis</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Time Complexity: 	O(n^2)	</span><br><span class="line"></span><br><span class="line">Space Complexity: 	O(n^2)	Using O(n^2) space to store the table </span><br></pre></td></tr></table></figure>
<p><br><br><br><a name="longestPalindromicSubstringExpandAroundCenter"></a></p>
<h2 id="Expand-Around-Center"><a href="#Expand-Around-Center" class="headerlink" title="Expand Around Center"></a>Expand Around Center</h2><p>This approach allows us to solve this problem in O(n^2) time using only constant space complexity. We<br>observe that a palindrome mirrors around its enter and therefore a palindrome can be expanded from its<br>center and there are only 2n-1 such centers (for palindromes with an even number of letters like<br>“abba” its center is in between two letters).</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (s==<span class="literal">null</span> || s.length() &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;     <span class="comment">//edge case </span></span><br><span class="line">	<span class="type">int</span> start=<span class="number">0</span>, end=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;s.length(); i++) &#123;</span><br><span class="line">		<span class="type">int</span> len1=expandAroundCenter(s,i,i);</span><br><span class="line">		<span class="type">int</span> len2=expandAroundCenter(s,i,i+<span class="number">1</span>);</span><br><span class="line">		<span class="type">int</span> len=Math.max(len1,len2);</span><br><span class="line">		<span class="keyword">if</span> (len&gt;end-start) &#123;</span><br><span class="line">			start= i-(len-<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">			end=i+len/<span class="number">2</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> s.substring(start,end+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">expandAroundCenter</span><span class="params">(String s, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">	<span class="type">int</span> L=left, R=right;</span><br><span class="line">	<span class="keyword">while</span>(L&gt;=<span class="number">0</span> &amp;&amp; R&lt;s.length() &amp;&amp; s.charAt(L)==s.charAt(R)) &#123;</span><br><span class="line">		L--;</span><br><span class="line">		R++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> R-L-<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><br><br><br><a name="longestPalindromicSubstringManacherAlgorithm"></a></p>
<h2 id="Manacher’s-Algorithm"><a href="#Manacher’s-Algorithm" class="headerlink" title="Manacher’s Algorithm"></a>Manacher’s Algorithm</h2><p>There is an O(n) algorithm called Manacher’s algorithm, however, it is a non-trivial algorithm and no<br>one would expect you to come up with this algorithm in a 45 minute coding session</p>
<p><br><br><br></p>
<hr>
<p><a name="zigZagConversion"></a></p>
<h1 id="6-ZigZag-Conversion"><a href="#6-ZigZag-Conversion" class="headerlink" title="6-ZigZag Conversion"></a>6-ZigZag Conversion</h1><p>The string “PAYPALISHIRING” is written in a zigzag pattern on a given number of rows like this: </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">P   A   H   N</span><br><span class="line">A P L S I I G</span><br><span class="line">Y   I   R</span><br></pre></td></tr></table></figure>
<p>And then read line by line: “PAHNAPLSIIGYIR”. Write a code that will take a string and make this<br>conversion given a number of rows: </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string convert(string s, int numRows);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Example 1: </span><br><span class="line"></span><br><span class="line">Input: s=&quot;PAYPALISHIRING&quot;, numRows=3</span><br><span class="line">Output: &quot;PAHNAPLSIIGYIR&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: s=&quot;PAYPALISHIRING&quot;, numRows=4</span><br><span class="line">Output: &quot;PINALSIGYAHRPI&quot;</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line"></span><br><span class="line">P           I          N</span><br><span class="line">A       L   S      I   G</span><br><span class="line">Y   A       H   R</span><br><span class="line">P           I</span><br></pre></td></tr></table></figure>

<p><br><br><br><a name="zigZagConversionSortbyRow"></a></p>
<h2 id="Sort-by-Row"><a href="#Sort-by-Row" class="headerlink" title="Sort by Row"></a>Sort by Row</h2><p>By iterating through the string from left to right we can easily determine which row in the Zig-Zag<br>pattern that a character belongs to</p>
<p><br><br><br><em>Algorithm</em></p>
<p>We can use min(numRows,len(s)) lists to represent the non-empty rows of the Zig-Zag Pattern.<br>Iterate through s from left to right appending each character to the appropriate row. The appropriate<br>row can be tracked using two variables: the current row and the current direction. </p>
<p>The current direction only changes when we moved to the topmost row or moved down to the bottommost<br>row </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">convert</span><span class="params">(String s, <span class="type">int</span> numRows)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (numRows==<span class="number">1</span>) <span class="keyword">return</span> s;		<span class="comment">//if there is only one row return string</span></span><br><span class="line"></span><br><span class="line">		List&lt;StringBuilder&gt; rows=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;Math.min(numRows, s.length()); i++)&#123;</span><br><span class="line">			rows.add(<span class="keyword">new</span> <span class="title class_">StringBuilder</span>());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> curRow=<span class="number">0</span>;</span><br><span class="line">		<span class="type">boolean</span> goingDown=<span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">char</span> c: s.toCharArray()) &#123;</span><br><span class="line">			rows.get(curRow).append(c);</span><br><span class="line">			<span class="keyword">if</span> (curRow==<span class="number">0</span> || curRow==numRows-<span class="number">1</span>) &#123;</span><br><span class="line">				goingDown=!goingDown;</span><br><span class="line">			&#125;</span><br><span class="line">			curRow+=goingDown ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">		&#125;	</span><br><span class="line"></span><br><span class="line">		StringBuilder ret= <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">		<span class="keyword">for</span>(StringBuilder row:rows) &#123;</span><br><span class="line">			ret.append(row);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ret.toString();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Complexity Analysis</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Time Complexity:  O(n)	where n==len(s)</span><br><span class="line">Space Complexity: O(n)</span><br></pre></td></tr></table></figure>

<p><br><br><br><a name="zigZagConversionVisitbyRow"></a></p>
<h2 id="Visit-by-Row"><a href="#Visit-by-Row" class="headerlink" title="Visit by Row"></a>Visit by Row</h2><p>Visit the characters in the same order as reading the Zig-Zag pattern line by line</p>
<p><br><br><br><em>Algorithm</em></p>
<p>Visit all characters in row 0 first, then row 1, then row 2, and so on.<br>For all whole numbers k,<br>    * characters in row 0 are located at indexes  k*(2*numRows-2)<br>    * characters in row numRows -1 are located at indexes  k*(2*numRows-2)+ numRows -1<br>    * characters in inner row i are located at indexes  k*(2*numRows-2)+i and (k+1)(2*numRows-2)-i</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">convert</span><span class="params">(String s, <span class="type">int</span> numRows)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (numRows==<span class="number">1</span>) <span class="keyword">return</span> s; </span><br><span class="line"></span><br><span class="line">		StringBuilder ret=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">		<span class="type">int</span> n=s.length();</span><br><span class="line">		<span class="type">int</span> cycleLen= <span class="number">2</span>* numRows -<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;numRows; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j+<span class="number">1</span>&lt;n; j+= cycleLen) &#123;</span><br><span class="line">				ret.append(s.charAt(j+i));</span><br><span class="line">				<span class="keyword">if</span> (i!=<span class="number">0</span> &amp;&amp; i!=numROws-<span class="number">1</span> &amp;&amp; j+cycleLen-i&lt;n) &#123;</span><br><span class="line">					ret.append(s.charAt(j+cycleLen-i));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> ret.toString();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Complexity Analysis</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Time Complexity: O(n)	where n==len(s) Each index is visited once</span><br><span class="line"></span><br><span class="line">Space Complexity: O(n) 	C++ implementation can achieve O(1) if the return string is not considered </span><br><span class="line">			extra space</span><br></pre></td></tr></table></figure>


<p><br><br><br></p>
<hr>
<p><a name="reverseInteger"></a></p>
<h1 id="7-Reverse-Integer"><a href="#7-Reverse-Integer" class="headerlink" title="7-Reverse Integer"></a>7-Reverse Integer</h1><p>Given a 32- bit signed integer, reverse digits of an integer. </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Example 1: </span><br><span class="line"></span><br><span class="line">Input: 123</span><br><span class="line">Output: 321</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Example 2: </span><br><span class="line"></span><br><span class="line">Input: -123</span><br><span class="line">Output: -321</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Example 3: </span><br><span class="line"></span><br><span class="line">Input: 120 </span><br><span class="line">Output: 21</span><br></pre></td></tr></table></figure>

<p>For the purpose of this problem assume that your function returns 0 when the reversed integer overflows</p>
<p><br><br><br><a name="reverseIntegerPopandPush"></a></p>
<h2 id="Pop-and-Push-Digits-and-Check-Before-Overflow"><a href="#Pop-and-Push-Digits-and-Check-Before-Overflow" class="headerlink" title="Pop and Push Digits and Check Before Overflow"></a>Pop and Push Digits and Check Before Overflow</h2><p>We can build up the reverse integer one digit at and time and before doing so we can check whether or<br>not appedning another digit would cause overflow </p>
<p><br><br><br><em>Algorithm</em></p>
<p>Reversing an integer can be done similarly to reversing a string. We want to repeatedly “pop” the last<br>digit off of x and push it to the back of the rev so that in the end rev is the reverse of x. </p>
<p>To push and pop digits without the help of some auxiliar stack&#x2F;array we can use math </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//pop operation: </span><br><span class="line">pop = x%10; </span><br><span class="line">x/=10;</span><br><span class="line"></span><br><span class="line">//push operation:</span><br><span class="line">temp=rev*10+pop;</span><br><span class="line">rev =temp;</span><br></pre></td></tr></table></figure>

<p>This statement is dangerous however as the statement temp&#x3D;rev*10+pop may cause an overflow and luckily<br>it is easy to check beforehand whether or not this statement would cause an overflow. </p>
<ol>
<li>If temp&#x3D;rev*10+pop causes an overflow, then rev&gt;&#x3D;INTMAX&#x2F;10</li>
<li>If rev&gt; INTMAX&#x2F;10, then temp&#x3D;rev*10+pop is guaranteed to overflow</li>
<li>if rev&#x3D;&#x3D;INTMAX&#x2F;10, then temp&#x3D;rev*10 + pop will overflow if an only if pop&gt;7</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">		<span class="type">int</span> rev=<span class="number">0</span>; </span><br><span class="line">		<span class="keyword">while</span> (x!=<span class="number">0</span>) &#123;</span><br><span class="line">			<span class="type">int</span> pop=x%<span class="number">10</span>;</span><br><span class="line">			x/=<span class="number">10</span>;</span><br><span class="line">			<span class="keyword">if</span> (rev&gt;Integer.MAX_VALUE/<span class="number">10</span>||(rev==Integer.MAX_VALUE/<span class="number">10</span> &amp;&amp; pop&gt;<span class="number">7</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">if</span> (rev&lt;Integer.MIN_VALUE/<span class="number">10</span>||(rev==Integer.MIN_VALUE/<span class="number">10</span> &amp;&amp; pop&lt;-<span class="number">8</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			rev=rev*<span class="number">10</span> +pop;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> rev;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Complexity Analysis</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Time Complexity:  O(log(x))	There are roughly log10(x) digits in x </span><br><span class="line">Space Complexity: O(1)</span><br></pre></td></tr></table></figure>


<p><br><br><br></p>
<hr>
<p><a name="stringtoInteger"></a></p>
<h1 id="8-String-to-Integer-atoi"><a href="#8-String-to-Integer-atoi" class="headerlink" title="8-String to Integer (atoi)"></a>8-String to Integer (atoi)</h1><p>Implement atoi which converts a string to an integer </p>
<p>The function first discards as many whitespace characters as necessary until the first non-whitespace<br>character is found. Then, starting from this character, takes an optional initial plus or minus sign<br>followed by as many numerical digits as possible and interprets them as a numerical value. </p>
<p>The string can contain additional characters after those that form the integral number, which are<br>ignored and have no effect on the behavior of this function. </p>
<p>If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such<br>sequence exits because either str is empty or it contains only whitespace characters, no conversion is<br>performed. </p>
<p>If no valid conversion could be performed a zero value is returned </p>
<p>Note: </p>
<ul>
<li>only the space character ‘ ‘ is considered as whitespace character </li>
<li>assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [-2^31, 2^31-1]. If the numerical value is out of the range of representable values, INT_MAX (2^31-1) or INT_MIN (-2^31) is returned</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Example 1: </span><br><span class="line"></span><br><span class="line">Input: &quot;42&quot;</span><br><span class="line">Output: 42</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Example 2: </span><br><span class="line"></span><br><span class="line">Input: &quot;      -42&quot; </span><br><span class="line">Output: -42</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Input: &quot;4193 with words &quot;</span><br><span class="line">Output: 4193</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Example 4: </span><br><span class="line"></span><br><span class="line">Input: &quot;words and 987&quot;</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Example 5:</span><br><span class="line"></span><br><span class="line">Input: &quot;-91283472332&quot;</span><br><span class="line">Output: -2147483648 	//out of the range of a 32-bit signed integer so INT_MIN is returned</span><br></pre></td></tr></table></figure>


<p><br><br><br><a name="stringtoIntegerASCII"></a></p>
<h2 id="ASCII-Conversion"><a href="#ASCII-Conversion" class="headerlink" title="ASCII Conversion"></a>ASCII Conversion</h2><p>Recognize that ASCII characters are actually numbers and 0-9 digits are numbers starting from decimal<br>48 (0x30 hexadecimal) </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x27;0&#x27; is 48</span><br><span class="line">&#x27;1&#x27; is 49</span><br><span class="line">...</span><br><span class="line">&#x27;9&#x27; is 57</span><br></pre></td></tr></table></figure>
<p>So to get the value of any character digit you can just remove the ‘0’ </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x27;1&#x27; - &#x27;0&#x27; =&gt; 1</span><br><span class="line">49  -  48 =&gt; 1</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">myAtoi</span><span class="params">(String str)</span> &#123;</span><br><span class="line">	<span class="type">int</span> index=<span class="number">0</span>, sign=<span class="number">1</span>, total=<span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//1. Empty string </span></span><br><span class="line">	<span class="keyword">if</span> (str.length() ==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2. Remove Spaces </span></span><br><span class="line">	<span class="keyword">while</span>(str.charAt(index)==<span class="string">&#x27; &#x27;</span> &amp;&amp; index &lt; str.length())</span><br><span class="line">		index++;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//3. Handle signs </span></span><br><span class="line">	<span class="keyword">if</span> (str.charAt(index)==<span class="string">&#x27;+&#x27;</span> || str.charAt(index)==<span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">		sign= str.charAt(index) == <span class="string">&#x27;+&#x27;</span> ? <span class="number">1</span>:-<span class="number">1</span>;</span><br><span class="line">		index++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//4. COnvert number and avoid overflow</span></span><br><span class="line">	<span class="keyword">while</span>(index&lt;str.length())&#123;</span><br><span class="line">		<span class="type">int</span> digit= str.charAt(index) - <span class="string">&#x27;0&#x27;</span>; </span><br><span class="line">		<span class="keyword">if</span> (digit&lt;<span class="number">0</span>||digit&gt;<span class="number">9</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//check if total will overflow after 10 times and add digit</span></span><br><span class="line">		<span class="keyword">if</span> (Integer.MAX_VALUE/<span class="number">10</span> &lt; total || Integer.MAX_VALUE/<span class="number">10</span> == total </span><br><span class="line">		    &amp;&amp; Integer.MAX_VALUE%<span class="number">10</span>&lt;digit) &#123;    </span><br><span class="line">		    <span class="keyword">return</span> sign==<span class="number">1</span> ? Integer.MAX_VALUE : Integer.MIN_VALUE;</span><br><span class="line">		&#125;</span><br><span class="line">		total= <span class="number">10</span>* total+digit;</span><br><span class="line">		index++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> total*sign;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><br><br><br></p>
<hr>
<p><a name="palindromeNumber"></a></p>
<h1 id="9-Palindrome-Number"><a href="#9-Palindrome-Number" class="headerlink" title="9-Palindrome Number"></a>9-Palindrome Number</h1><p>Determines whether an interger is a palindrome. An integer is a palindrome when it reads the same<br>backward as forward. </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Example 1: </span><br><span class="line"></span><br><span class="line">Input: 121</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Example 2: </span><br><span class="line"></span><br><span class="line">Input: -121</span><br><span class="line">Output: false </span><br><span class="line">Explanation: 	From left to right, it reads -121, meanwhile from right to left it becomes 121- . </span><br><span class="line">		Therefore it is not a palindrome</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Example 3: </span><br><span class="line"></span><br><span class="line">Input: 10 </span><br><span class="line">Output: false </span><br><span class="line">Explanation: 	Reads 01 from right to left. Therefore it is not a palindrome</span><br></pre></td></tr></table></figure>


<p><br><br><br><a name="palindromeNumberRevertHalf"></a></p>
<h2 id="Revert-Half-of-the-Number"><a href="#Revert-Half-of-the-Number" class="headerlink" title="Revert Half of the Number"></a>Revert Half of the Number</h2><p>A first idea which may come to mind is to convert the number into a string and check if the string is a<br>palindrome but this would require extra non-constant space for creating the string not allowed by the<br>problem description </p>
<p>Second idea would be reverting the number itself and comparing the number with the original number, if<br>they are the same then the number is a palindrome, however if the reversed number is larger than<br>int.MAX we will hit integer overflow problem. </p>
<p>To avoid the overflow issue of the reverted number, what if we only revert half of the int number? The<br>reverse of the last half of the palindrome should be the same as the first half of the number if the<br>number is a palindrome. </p>
<p>If the input is 1221, if we can revert the last part of the number “1221” from “21” to “12” and compare<br>it with the first half of the number “12”, since 12 is the same as 12, we know that the number is a<br>palindrome. </p>
<p><br><br><br><em>Algorithm</em> </p>
<p>At the very beginning we can deal with some edge cases. All negative numbers are not palindrome and<br>numbers ending in zero can only be a palindrome if the first digit is also 0 (only 0 satisfies this<br>property) </p>
<p>Now let’s think about how to revert the last half of the number. For the number 1221 if we do 1221%10<br>we get the last digit 1. To get the second last digit we divide the number by 10 1221&#x2F;10&#x3D;122 and then<br>we can get the last digit again by doing a modulus by 10, 122%10&#x3D;2. If we multiply the last digit by<br>10 and add the second last digit 1*10+2&#x3D;12 which gives us the reverted number we want. COntinuing this<br>process would give us the reverted number with more digits. </p>
<p>Next is how do we know that we’ve reached the half of the number?<br>Since we divided the number by 10 and multiplied the reversed number by 10 when the original number is<br>less than the reversed number, it means we’ve gone through half of the number digits. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (x&lt;<span class="number">0</span> || (x%<span class="number">10</span>==<span class="number">0</span> &amp;&amp; x!=<span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> revertedNumber=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x&gt;revertedNumber)&#123;</span><br><span class="line">            revertedNumber=x%<span class="number">10</span>+revertedNumber*<span class="number">10</span>;</span><br><span class="line">            x/=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//when the length is an odd number, we can get rid of the middle digit by </span></span><br><span class="line">        <span class="comment">//revertedNumber/10</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//For example when the input is 12321, at the end of the while loop we get x=12, </span></span><br><span class="line">        <span class="comment">//revertedNumber=123, since the middle digit doesn&#x27;t matter in a palindrome we can</span></span><br><span class="line">        <span class="comment">//simply get rid of it </span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> x==revertedNumber||x==revertedNumber/<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><br><br><br></p>
<hr>
<p><a name="regularExpressionMatching"></a></p>
<h1 id="10-Regular-Expression-Matching"><a href="#10-Regular-Expression-Matching" class="headerlink" title="10-Regular Expression Matching"></a>10-Regular Expression Matching</h1><p>Given an input string (s) and a pattern (p), implement regular expression matching with support for ‘.’<br>and ‘*’</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x27;.&#x27; Matches any single character</span><br><span class="line">&#x27;*&#x27; Matches zero or more of the preceding element </span><br></pre></td></tr></table></figure>
<p>The matching should cover the entire input string (not partial) </p>
<p>Note: </p>
<ul>
<li>s could be empty and contains only lower case letters a-z</li>
<li>p could be empty and contains only lower case letters a-z and characters like . or *</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Example 1: </span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">	s=&quot;aa&quot; </span><br><span class="line">	p=&quot;a&quot; </span><br><span class="line">	Output: false </span><br><span class="line">	Explanation: 	&quot;a&quot; does not match the entire string &quot;aa&quot; </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Example 2: </span><br><span class="line"></span><br><span class="line">Input: </span><br><span class="line">	s=&quot;aa&quot;</span><br><span class="line">	p=&quot;a*&quot; </span><br><span class="line">	Output: true </span><br><span class="line">	Explanation: 	&#x27;*&#x27; means zero of more of the preceding element, &#x27;a&#x27;. Therefore, by repeating</span><br><span class="line">			&#x27;a&#x27; once it becomes &quot;aa&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Example 3: </span><br><span class="line"></span><br><span class="line">Input: </span><br><span class="line">	s=&quot;ab&quot; </span><br><span class="line">	p=&quot;.*&quot; </span><br><span class="line">	Output: true </span><br><span class="line">	Explanation: 	&#x27;.*&#x27; means &quot;zero or more (*) of any character (.)&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Example 4: </span><br><span class="line"></span><br><span class="line">Input: </span><br><span class="line">	s=&quot;aab&quot; </span><br><span class="line">	p=&quot;c*a*b&quot; </span><br><span class="line">	Output: true</span><br><span class="line">	Explanation: 	c can be repeated 0 times, a can be repeated 1 time. Therefore it matches </span><br><span class="line">			&quot;aab&quot; </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Example 5: </span><br><span class="line"></span><br><span class="line">Input: </span><br><span class="line">	s=&quot;mississippi&quot; </span><br><span class="line">	p=&quot;mis*is*p*.&quot;</span><br><span class="line">	Output: false </span><br></pre></td></tr></table></figure>

<p><br><br><br><a name="regularExpressionMatchingRecursion"></a></p>
<h2 id="Recursion"><a href="#Recursion" class="headerlink" title="Recursion"></a>Recursion</h2><p>If there were no Kleene stars (the * wildcard characters for regular expressions), the problem would<br>be easier- we simply check from left to right if each character of the text matches the pattern. When<br>a star is present we may need to check for may different suffixes of the text and see if they match<br>the rest of the pattern. A recursive solution is a straightforward way to represent this relationship</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isMatch</span><span class="params">(String text, String pattern)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (pattern.isEmpty()) <span class="keyword">return</span> text.isEmpty(); </span><br><span class="line">		</span><br><span class="line">		<span class="type">boolean</span> first_match=(!text.isEmpty() &amp;&amp; </span><br><span class="line">				    (pattern.charAt(<span class="number">0</span>)==text.charAt(<span class="number">0</span>) || pattern.charAt(<span class="number">0</span>)==<span class="string">&#x27;.&#x27;</span>));</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (pattern.length()&gt;=<span class="number">2</span> &amp;&amp; pattern.charAt(<span class="number">1</span>) ==<span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> (isMatch(text,pattern.substring(<span class="number">2</span>))||</span><br><span class="line">			       (first_match &amp;&amp; isMatch(text.substring(<span class="number">1</span>),pattern)));</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//note: pattern.substring(2) returns all of the characters after index 2 of pattern</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> first_match &amp;&amp; isMatch(text.substring(<span class="number">1</span>), pattern.substring(<span class="number">1</span>));</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Complexity Analysis</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Time Complexity: 	Let T, P be the lengths of the text and the pattern respectively. In the worst</span><br><span class="line">			case, a call to match(text[i:],pattern[2j:]) will be made (i+j i) times, and </span><br><span class="line">			strings of the order O(T-i) and O(P-2*j) will be made. Thus the complexity has</span><br><span class="line">			the order: </span><br><span class="line"></span><br><span class="line">			summation from i=0 to T * summation from j=0 to P/2 * (i+j i) O(T+P-i-2j).</span><br><span class="line"></span><br><span class="line">			We can show that this is bounded by O((T+P)2^(T+P/2))</span><br><span class="line"></span><br><span class="line">Space Complexity:	For every call to match, we will create those strings as described above </span><br><span class="line">			possibly creating duplicates. If memory is not freed, this will also take a</span><br><span class="line">			total of O((T+P)2^(T+P/2)) space even though there are only order O(T^2+P^2) </span><br><span class="line">			unique suffixes of P and T that are actually required </span><br></pre></td></tr></table></figure>

<p><br><br><br><a name="regularExpressionMatchingDynamicProgramming"></a></p>
<h2 id="Dynamic-Programming-1"><a href="#Dynamic-Programming-1" class="headerlink" title="Dynamic Programming"></a>Dynamic Programming</h2><p>As the problem has an optimal substructure, it is natural to cache intermediate results. We ask the<br>question dp(i,j): does text[i:] and pattern[j:] match? We can describe our answer in terms of answers<br>to questions involving smaller strings</p>
<p><br><br><br><em>Algorithm</em> </p>
<p>We proceed with the same recursion as in Approach 1, except because calls will only ever be made to<br>match(text[i:], pattern[j:]), we use dp(i,j) to handle those calls instead, saving us expensive<br>string-building operations and allowing us to cache the intermediate results </p>
<p><strong>Java Top-Down Variation</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Result</span> &#123;</span><br><span class="line">	TRUE, FALSE</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	Result[][] memo; </span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isMatch</span><span class="params">(String text, String pattern)</span> &#123; </span><br><span class="line">		memo=<span class="keyword">new</span> <span class="title class_">Result</span>[text.length() +<span class="number">1</span>][pattern.length() +<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">return</span> dp(<span class="number">0</span>,<span class="number">0</span>,text,pattern);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dp</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, String text, String pattern)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (memo[i][j]!=<span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> memo[i][j]==Result.TRUE;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">boolean</span> ans; </span><br><span class="line">		<span class="keyword">if</span> (j==pattern.length())&#123;</span><br><span class="line">			ans=i==text.length();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="type">boolean</span> first_match=(i&lt;text.length() &amp;&amp; (pattern.charAt(j) == text.charAt(i) ||</span><br><span class="line">					     patter.charAt(j) == <span class="string">&#x27;.&#x27;</span>));</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (j+<span class="number">1</span>&lt;pattern.length() &amp;&amp; pattern.charAt(j+<span class="number">1</span>)==<span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">				ans=(dp(i,j+<span class="number">1</span>,text,pattern)||first_match&amp;&amp; dp(i+<span class="number">1</span>,j,text,pattern));</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				ans=first_match &amp;&amp; dp(i+<span class="number">1</span>, j+<span class="number">1</span>, text, pattern); </span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		memo[i][j]=ans? Result.TRUE: Result.FALSE; </span><br><span class="line">		<span class="keyword">return</span> ans; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Complexity Analysis</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Time Complexity: 	Let T, P be the lengths of the text and the pattern respectively. The work </span><br><span class="line">			for every call to dp(i,j) for i=0,...,T; j=0,...,P is done once and it is O(1) 				work. Hence the time complexity is O(TP)</span><br><span class="line"></span><br><span class="line">Space Complexity:	The only memory we use is the O(TP) boolean entries in our cache. Hence, the </span><br><span class="line">			space complexity is O(TP) </span><br></pre></td></tr></table></figure>

<p><br><br><br><a name="regularExpressionMatchingNonRecursive"></a></p>
<h2 id="Non-Recursive"><a href="#Non-Recursive" class="headerlink" title="Non-Recursive"></a>Non-Recursive</h2><p>The recursive programming solutions are pretty confusing so this implementation uses 2D arrays and<br>Dynamic Programming </p>
<p>The logic works as follows: </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1. If p.charAt(j) == s.charAt(i) : dp[i][j] = dp[i-1][j-1]; </span><br><span class="line">2. If p.charAt(j) == &#x27;.&#x27; : dp[i][j] = dp[i-1][j-1]; </span><br><span class="line">3. If p.charAt(j) == &#x27;*&#x27;: </span><br><span class="line">	</span><br><span class="line">	Subconditions</span><br><span class="line">	1. If p.charAt(j-1)!= s.charAt(i):dp[i][j]=dp[i][j-2]  	//in this case a* only counts as empty</span><br><span class="line">	2. If p.charAt(i-1)== s.charAt(i) or p.charAt(i-1) == &#x27;.&#x27;: </span><br><span class="line">		</span><br><span class="line">		dp[i][j] = dp[i-1][j]	//in this case a* counts as multiple a </span><br><span class="line">	     or dp[i][j] = dp[i][j-1]	//in this case a* counts as single a </span><br><span class="line">	     or dp[i][j] = dp[i][j-2]	//in this case a* counts as empty </span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isMatch</span><span class="params">(String s, String p)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (s==<span class="literal">null</span> || p==<span class="literal">null</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">boolean</span>[][] dp=<span class="keyword">new</span> <span class="title class_">boolean</span>[s.length()+<span class="number">1</span>][p.length()+<span class="number">1</span>];</span><br><span class="line">	dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="literal">true</span>; </span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;p.length(); i++)&#123;</span><br><span class="line">		<span class="keyword">if</span> (p.charAt(i)==<span class="string">&#x27;*&#x27;</span> &amp;&amp; dp[<span class="number">0</span>][i-<span class="number">1</span>])&#123;</span><br><span class="line">			dp[<span class="number">0</span>][i+<span class="number">1</span>]=<span class="literal">true</span>; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;p.length();j++)&#123;</span><br><span class="line">			<span class="keyword">if</span> (p.charAt(j)==<span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">				dp[i+<span class="number">1</span>][j+<span class="number">1</span>]=dp[i][j];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (p.charAt(j)==s.charAt(i))&#123;</span><br><span class="line">				dp[i+<span class="number">1</span>][j+<span class="number">1</span>]=dp[i][j];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (p.charAt(j)==<span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">				<span class="keyword">if</span> (p.charAt(j-<span class="number">1</span>)!=s.charAt(i) &amp;&amp; p.charAt(j-<span class="number">1</span>) !=<span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">					dp[i+<span class="number">1</span>][j+<span class="number">1</span>]=dp[i+<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span>&#123;</span><br><span class="line">					dp[i+<span class="number">1</span>][j+<span class="number">1</span>]=(dp[i+<span class="number">1</span>][j] || dp[i][j+<span class="number">1</span>] || dp[i+<span class="number">1</span>][j-<span class="number">1</span>]);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[s.length()][p.length()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><br><br><br></p>
<hr>
<p><a name="containerwiththeMostWater"></a></p>
<h1 id="11-Container-with-the-Most-Water"><a href="#11-Container-with-the-Most-Water" class="headerlink" title="11-Container with the Most Water"></a>11-Container with the Most Water</h1><p>Given n non negative integers a1,a2, … , an where each represents a point at coordinate (i, ai). n<br>vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two<br>lines, which together with x-axis forns a container such that the container contains the most water. </p>
<figure class="highlight plaintext"><figcaption><span>The array [1,8,6,2,5,4,8,3,7] would have a max area of water which is 49.</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">      ^		    ^</span><br><span class="line">These two values form the container which could hold water at a max height of 7, these values</span><br><span class="line">are also 7 array indexes apart from each other so it could hold water at a max width of 7. The</span><br><span class="line">area of water which could be held is thus 7 x 7 = 49</span><br></pre></td></tr></table></figure>


<p><a name="containerwiththeMostWaterBruteForce"></a></p>
<h2 id="Brute-Force-3"><a href="#Brute-Force-3" class="headerlink" title="Brute Force"></a>Brute Force</h2><p>In this case we simply consider the area for every possible pair of the lines and find out the maximum<br>area out of those. </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">	public int maxArea(int[] height) &#123;</span><br><span class="line">		int maxarea=0; </span><br><span class="line">		for (int i=0; i&lt;height.length; i++)&#123;</span><br><span class="line">			for (int j=i+1;j&lt;height.length;j++)&#123;</span><br><span class="line">				maxarea=Math.max(maxarea, Math.min(height[i],height[j])*(j-i));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return maxarea;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Complexity Analysis</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Time complexity: 	O(n^2) 	Calculating the area for all n(n-1)/2 height pairs </span><br><span class="line">Space complexity: 	O(1) 	Constant extra space is used </span><br></pre></td></tr></table></figure>

<p><br><br><br><a name="containerwiththeMostWaterTwoPointer"></a></p>
<h2 id="Two-Pointer-Approach"><a href="#Two-Pointer-Approach" class="headerlink" title="Two Pointer Approach"></a>Two Pointer Approach</h2><p>The intuition behind this approach is that the area formed between the lines will always be limited by<br>the height of the shorter line. Further, the farther the lines, the more will be the area obtained. </p>
<p>We take two pointers, one at the beginning and one at the end of the array constituting the length of<br>the lines. Further, we maintain a variable maxarea to store the maximum area obtained till now. At<br>every step, we find out the area formed between them, update maxarea and move the pointer pointing to<br>the shorter line towards the other end by one step. </p>
<p>Initially we consider the area constituting the exterior most lines. Now to maximize the area we need<br>to consider the area between the lines of larger lengths. If we try to move the pointer at the longer<br>line inwards, we won’t gain any increase in area, since it is limited by the shorter line. But moving<br>the shorter line’s pointer could turn out to be benefical, as per the same argument, despite the<br>reduction in width. This is done since a relatively longer line obtained by moving the shorter line’s<br>pointer might overcome the reduction in area caused by the width reduction. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxArea</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">		<span class="type">int</span> maxarea=<span class="number">0</span>, l=<span class="number">0</span>, r=height.length-<span class="number">1</span>; </span><br><span class="line">		<span class="keyword">while</span> (l&lt;r)&#123;</span><br><span class="line">			maxarea=Math.max(maxarea,Math.min(height[l],height[r])*(r-l));</span><br><span class="line">			<span class="keyword">if</span> (height[l]&lt;height[r])&#123;</span><br><span class="line">				l++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				r--;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> maxarea; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Complexity Analysis</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Time complexity: 	O(n) 	Single pass</span><br><span class="line">Space complexity: 	O(1) 	Constant space is used </span><br></pre></td></tr></table></figure>

<p><br><br><br></p>
<hr>
<p><a name="integertoRoman"></a></p>
<h1 id="12-Integer-To-Roman"><a href="#12-Integer-To-Roman" class="headerlink" title="12-Integer To Roman"></a>12-Integer To Roman</h1><p>Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Symbol		Value </span><br><span class="line">I		1</span><br><span class="line">V		5</span><br><span class="line">X		10</span><br><span class="line">L		50</span><br><span class="line">C		100</span><br><span class="line">D		500</span><br><span class="line">M		1000</span><br></pre></td></tr></table></figure>

<p>For example, two is written as II in Roman numeral, just two one’s added together. Twelve is written as<br>XII which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II. </p>
<p>Roman numerals are usually written largest to smallest from left to right. However, the numeral for<br>four is not IIII. Instead, the number four is written as IV. Because the one is before the five we<br>subtract it making four. The same principle applies to the number nine which is written as IX. There<br>are six instances where subtraction is used: </p>
<ul>
<li>I can be placed before V (5) and X (10) to make 4 and 9 </li>
<li>X can be placed before L (50) and C(100) to make 40 and 90 </li>
<li>C can be placed before D (500) and M(1000) to make 400 and 900</li>
</ul>
<p>Given an integer, convert it to a roman numeral, input is guaranteed to be within the range from<br>1 to 3999</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Example 1: </span><br><span class="line"></span><br><span class="line">Input: 3 </span><br><span class="line">Output: &quot;III&quot; </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Example 2: </span><br><span class="line"></span><br><span class="line">Input: 4</span><br><span class="line">Output: &quot;IV&quot; </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Example 3: </span><br><span class="line"></span><br><span class="line">Input: 9 </span><br><span class="line">Output: &quot;IX&quot; </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Example 4: </span><br><span class="line"></span><br><span class="line">Input: 58 </span><br><span class="line">Output: &quot;LVIII&quot; </span><br><span class="line">Explanation: L=50, V=5, III=3</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Example 5: </span><br><span class="line"></span><br><span class="line">Input: 1994</span><br><span class="line">Output: &quot;MCMXCIV&quot;</span><br><span class="line">Explanation: M=1000, CM=900, XC=90 and IV=4 </span><br></pre></td></tr></table></figure>

<p><a name="integertoRomanStringArray"></a></p>
<h2 id="String-Array"><a href="#String-Array" class="headerlink" title="String Array"></a>String Array</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">intToRoman</span><span class="params">(<span class="type">int</span> num)</span> &#123; </span><br><span class="line">	</span><br><span class="line">	String M[]=&#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;M&quot;</span>, <span class="string">&quot;MM&quot;</span>, <span class="string">&quot;MMM&quot;</span>&#125;;</span><br><span class="line">	<span class="comment">//represents 1000, 2000, and 3000 since we know the number is in the range 1 to 3999</span></span><br><span class="line">	</span><br><span class="line">	String C[]=&#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;CC&quot;</span>, <span class="string">&quot;CCC&quot;</span>, <span class="string">&quot;CD&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;DC&quot;</span>, <span class="string">&quot;DCC&quot;</span>, <span class="string">&quot;DCCC&quot;</span>, <span class="string">&quot;CM&quot;</span>&#125;;</span><br><span class="line">	<span class="comment">//represents 0, 100,  200,   300,  400, 500,  600,   700,    800,  900</span></span><br><span class="line"></span><br><span class="line">	String X[]=&#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;X&quot;</span>, <span class="string">&quot;XX&quot;</span>, <span class="string">&quot;XXX&quot;</span>, <span class="string">&quot;XL&quot;</span>, <span class="string">&quot;L&quot;</span>, <span class="string">&quot;LX&quot;</span>, <span class="string">&quot;LXX&quot;</span>, <span class="string">&quot;LXXX&quot;</span>, <span class="string">&quot;XC&quot;</span>&#125;;</span><br><span class="line">	<span class="comment">//represents 0,  10,   20,    30,   40,  50,   60,    70,     80,   90</span></span><br><span class="line"></span><br><span class="line">	String I[]=&#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;I&quot;</span>, <span class="string">&quot;II&quot;</span>, <span class="string">&quot;III&quot;</span>, <span class="string">&quot;IV&quot;</span>, <span class="string">&quot;V&quot;</span>, <span class="string">&quot;VI&quot;</span>, <span class="string">&quot;VII&quot;</span>, <span class="string">&quot;VIII&quot;</span>, <span class="string">&quot;IX&quot;</span>&#125;; </span><br><span class="line">	<span class="comment">//represents 0,   1,    2,     3,    4,  5,    6,     7,      8,    9</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> M[num/<span class="number">1000</span>] + C[(num%<span class="number">1000</span>)/<span class="number">100</span>] + X[(num%<span class="number">100</span>)/<span class="number">10</span>] + I[num%<span class="number">10</span>]; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p><br><br><br></p>
<hr>
<p><a name="romantoInteger"></a></p>
<h1 id="13-Roman-to-Integer"><a href="#13-Roman-to-Integer" class="headerlink" title="13-Roman to Integer"></a>13-Roman to Integer</h1><p>Roman numerals are represented by seven different symbols I, V, X, L, C, D and M </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Symbol 		Value </span><br><span class="line">I		1</span><br><span class="line">V		5</span><br><span class="line">X		10 </span><br><span class="line">L		50</span><br><span class="line">C		100</span><br><span class="line">D		500</span><br><span class="line">M		1000</span><br></pre></td></tr></table></figure>

<p>For example, two is written as II in Roman numeral, just two one’s added together. Twelve is written as<br>XII which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II. </p>
<p>Roman numerals are usually written largest to smallest from left to right. However, the numeral for<br>four is not IIII. Instead, the number four is written as IV. Because the one is before the five we<br>subtract it making four. The same principle applies to the number nine which is written as IX. There<br>are six instances where subtraction is used: </p>
<ul>
<li>I can be placed before V (5) and X (10) to make 4 and 9 </li>
<li>X can be placed before L (50) and C(100) to make 40 and 90 </li>
<li>C can be placed before D (500) and M(1000) to make 400 and 900</li>
</ul>
<p>Given an integer, convert it to a roman numeral, Input is guaranteed to be within the range from<br>1 to 3999</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Example 1: </span><br><span class="line">	</span><br><span class="line">Input: &quot;III&quot; </span><br><span class="line">Output: 3 </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Example 2: </span><br><span class="line"></span><br><span class="line">Input: &quot;IV&quot; </span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Example 3: </span><br><span class="line"></span><br><span class="line">Input: &quot;IX&quot; </span><br><span class="line">Output: 9 </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Example 4: </span><br><span class="line"></span><br><span class="line">Input: &quot;LVIII&quot; </span><br><span class="line">Output: 58 </span><br><span class="line">Explanation: L=50, V=5, III=3</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Example 5: </span><br><span class="line"></span><br><span class="line">Input: &quot;MCMXCIV&quot; </span><br><span class="line">Output: 1994</span><br><span class="line">Explanation: M=1000, CM=900, XC=90 and IV=4</span><br></pre></td></tr></table></figure>
<p><br><br><br><a name="romantoIntegerCharacterArray"></a></p>
<h2 id="Character-Array"><a href="#Character-Array" class="headerlink" title="Character Array"></a>Character Array</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">romanToInt</span><span class="params">(String s)</span> &#123;</span><br><span class="line">		Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>(); </span><br><span class="line">		map.put(<span class="string">&#x27;I&#x27;</span>, <span class="number">1</span>); </span><br><span class="line">		map.put(<span class="string">&#x27;V&#x27;</span>, <span class="number">5</span>); </span><br><span class="line">		map.put(<span class="string">&#x27;X&#x27;</span>, <span class="number">10</span>); </span><br><span class="line">		map.put(<span class="string">&#x27;L&#x27;</span>, <span class="number">50</span>); </span><br><span class="line">		map.put(<span class="string">&#x27;C&#x27;</span>, <span class="number">100</span>); </span><br><span class="line">		map.put(<span class="string">&#x27;D&#x27;</span>, <span class="number">500</span>); </span><br><span class="line">		map.put(<span class="string">&#x27;M&#x27;</span>, <span class="number">1000</span>); </span><br><span class="line"></span><br><span class="line">		<span class="type">char</span>[] sc= s.toCharArray(); </span><br><span class="line">		<span class="type">int</span> total= map.get(sc[<span class="number">0</span>]); </span><br><span class="line">		<span class="type">int</span> pre=map.get(sc[<span class="number">0</span>]); </span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;sc.length; i++) &#123;</span><br><span class="line">			<span class="type">int</span> curr=map.get(sc[i]); </span><br><span class="line">			<span class="keyword">if</span> (curr&lt;=pre) &#123;</span><br><span class="line">				total= total + curr; </span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				total=total+curr -<span class="number">2</span>*pre; </span><br><span class="line">			&#125;</span><br><span class="line">			pre=curr; </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> total; </span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><br><br><br></p>
<hr>
<p><a name="longestCommonPrefix"></a></p>
<h1 id="14-Longest-Common-Prefix"><a href="#14-Longest-Common-Prefix" class="headerlink" title="14-Longest Common Prefix"></a>14-Longest Common Prefix</h1><p>Write a function to find the longest common prefix string amongst an array of strings. If there is no<br>common prefix, return an empty string “”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Example 1: </span><br><span class="line"></span><br><span class="line">Input: [&quot;flower&quot;, &quot;flow&quot;, &quot;flight&quot;]</span><br><span class="line">Output: &quot;fl&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Example 2: </span><br><span class="line"></span><br><span class="line">Input: [&quot;dog&quot;, &quot;racecar&quot;, &quot;car&quot;] </span><br><span class="line">Output: &quot;&quot;</span><br><span class="line"></span><br><span class="line">Explanation: There is no common prefix among the input strings </span><br></pre></td></tr></table></figure>

<p><em>Note:</em><br>All given inputs are in lowercase letters a-z</p>
<p><br><br><br><a name="longestCommonPrefixHorizontalScanning"></a></p>
<h2 id="Horizontal-Scanning"><a href="#Horizontal-Scanning" class="headerlink" title="Horizontal Scanning"></a>Horizontal Scanning</h2><br>
*Intuition:* 

<p>For a start we will describe a simple way of find the longest prefix shared by a set of strings<br>LCP(S1 … Sn).We will use the observation that: </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LCP(S1 ... Sn) = LCP(LCP(LCP(S1, S2), S3), ... Sn) </span><br></pre></td></tr></table></figure>

<p><br><br><br><em>Algorithm:</em></p>
<p>To employ this idea, the algorithm iterates through the strings [S1 … Sn]. finding at each iteration<br>i the longest common prefix of strings LCP(S1 … Si). When LCP(S1 … Si) is an empty string, the<br>algorithm ends. Otherwise after n iterations, the algorithm returns LCP(S1 … Sn) </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Example: </span><br><span class="line"></span><br><span class="line">&#123;leets, leetcode, leet, leeds&#125;</span><br><span class="line">   \       /      </span><br><span class="line">  LCP&#123;1,2&#125; = leets</span><br><span class="line">  	     leetcode</span><br><span class="line">	     leet </span><br><span class="line"></span><br><span class="line">	 	\	&#123;leets, leetcode, leet, leeds&#125;</span><br><span class="line">		 \ 			   /</span><br><span class="line"></span><br><span class="line">		 LCP&#123;1,3&#125; = leet</span><br><span class="line">		 	    leet</span><br><span class="line">			    leet</span><br><span class="line"></span><br><span class="line">			      \          &#123;leets, leetcode, leet, leeds&#125;</span><br><span class="line">			       \ 				  /</span><br><span class="line">			       LCP&#123;1,4&#125;   leet</span><br><span class="line">			       		  leeds</span><br><span class="line">					  lee</span><br><span class="line"></span><br><span class="line">				LCP&#123;1,4&#125; = &quot;lee&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String longestCommon <span class="title function_">Prefix</span><span class="params">(String[] strs)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (strs.length==<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;&quot;</span>; </span><br><span class="line">	&#125;</span><br><span class="line">	String prefix=strs[<span class="number">0</span>]; </span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;strs.length; i++) &#123;</span><br><span class="line">		<span class="keyword">while</span> (strs[i].indexOf(prefix) != <span class="number">0</span>) &#123;</span><br><span class="line">			prefix=prefix.substring(<span class="number">0</span>, prefix.length() -<span class="number">1</span>);</span><br><span class="line">			<span class="keyword">if</span> (prefix.isEmpty()) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> prefix; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Complexity Analysis</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Time complexity: 	O(S)	Where S is the sum of all characters in all strings. In the worse case</span><br><span class="line">				all n strings are the same. The algorithm compares the string S1 with </span><br><span class="line">				the other strings [S2 ... Sn]. There are S character comparisons where</span><br><span class="line">				S is the sum of all characters in the input array </span><br><span class="line"></span><br><span class="line">Space complexity: 	O(1) 	We only used constant extra space </span><br></pre></td></tr></table></figure>


<p><br><br><br><a name="longestCommonPrefixVerticalScanning"></a></p>
<h2 id="Vertical-Scanning"><a href="#Vertical-Scanning" class="headerlink" title="Vertical Scanning"></a>Vertical Scanning</h2><p>Imagine a very short string is at the end of the array. The above approach will still do S comparisons.<br>One way to optimize this case is to do vertical scanning. We compare characters from top to bottom on<br>the same column (same character index of the strings) before moving on to the next column. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">longestCommonPrefix</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (strs==<span class="literal">null</span> || strs.length==) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>; </span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;strs[<span class="number">0</span>].length(); i++)&#123;</span><br><span class="line">		<span class="type">char</span> c=strs[<span class="number">0</span>].charAt(i); </span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>; j&lt;strs.length; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (i==strs[j].length() || strs[j].charAt(i)!=c)&#123;</span><br><span class="line">				<span class="keyword">return</span> strs[<span class="number">0</span>].substring(<span class="number">0</span>,i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> strs[<span class="number">0</span>]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Complexity Analysis</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Time complexity: 	O(S) 	Where S is the sum of all characters in all strings. In the worst case</span><br><span class="line">				there will be n equal strings with length m and the algorithm performs</span><br><span class="line">				S=n*m character comparisons. Even the worst case is still the same as </span><br><span class="line">				Approach 1, in the best case there are at most n*minLen comparisons </span><br><span class="line">				where minLen is the length of the shortest string in the array. </span><br><span class="line"></span><br><span class="line">Space complexity: 	O(1)	We only used constant extra space</span><br></pre></td></tr></table></figure>

<p><br><br><br><a name="longestCommonPrefixDivideandConquer"></a></p>
<h2 id="Divide-and-Conquer"><a href="#Divide-and-Conquer" class="headerlink" title="Divide and Conquer"></a>Divide and Conquer</h2><p>The idea of the algorithm comes from the associative property of LCP operation. We notice that:<br>LCP(S1 … Sn) &#x3D; LCP(LCP(S1 … Sk), LCP(Sk+1 … Sn)), where LCP(S1 … Sn) is the longest common<br>prefix in a set of strings [S1 … Sn], 1&lt;k&lt;n </p>
<p><br><br><br><em>Algorithm</em> </p>
<p>To apply the previous observation, we use the divide and conquer technique, where we split the<br>LCP(Si … Sj) problem into two subproblems LCP(Si … Smid) and LCP(Smid+1 … Sj), where mid is<br>(i+j)&#x2F;2. We use their solutions lcpLeft and lcpRight to construct the solution of the main problem<br>LCP(Si … Sj). To accomplish this we compare one by one the characters of lcpLeft and lcpRight till<br>there is no character match. The found common prefix of lcpLeft and lcpRight is the solution of the<br>LCP(Si … Sj) </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">				&#123;leetcode, leet, lee, le&#125; </span><br><span class="line"></span><br><span class="line">				    /                \   </span><br><span class="line">Divide 			&#123;leetcode, leet&#125;            &#123;lee, le&#125; </span><br><span class="line"></span><br><span class="line">Conquer				|			 | </span><br><span class="line"></span><br><span class="line">			     &#123;leet&#125; 		        &#123;le&#125; </span><br><span class="line"></span><br><span class="line">			         \                      /</span><br><span class="line"></span><br><span class="line">				 	   &#123;le&#125; </span><br><span class="line"></span><br><span class="line">	Searching for the longest common prefix (LCP) in dataset &#123;leetcode, leet, lee, le&#125; </span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">longestCommonPrefix</span><span class="params">(String[] strs)</span> &#123; </span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (strs == <span class="literal">null</span> || strs.length ==<span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">		<span class="keyword">return</span> longestCommonPrefix(strs, <span class="number">0</span>, strs.length-<span class="number">1</span>); </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String <span class="title function_">longestCommonPrefix</span><span class="params">(String[] strs, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123; </span><br><span class="line">	<span class="keyword">if</span> (l==r) &#123;</span><br><span class="line">		<span class="keyword">return</span> strs[l];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="type">int</span> mid=(l+r)/<span class="number">2</span>; </span><br><span class="line">		String lcpLeft= longestCommonPrefix(strs,l, mid); </span><br><span class="line">		String lcpRight= longestCommonPrefix(strs,mid+<span class="number">1</span>;r); </span><br><span class="line">		<span class="keyword">return</span> commonPrefix(lcpLeft,lcpRight);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String <span class="title function_">commonPrefix</span><span class="params">(String left, String right)</span> &#123;</span><br><span class="line">	<span class="type">int</span> min=Math.min(left.length(), right.length()); </span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;min; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (left.charAt(i) !=right.charAt(i) )&#123;</span><br><span class="line">			<span class="keyword">return</span> left.substring(<span class="number">0</span>, i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> left.substring(<span class="number">0</span>, min);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Complexity Analysis</strong></p>
<p>In the worst case we have n equal strings with length m</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Time Complexity: O(S)		where S is the number of all characters in the array, S=m*n so time</span><br><span class="line">				complexity is 2*T(n/2)+O(m). Therefore time complexity is O(S). In the</span><br><span class="line">				best case the algorithm performs O(minLen * n) comparisons, where</span><br><span class="line">				minLen is the shortest string of the array </span><br><span class="line"></span><br><span class="line">Space Complexity: O(m*log(n))	There is a memory overhead since we sotre recursive call in the </span><br><span class="line">				execution stack. There are log(n) recursive calls, each store needs m</span><br><span class="line">				space to store the result so space complexity is O(m*log(n))</span><br></pre></td></tr></table></figure>

<p><br><br><br><a name="longestCommonPrefixBinarySearch"></a></p>
<h2 id="Binary-Search"><a href="#Binary-Search" class="headerlink" title="Binary Search"></a>Binary Search</h2><p>The idea is to apply binary search method to find the string with maximum value L, which is common<br>prefix of all the strings. The algorithm searches the space in the interval (0 … minLen), where<br>minLen is minimum string length and the maximum possible common prefix. Each time search space is<br>divided in two equal parts, one of them is discarded because it is sure that it doesn’t contain the<br>solution. There are two possible cases: </p>
<ul>
<li>S[1…mid] is not a common string. This means that for each j&gt;i, S[1…j] is not a common string and we discard the second half of the search space</li>
<li>S [1…mid] is common string. This means that for each i&lt;j, S[1…i] is a common string and we discard the first half of the search space, because we try to find longer common prefix</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">	&#123;leets, leetcode, leetc, leeds&#125; </span><br><span class="line"></span><br><span class="line">		|</span><br><span class="line">	      </span><br><span class="line">	     &quot;leets&quot;</span><br><span class="line">	    /        \</span><br><span class="line">	 &quot;lee&quot;      &quot;ts&quot;</span><br><span class="line"></span><br><span class="line">	     midpoint </span><br><span class="line"></span><br><span class="line">&quot;lee&quot; in &quot;leetcode&quot; : yes</span><br><span class="line">&quot;lee&quot; in &quot;leetc&quot; : yes</span><br><span class="line">&quot;lee&quot; in &quot;leeds&quot; : yes</span><br><span class="line"></span><br><span class="line">		|</span><br><span class="line"></span><br><span class="line">	     &quot;leets&quot;</span><br><span class="line">	     /     \</span><br><span class="line">	  &quot;lee&quot;    &quot;ts&quot;</span><br><span class="line">	    |      /   \</span><br><span class="line"></span><br><span class="line">	  &quot;lee&quot;   &quot;t&quot;   &quot;s&quot;</span><br><span class="line">	        </span><br><span class="line">		   midpoint</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		   &quot;leet&quot; in &quot;leetcode&quot; : yes</span><br><span class="line">		   &quot;leet&quot; in &quot;leetc&quot; : yes </span><br><span class="line">		   &quot;leet&quot; in &quot;leeds&quot; : no</span><br><span class="line"></span><br><span class="line">		   LCP= &quot;lee&quot; </span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">longestCommonPrefix</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (strs==<span class="literal">null</span> || strs.length==<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">	<span class="type">int</span> minLen=Integer.MAX_VALUE; </span><br><span class="line">	<span class="keyword">for</span> (String str: strs)</span><br><span class="line">		minLen=Math.min(minLen, str.length());</span><br><span class="line">	<span class="type">int</span> low=<span class="number">1</span>; </span><br><span class="line">	<span class="type">int</span> high=min Len; </span><br><span class="line">	<span class="keyword">while</span> (low&lt;=high) &#123;</span><br><span class="line">		<span class="type">int</span> middle=(low+high)/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span> (isCommonPrefix(strs, middle)</span><br><span class="line">			low=middle+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">			high=middle-<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> strs[<span class="number">0</span>].substring(<span class="number">0</span>, (low + high)/<span class="number">2</span>);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isCommonPrefix</span><span class="params">(String[] strs, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">	String str1=strs[<span class="number">0</span>].substring(<span class="number">0</span>,len);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;strs.length; i++)</span><br><span class="line">		<span class="keyword">if</span> (!strs[i].startsWith(str1))</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>**Complexity Analysis</p>
<p>In the worst case we have n equal strings with length m </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Time complexity: 	O(S * log(n)), where S is the sum of all characters in all strings. The</span><br><span class="line">			algorithm makes log(n) iterations, for each of them there are S=m*n </span><br><span class="line">			comparisons, which gives in total O(S * log(n)) time complexity</span><br><span class="line"></span><br><span class="line">Space complexity: 	O(1). We only used constant extra space </span><br></pre></td></tr></table></figure>
<p><br><br><br><a name="longestCommonPrefixFurtherThoughts"></a></p>
<h2 id="Further-Thoughts"><a href="#Further-Thoughts" class="headerlink" title="Further Thoughts"></a>Further Thoughts</h2><p>Considering a slightly different problem: </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Given a set of keys S= [S1, S2 ... Sn], find the longest common prefix among a string q and S.</span><br><span class="line">This LCP query will be called frequently</span><br></pre></td></tr></table></figure>
<p>We coule optimize LCP queries by storing the set of keys S in a Trie. See this for Trie<br>implementation. In a Trie, each node descending from the root represents a common prefix of some keys. But we need to<br>find the longest common prefix of a string q and all key strings. This means that we have to find the<br>deepest path from the root, which satisfies the following conditions </p>
<ul>
<li>it is a prefix of query string q</li>
<li>each node along the path must contain only one child element. Otherwise the found path will not be a<br>common prefix among all strings</li>
<li>the path doesn’t comprise of nodes which are marked as end of key. Otherwise the path couldn’t be a<br>prefix of a key which is shorter than itself</li>
</ul>
<p><br><br><br><em>Algorithm</em> </p>
<p>The only question left is how to find the deepest path in the Trie, that fulfills the requirements<br>above. The most effective way is to build a trie from {S1 … Sn] strings. Then find the prefix of<br>query string q in the Trie. We traverse the Trie from the root, till it is impossible to continue the<br>path in the Trie because one of the conditions above is not satisfied. </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Searching for the longest common prefix of string &quot;le&quot; in a Trie from dataset &#123;lead, leet&#125;</span><br><span class="line"></span><br><span class="line">			Root</span><br><span class="line"></span><br><span class="line">			 1</span><br><span class="line"></span><br><span class="line">	l   ===========&gt;  \  l</span><br><span class="line"></span><br><span class="line">			     2</span><br><span class="line"></span><br><span class="line">	e   ===============&gt;   \ e</span><br><span class="line"></span><br><span class="line">LCP &quot;le&quot; FOUND	=============&gt;   3   </span><br><span class="line"></span><br><span class="line">			     a	/  \ e    End of Key &quot;lee&quot; </span><br><span class="line">				     </span><br><span class="line">			      6      4</span><br><span class="line"></span><br><span class="line">			 d  /	       \ t</span><br><span class="line">				        </span><br><span class="line">END OF KEY &quot;lead&quot;	  7		 5   End of key &quot;leet&quot;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">public String longestCommonPrefix(String q, String[] strs) &#123;</span><br><span class="line">    if (strs == null || strs.length == 0)</span><br><span class="line">         return &quot;&quot;;  </span><br><span class="line">    if (strs.length == 1)</span><br><span class="line">         return strs[0];</span><br><span class="line">    Trie trie = new Trie();      </span><br><span class="line">    for (int i = 1; i &lt; strs.length ; i++) &#123;</span><br><span class="line">        trie.insert(strs[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return trie.searchLongestPrefix(q);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class TrieNode &#123;</span><br><span class="line"></span><br><span class="line">    // R links to node children</span><br><span class="line">    private TrieNode[] links;</span><br><span class="line"></span><br><span class="line">    private final int R = 26;</span><br><span class="line"></span><br><span class="line">    private boolean isEnd;</span><br><span class="line"></span><br><span class="line">    // number of children non null links</span><br><span class="line">    private int size;    </span><br><span class="line">    public void put(char ch, TrieNode node) &#123;</span><br><span class="line">        links[ch -&#x27;a&#x27;] = node;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getLinks() &#123;</span><br><span class="line">        return size;</span><br><span class="line">    &#125;</span><br><span class="line">    //assume methods containsKey, isEnd, get, put are implemented as it is described</span><br><span class="line">   //in  https://leetcode.com/articles/implement-trie-prefix-tree/)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Trie &#123;</span><br><span class="line"></span><br><span class="line">    private TrieNode root;</span><br><span class="line"></span><br><span class="line">    public Trie() &#123;</span><br><span class="line">        root = new TrieNode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//assume methods insert, search, searchPrefix are implemented</span><br><span class="line">    private String searchLongestPrefix(String word) &#123;</span><br><span class="line">        TrieNode node = root;</span><br><span class="line">        StringBuilder prefix = new StringBuilder();</span><br><span class="line">        for (int i = 0; i &lt; word.length(); i++) &#123;</span><br><span class="line">            char curLetter = word.charAt(i);</span><br><span class="line">            if (node.containsKey(curLetter) &amp;&amp; (node.getLinks() == 1) &amp;&amp; (!node.isEnd())) &#123;</span><br><span class="line">                prefix.append(curLetter);</span><br><span class="line">                node = node.get(curLetter);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">                return prefix.toString();</span><br><span class="line"></span><br><span class="line">         &#125;</span><br><span class="line">         return prefix.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Complexity Analysis</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In the worst case query q has length m and is equal to all n strings of the array </span><br><span class="line"></span><br><span class="line">Time Complexity:   O(S)   where S is the number of all characters in the array, LCP query O(m) </span><br><span class="line">  			  Trie build has O(S) time complexity. To find the common prefix of q </span><br><span class="line">			  in the Trie takes in the worst O(m). </span><br><span class="line"></span><br><span class="line">Space complexity:  O(S)   we only used additional S extra space for the Trie. </span><br></pre></td></tr></table></figure>


<p><br><br><br></p>
<hr>
<p><a name="threeSum"></a></p>
<h1 id="15-3Sum"><a href="#15-3Sum" class="headerlink" title="15-3Sum"></a>15-3Sum</h1><p>Given an array “nums” of n integers, are there elements a, b, c in nums such that a+b+c&#x3D;0? Find all<br>unique triplets in the array which gives the sum of zero. </p>
<p>Note: </p>
<p>The solution set must not contain duplicate triplets </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Example: </span><br><span class="line"></span><br><span class="line">Given array nums = [-1, 0, 1, 2, -1, -4]. </span><br><span class="line"></span><br><span class="line">A solution set is: </span><br><span class="line">[</span><br><span class="line">  [-1, 0, 1],</span><br><span class="line">  [-1, -1, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p><br><br><br><a name="threeSumSortedArray"></a></p>
<h2 id="Sorted-Array"><a href="#Sorted-Array" class="headerlink" title="Sorted Array"></a>Sorted Array</h2><p>The method is to sort an input array and then run through all indices of a possible first element of a<br>triplet. For each element we make another 2Sum sweep of the remaining part of the array. Also we want<br>to skip elements to avoid duplicates in the answer without expending extra memory. </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] num) &#123;</span><br><span class="line">    </span><br><span class="line">    //Arrays.sort re-arranges the array of integers in ascending order</span><br><span class="line">    //ex. [1, 2, 3, 4]</span><br><span class="line"></span><br><span class="line">    Arrays.sort(num);</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); </span><br><span class="line">    for (int i = 0; i &lt; num.length-2; i++) &#123;</span><br><span class="line">        if (i == 0 || (i &gt; 0 &amp;&amp; num[i] != num[i-1])) &#123;</span><br><span class="line">            </span><br><span class="line">	    //This lets us skip some of the duplicate entries in the array</span><br><span class="line">	    </span><br><span class="line">	    int lo = i+1, hi = num.length-1, sum = 0 - num[i];</span><br><span class="line"></span><br><span class="line">	    //This is for the 2 Sum sweep </span><br><span class="line"></span><br><span class="line">            while (lo &lt; hi) &#123;</span><br><span class="line">                if (num[lo] + num[hi] == sum) &#123;</span><br><span class="line">                    res.add(Arrays.asList(num[i], num[lo], num[hi]));</span><br><span class="line">                    while (lo &lt; hi &amp;&amp; num[lo] == num[lo+1]) lo++;</span><br><span class="line">                    while (lo &lt; hi &amp;&amp; num[hi] == num[hi-1]) hi--;</span><br><span class="line"></span><br><span class="line">		    //This lets us skip some of the duplicate entries in the array</span><br><span class="line"></span><br><span class="line">                    lo++; hi--;</span><br><span class="line">                &#125; else if (num[lo] + num[hi] &lt; sum) lo++;</span><br><span class="line">                else hi--;</span><br><span class="line"></span><br><span class="line">		//This allows us to optimize slightly since we know that the array is sorted</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Complexity Analysis</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Time Complexity:  O(n^2)   We go through a maximum of n elements for the first element of a triplet, </span><br><span class="line">			   and then when making a bi-directional 2Sum sweep of the remaining part of </span><br><span class="line">			   the array we also go through a maxiumum of n elements. </span><br><span class="line"></span><br><span class="line">Space Complexity: O(1)	   If we assume the return linked list is not extra space, then we do not </span><br><span class="line">			   allocate any significant extra space</span><br></pre></td></tr></table></figure>



<p><br><br><br></p>
<hr>
<p><a name="threeSumClosest"></a></p>
<h1 id="16-3Sum-Closest"><a href="#16-3Sum-Closest" class="headerlink" title="16-3Sum Closest"></a>16-3Sum Closest</h1><p>Given an array nums of n integers and an integer target, find three integers in nums such that the sum<br>is closest to target. Return the sum of the three integers. You may assume that each input would have<br>exactly one solution. </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Given array nums=[-1, 2, 1, -4], and target=1.</span><br><span class="line"></span><br><span class="line">The sum that is closest to the target is 2. (-1+2+1=2)</span><br></pre></td></tr></table></figure>

<p><br><br><br><a name="threeSumClosestThreePointers"></a></p>
<h2 id="3-Pointers"><a href="#3-Pointers" class="headerlink" title="3 Pointers"></a>3 Pointers</h2><p>Similar to the previous 3Sum problem, we use three pointers to point to the current element, next<br>element and the last element. If the sum is less than the target, it means that we need to add a larger<br>element so next element move to the next. If the sum is greater, it means we have to add a smaller<br>element so last element move to the second last element. Keep doing this until the end. Each time<br>compare the difference between sum and target, if it is less than minimum difference so far, then<br>replace result with it, otherwise continue iterating. </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">		public int threeSumClosest(int[] num, int target) &#123;</span><br><span class="line">		int result=num[0] + num[1] + num[num.length-1];</span><br><span class="line">		Arrays.sort(num);</span><br><span class="line">		for (int i=0; i&lt;num.length -2; i++) &#123;</span><br><span class="line">			int start= i+1, end = num.length -1;</span><br><span class="line">			while (start &lt; end) &#123;</span><br><span class="line">				int sum = num[i] + num[start] + num[end];</span><br><span class="line">				if (sum &gt; target) &#123;</span><br><span class="line">					end--;</span><br><span class="line">				&#125; else &#123;</span><br><span class="line">					start++;</span><br><span class="line">				&#125;</span><br><span class="line">				if (Math.abs(sum-target) &lt; Math.abs(result-target)) &#123;</span><br><span class="line">					result=sum;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return result;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><br><br><br></p>
<hr>
<p><a name="letterCombinationsofaPhoneNumber"></a></p>
<h1 id="17-Letter-Combinations-of-a-Phone-Number"><a href="#17-Letter-Combinations-of-a-Phone-Number" class="headerlink" title="17-Letter Combinations of a Phone Number"></a>17-Letter Combinations of a Phone Number</h1><p>Given a string contianing digits from 2-9 inclusive, return all possible letter combinations that the<br>number could represent. </p>
<p>A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not<br>map to any letters. </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2 - abc 	3 - def 	4 - ghi		5 - jkl		6 - mno		7 - pqrs 	8 - tuv</span><br><span class="line">				</span><br><span class="line">						9 - wxyz</span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Example: </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Input: &quot;23&quot; </span><br><span class="line"></span><br><span class="line">Output: [&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;]. </span><br></pre></td></tr></table></figure>


<p><em>Note: The above answer is in lexicographical order but the answer can be in any order</em></p>
<p><br><br><br><a name="letterCombinationsofaPhoneNumberBacktracking"></a></p>
<h2 id="Backtracking"><a href="#Backtracking" class="headerlink" title="Backtracking"></a>Backtracking</h2><p>Backtracking is an algorithm for finding all solutions by exploring all potential candidates. If the<br>solution candidate turns to not be a solution (or at least not the last one), backtracking algorithm<br>discards it by making some changes on the previous step, ie <em>backtracks</em> and then tries again. </p>
<p>Here is a backtrack function backtrack(combination, next_digits) which takes as arguments an ongoing<br>letter combination and the next digits to check. </p>
<ul>
<li>If there are no more digits to check that means the current combination is done </li>
<li>If there are still digits to check: <ul>
<li>Iterate over the letters mapping to the next available digit</li>
<li>Append the current letter to the current combination and proceed to check next digits:</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">combination = combination + letter</span><br><span class="line"></span><br><span class="line">backtrack(combination + letter, next_digits[1:]).</span><br></pre></td></tr></table></figure>


<p><strong>Visual Representation</strong> </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/SamirPaulb/assets/main/Screenshot-2022-10-26-180426.png" alt="Visual Representation"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>Complexity Analysis</strong> </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Time Complexity: 	O(3^N * 4^M) 	where N is the number of digits in the input that maps to 3</span><br><span class="line">					letters (eg. 2, 3, 4, 5, 6, 8) and M is the number of digits </span><br><span class="line">					in the input that maps to 4 letters (eg. 7, 9) and N+M is the </span><br><span class="line">					total number digits in the input </span><br><span class="line"></span><br><span class="line">Space Complexity: 	O(3^N * 4^M)	since one has to keep 3^N * 4^M solutions </span><br></pre></td></tr></table></figure>



<p><br><br><br><a name="letterCombinationsofaPhoneNumberFIFOQueue"></a></p>
<h2 id="First-In-First-Out-FIFO-Queue"><a href="#First-In-First-Out-FIFO-Queue" class="headerlink" title="First In First Out (FIFO) Queue"></a>First In First Out (FIFO) Queue</h2><p>This solution utilizes the Single Queue Breadth First Search (BFS) which is an algorithm for traversing<br>or searching tree or graph data structures. It starts at the tree root and explores all of the neighbor<br>nodes. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;String&gt; <span class="title function_">letterCombinations</span><span class="params">(String digits)</span> &#123;</span><br><span class="line">	</span><br><span class="line">	LinkedList&lt;String&gt; ans = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;String&gt;();</span><br><span class="line">	<span class="keyword">if</span> (digits.isEmpty()) <span class="keyword">return</span> ans; </span><br><span class="line">	String[] mapping = <span class="keyword">new</span> <span class="title class_">String</span>[] &#123;<span class="string">&quot;0&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>, <span class="string">&quot;jkl&quot;</span>, <span class="string">&quot;mno&quot;</span>, <span class="string">&quot;pqrs&quot;</span>, <span class="string">&quot;tuv&quot;</span>, &#123;wxyz<span class="string">&quot;&#125;;</span></span><br><span class="line"><span class="string">	ans.add(&quot;</span><span class="string">&quot;); </span></span><br><span class="line"><span class="string">	for (int i = 0; i&lt;digits.length(); i++) &#123;</span></span><br><span class="line"><span class="string">		int x = Character.getNumericValue(digits.charAt(i)); </span></span><br><span class="line"><span class="string">		</span></span><br><span class="line"><span class="string">		//we terminate the while loop when we encounter a new-formed string which is more than</span></span><br><span class="line"><span class="string">		//the current level i </span></span><br><span class="line"><span class="string">		</span></span><br><span class="line"><span class="string">		//peek retrieves the first value of the linked list</span></span><br><span class="line"><span class="string">		while (ans.peek().length==i)&#123;</span></span><br><span class="line"><span class="string">			</span></span><br><span class="line"><span class="string">			//removes the head or the first value in the linkedlist</span></span><br><span class="line"><span class="string">			String t = ans.remove(); </span></span><br><span class="line"><span class="string">			for (char s : mapping[x].toCharArray()) &#123;</span></span><br><span class="line"><span class="string">				ans.add(t+s);</span></span><br><span class="line"><span class="string">				//this works because add appends to the end of the list</span></span><br><span class="line"><span class="string">			&#125;</span></span><br><span class="line"><span class="string">		&#125;</span></span><br><span class="line"><span class="string">		return ans; </span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>Complexity Analysis</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Time Complexity: 	O(3^N * 4^M) 	where N is the number of digits in the input that maps to 3</span><br><span class="line">					letters (eg. 2, 3, 4, 5, 6, 8) and M is the number of digits </span><br><span class="line">					in the input that maps to 4 letters (eg. 7, 9) and N+M is the </span><br><span class="line">					total number digits in the input </span><br><span class="line"></span><br><span class="line">Space Complexity: 	O(3^N * 4^M)	since one has to keep 3^N * 4^M solutions </span><br></pre></td></tr></table></figure>

<p><br><br><br></p>
<hr>
<p><a name="fourSum"></a></p>
<h1 id="18-4Sum"><a href="#18-4Sum" class="headerlink" title="18-4Sum"></a>18-4Sum</h1><p>Given an array nums of n integers and an integer target, are there elements a, b, c, and d in nums such<br>that a + b + c + d &#x3D; target? Find all unique quadruplets in the array which gives the sum of target</p>
<p><em>Note:</em><br>The solution set must not contain duplicate quadruplets </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Example: </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Given array nums = [1, 0, -1, 0, -2, 2], and target = 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">A solution set is: </span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">  [-1,  0, 0, 1],</span><br><span class="line">  [-2, -1, 1, 2],</span><br><span class="line">  [-2,  0, 0, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>


<p><br><br><br><a name="fourSumSortedArray"></a></p>
<h2 id="Sorted-Array-1"><a href="#Sorted-Array-1" class="headerlink" title="Sorted Array"></a>Sorted Array</h2><p>The idea is the same as the other numbered sum problems like 2sum and 3sum. We sort the array and then<br>proceed to interate through the values until we end up with a result that we are looking for. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">fourSum</span><span class="params">(<span class="type">int</span>[] num, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">		</span><br><span class="line">		ArrayList&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (num.length&lt;<span class="number">4</span>) &#123;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">return</span> ans;</span><br><span class="line">		&#125;</span><br><span class="line">		Arrays.sort(num); </span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;num.length-<span class="number">3</span>; i++) &#123;   <span class="comment">//picking the first candidate must leave room</span></span><br><span class="line">						       <span class="comment">//for the other values </span></span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span> (num[i]+num[i+<span class="number">1</span>]+num[i+<span class="number">2</span>]+num[i+<span class="number">3</span>]&gt;target) &#123;</span><br><span class="line">				</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">				<span class="comment">//first candidate too large, search finished</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (num[i]+num[num.length-<span class="number">1</span>]+num[num.length-<span class="number">2</span>]+num[num.length-<span class="number">3</span>]&lt;target) &#123;</span><br><span class="line">				</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">				<span class="comment">//first candidate too small </span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; num[i]==num[i-<span class="number">1</span>]) &#123;</span><br><span class="line">				</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">				<span class="comment">//prevents duplicate in ans list</span></span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j=i+<span class="number">1</span>; j&lt;num.length-<span class="number">2</span>; j++) &#123;   <span class="comment">//picking the second candidate must</span></span><br><span class="line">								 <span class="comment">//leave room for other values </span></span><br><span class="line">				</span><br><span class="line">				<span class="keyword">if</span> (num[i]+num[j]+num[j+<span class="number">1</span>]+num[j+<span class="number">2</span>]&gt;target) &#123;</span><br><span class="line">					</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">					<span class="comment">//second candidate too large</span></span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (num[i]+num[j]+num[num.length-<span class="number">1</span>]+num[num.length-<span class="number">2</span>]&lt;target) &#123;</span><br><span class="line">				</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">					<span class="comment">//second candidate too small</span></span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span>(j&gt;i+<span class="number">1</span> &amp;&amp; num[j]==num[j-<span class="number">1</span>]) &#123;</span><br><span class="line">					</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">					<span class="comment">//prevents duplicate results in ans list</span></span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="type">int</span> low=j+<span class="number">1</span>, high=num.length-<span class="number">1</span>;</span><br><span class="line">				</span><br><span class="line">				<span class="comment">//two pointer search</span></span><br><span class="line">				<span class="keyword">while</span>(low&lt;high) &#123;</span><br><span class="line">					</span><br><span class="line">					<span class="type">int</span> sum=num[i]+num[j]+num[low]+num[high];</span><br><span class="line">					<span class="keyword">if</span> (sum==target) &#123;</span><br><span class="line">						</span><br><span class="line">						ans.add(Arrays.asList(num[i],num[j],num[low],num[high]));</span><br><span class="line">						<span class="keyword">while</span>(low&lt;high&amp;&amp;num[low]==num[low+<span class="number">1</span>]) &#123;</span><br><span class="line">							low++; <span class="comment">//skipping over duplicates</span></span><br><span class="line">						&#125;</span><br><span class="line"></span><br><span class="line">						<span class="keyword">while</span>(low&lt;high &amp;&amp; num[high]==num[high-<span class="number">1</span>] &#123;</span><br><span class="line">							high--; <span class="comment">//skipping over duplicates </span></span><br><span class="line">						&#125;</span><br><span class="line">						low++;</span><br><span class="line">						high--;</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">					<span class="comment">//moving window</span></span><br><span class="line">					<span class="keyword">else</span> <span class="keyword">if</span> (sum&lt;target) &#123;</span><br><span class="line">						low++;</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">					<span class="keyword">else</span> &#123;</span><br><span class="line">						high--;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






<p><br><br><br></p>
<hr>
<p><a name="removeNthNodefromEndofList"></a></p>
<h1 id="19-Remove-Nth-Node-From-End-of-List"><a href="#19-Remove-Nth-Node-From-End-of-List" class="headerlink" title="19-Remove Nth Node From End of List"></a>19-Remove Nth Node From End of List</h1><p>Given a linked list, remove the n-th node from the end of the list and return its head</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Example: </span><br><span class="line"></span><br><span class="line">Given linked list: 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5, and n=2 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">After removing the second node from the end, the linked list becomes </span><br><span class="line">		   </span><br><span class="line">		   1 -&gt; 2 -&gt; 3 -&gt; 5</span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong><br>Given n will always be valid </p>
<p><strong>Follow up:</strong><br>Could you do this in one pass? </p>
<p><br><br><br><a name="removeNthNodefromEndofListTwoPassAlgorithm"></a></p>
<h2 id="Two-Pass-Algorithm"><a href="#Two-Pass-Algorithm" class="headerlink" title="Two Pass Algorithm"></a>Two Pass Algorithm</h2><p><strong>Intuition</strong></p>
<p>We notice that the problem could be simply reduced to another one: Remove the (L-n+1)th node from the<br>beginning of the list, where L is the list length. This problem is easy to solve once we found the<br>list length L. </p>
<p><br><br><br><strong>Algorithm</strong> </p>
<p>First we will add an auxiliary “dummy” node, which points to the list head. The “dummy” node is used to<br>simplify some corner cases such as a list with only one node or removing the head of the list. On the<br>first pass, find the list length L. Then we set a pointer to the dummy node and start to move it<br>through the list till it comes to the (L-n)th node. We relink next pointer of the (L-n)th node to the<br>(L-n+2)th node and we are done. </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">D -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; NULL</span><br><span class="line"></span><br><span class="line">	    |</span><br><span class="line">	    v</span><br><span class="line"></span><br><span class="line">D -&gt; 1 -&gt; 2 -&gt; 4 -&gt; NULL</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>); </span><br><span class="line">	dummy.next = head; </span><br><span class="line">	<span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span><span class="number">0</span>; </span><br><span class="line">	<span class="type">ListNode</span> <span class="variable">first</span> <span class="operator">=</span> head; </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> (first!=<span class="literal">null</span>) &#123;</span><br><span class="line">		</span><br><span class="line">		length++;</span><br><span class="line">		first=first.next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	length -= n; </span><br><span class="line">	first = dummy;</span><br><span class="line">	<span class="keyword">while</span> (length&gt;<span class="number">0</span>) &#123;</span><br><span class="line">		</span><br><span class="line">		length--;</span><br><span class="line">		first=first.next;</span><br><span class="line">	&#125;</span><br><span class="line">	first.next=first.next.next;</span><br><span class="line">	<span class="keyword">return</span> dummy.next; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Complexity Analysis</strong> </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Time Complexity: 	O(L) 	The algorithm makes two traversals of the list, first to calculate the </span><br><span class="line">				list length L and second to find the (L-n)th node. There are 2L-n </span><br><span class="line">				operations and time complexity is O(L)</span><br><span class="line"></span><br><span class="line">Space Complexity: 	O(1) 	We only used constant extra space</span><br></pre></td></tr></table></figure>





<p><br><br><br><a name="removeNthNodefromEndofListOnePassAlgorithm"></a></p>
<h2 id="One-Pass-Algorithm"><a href="#One-Pass-Algorithm" class="headerlink" title="One Pass Algorithm"></a>One Pass Algorithm</h2><p>The previous algorithm could be optimized to one pass. Instead of one pointer, we could use two<br>pointers. The first pointer advances the list by n+1 steps from the beginning, while the second pointer<br>starts from the beginning of the list. Now, both pointers are separated by exactly n nodes. We maintain<br>this constant gap by advancing both pointers together until the first pointer arrives past the last<br>node. The second pointer will be pointing at the nth node counting from the last. We relink the next<br>pointer of the node referenced by the second pointer to point to the node’s next next node. </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">Maintaining N=2 nodes apart between the first and second pointer </span><br><span class="line"></span><br><span class="line">	D	-&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; NULL</span><br><span class="line"></span><br><span class="line">       first 	 Head </span><br><span class="line">       second </span><br><span class="line"></span><br><span class="line">			   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Move the first pointer N+1 steps </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			     |</span><br><span class="line">			     v</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	D	-&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; NULL</span><br><span class="line"></span><br><span class="line">      second     Head       First</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Move the first and second pointers together until the first pointer arrives past the last node </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			     |</span><br><span class="line">			     v</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	D	-&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; NULL</span><br><span class="line">		</span><br><span class="line">		 Head      Second           First</span><br><span class="line"></span><br><span class="line">Second pointer points to the nth node counting from last so link node to the node&#x27;s next next node </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">				  |</span><br><span class="line">				  v</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	D	-&gt; 1 -&gt; 2 -&gt; 3 -&gt;   -&gt; 5 -&gt; NULL</span><br><span class="line">	         </span><br><span class="line">		 Head      Second           First</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">	dummy.next = head; </span><br><span class="line">	<span class="type">ListNode</span> <span class="variable">first</span> <span class="operator">=</span> dummy; </span><br><span class="line">	<span class="type">ListNode</span> <span class="variable">second</span> <span class="operator">=</span> dummy;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//Moves the first pointer so that the first and second nodes are separated by n nodes</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n+<span class="number">1</span>; i++) &#123;</span><br><span class="line">		</span><br><span class="line">		first = first.next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Move first to the end, maintaining the gap</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (first!=<span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">		first=first.next;</span><br><span class="line">		second=second.next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	second.next=second.next.next;</span><br><span class="line">	<span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>Complexity Analysis</strong> </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Time Complexity: 	O(L) 	The algorithm makes one traversal of the list of L nodes. Therefore</span><br><span class="line">				time complexity is O(L)</span><br><span class="line"></span><br><span class="line">Space Complexity: 	O(1)	Only constant extra space was used </span><br></pre></td></tr></table></figure>







<p><br><br><br></p>
<hr>
<p><a name="validParentheses"></a></p>
<h1 id="20-Valid-Parentheses"><a href="#20-Valid-Parentheses" class="headerlink" title="20-Valid Parentheses"></a>20-Valid Parentheses</h1><p>Given a string containing just the characters ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[‘, ‘]’, determine if the input<br>string is valid </p>
<p>An input string is valid if: </p>
<ol>
<li>Open brackets must be closed by the same type of brackets </li>
<li>Open brackets must be closed in the correct order</li>
</ol>
<p>Note that an empty string is also considered valid</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Example 1: </span><br><span class="line"></span><br><span class="line">Input: &quot;()&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Example 2: </span><br><span class="line"></span><br><span class="line">Input: &quot;()[]&#123;&#125;&quot;</span><br><span class="line">Output: true </span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Example 3: </span><br><span class="line"></span><br><span class="line">Input: &quot;(]&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Example 4: </span><br><span class="line"></span><br><span class="line">Input: &quot;([)]&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Example 5: </span><br><span class="line"></span><br><span class="line">Input: &quot;&#123;[]&#125;&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>






<p><br><br><br><a name="validParenthesesCounting"></a></p>
<h2 id="Counting-method"><a href="#Counting-method" class="headerlink" title="Counting method"></a>Counting method</h2><p><strong>Intuition</strong> </p>
<p>Imagine you are writing a small compiler for your college project and one of the tasks or sub-tasks for<br>the compiler would be to detect if the parenthesis are in place or not. </p>
<p>The algorithm we will look at in this article can be then used to process all the parenthesis in the<br>program your compiler is compiling and checking if all the parenthesis are in place. This makes<br>checking if a given string of parenthesis is valid or not, an important programming problem. </p>
<p>The expressions that we will deal with in this problem can consist of three different types of<br>parenthesis: </p>
<ul>
<li>() </li>
<li>{}</li>
<li>[]</li>
</ul>
<p>Before looking at how we can check if a given expression consisting of thes parenthesis is valid or<br>not, let us look at a simpler version of the problem that consists of just one type of parenthesis. So,<br>the expressions we can encounter in this simplified version of the problem are: </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(((((()))))) -- VALID</span><br><span class="line"></span><br><span class="line">()()()()     -- VALID</span><br><span class="line"></span><br><span class="line">(((((((()    -- INVALID</span><br><span class="line"></span><br><span class="line">((()(())))   -- VALID</span><br></pre></td></tr></table></figure>


<p>Let’s look at a simple algorithm to deal with this problem </p>
<p><br><br></p>
<ol>
<li><p>We process the expression one bracket at a time starting from the left </p>
</li>
<li><p>Suppose we encounter an opening bracket ie. <code>(</code>, it may or may not be an invalid expression because<br>there can be a matching ending bracket somewhere in the remaining part of the expression. Here, we<br>simply increment the counter keeping track of the left parenthesis till now. <code>left += 1</code></p>
</li>
<li><p>If we encounter a closing bracket, this has two meanings: </p>
<ul>
<li><p>There was no matching opening bracket for this closing bracket and in that case we have an invalid<br>expression. This is the case when <code>left==0</code> ie. when there are no unmatched left brackets<br>available</p>
</li>
<li><p>We had some unmatched opening bracket available to match this closing bracket. This is the case<br>when <code>left&gt;0</code> ie. we have unmatched left brackets available</p>
</li>
</ul>
</li>
<li><p>If we encounter a closing bracket ie. <code>)</code> when left&#x3D;&#x3D;0, then we have an invalid expression on our<br>hands. Else, we decrement <code>left</code> thus reducing the number of unmatched left parenthesis available.</p>
</li>
<li><p>Continue processing the string until all parenthesis have been processed</p>
</li>
<li><p>If in the end we still have an unmatched left parenthesis available, this implies an invalid<br>expression</p>
</li>
</ol>
<p><br><br></p>
<p>The reason we discussed this particular algorithm here is because the approach for the approach for<br>the original problem derives its inspiration from this very solution. </p>
<p>If we try and follow the same approach for our original problem, then it simply won’t work. The reason<br>a simple counter based approach works above is because all the parenthesis are of the same type. So<br>when we encounter a closing bracket, we simply assume a corresponding opening matching bracket<br>to be available ie. if <code>left&gt;0</code></p>
<p>But in our problem, if we encounter say <code>]</code>, we don’t really know if there is a corresponding opening<br><code>[</code> available or not. You could say: </p>
<blockquote>
<p>Why not maintain a separate counter for the different types of parenthesis?</p>
</blockquote>
<p>This doesn’t work because the relative placement of the parenthesis also matters here eg: <code>[&#123;]</code></p>
<p><br><br> </p>
<p>If we simply keep counters here, then as soon as we encounter the closing square bracket, we would<br>know there is an unmatched opening square bracket available as well. But, the **closest unmatched<br>opening bracket available is a curly bracket and not a square bracket and hence the counting approach<br>breaks here. </p>
<p><br><br><br><a name="validParenthesesStack"></a></p>
<h2 id="Stacks"><a href="#Stacks" class="headerlink" title="Stacks"></a>Stacks</h2><p>An interesting property about a valid parenthesis expression is that a sub-expression. (Not every<br>sub-expression) eg. </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123; [ [ ] &#123; &#125; ] &#125; ( ) ( ) </span><br><span class="line"></span><br><span class="line">  ^         ^</span><br><span class="line">  |         |</span><br></pre></td></tr></table></figure>

<p>The entire expression is valid, but sub portions of it are also valid in themselves. This lends a sort<br>of a recursive structure to the problem. For example consider the expression enclosed within the<br>marked parenthesis in the diagram above. The opening bracket is at index <code>1</code> and the corresponding<br>closing bracket is at index <code>6</code>. </p>
<blockquote>
<p>What if whenever we encounter a matching pair of parenthesis in the expression we simply remove it<br>from the expression? </p>
</blockquote>
<p>Let’s have a look at this idea below where we remove the smaller expressions one at a time from the<br>overall expression and since this is a valid expression, we would be left with an empty string in the<br>end. </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The stack data structure can come in handy here in representing this recursive structure of the </span><br><span class="line">problem. We can&#x27;t really process this from the inside out because we don&#x27;t have an idea about the </span><br><span class="line">overall structure. But, the stack can help us process this recursively ie. from outside to inwards.</span><br></pre></td></tr></table></figure>

<p>Lets take a look at the algorithm for this problem using stacks as the intermediate data structure. </p>
<p><strong>Algorithm</strong> </p>
<ol>
<li>Initialize a stack S. </li>
<li>Process each bracket of the expression one at a time </li>
<li>If we encounter an opening bracket, we simply push it onto the stack. This means we will process it<br>later, let us simply move onto the sub-expression ahead </li>
<li>If encounter a closing bracket, then we check the element on top of the stack. If the element at the<br>top of the stack is an opening bracket <code>of the same type</code>, then we pop it off the stack and continue<br>processing. Else, this implies an invalid expression </li>
<li>In the end, if we are left with a stack still having elements, then this implies an invalid<br>expression</li>
</ol>
<p>Lets take a look at the implementation for this algorithm</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//Hash table that takes care of the mappings</span></span><br><span class="line">	<span class="keyword">private</span> HashMap&lt;Character, Character&gt; mappings; </span><br><span class="line"></span><br><span class="line">	<span class="comment">//Initialize the hash map with mappings. This simply makes the code easier to read </span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Solution</span><span class="params">()</span> &#123;</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">this</span>.mappings = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Character, Character&gt;(); </span><br><span class="line">		<span class="built_in">this</span>.mappings.put(<span class="string">&#x27;)&#x27;</span>, <span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">		<span class="built_in">this</span>.mappings.put(<span class="string">&#x27;&#125;&#x27;</span>, <span class="string">&#x27;&#123;&#x27;</span>);</span><br><span class="line">		<span class="built_in">this</span>.mappings.put(<span class="string">&#x27;]&#x27;</span>, <span class="string">&#x27;[&#x27;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> &#123; </span><br><span class="line">		</span><br><span class="line">		<span class="comment">// Initialize a stack to be used in the algorithm</span></span><br><span class="line">		Stack&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Character&gt;();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt; s.length(); i++) &#123;</span><br><span class="line">			</span><br><span class="line">			<span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// If the current character is a closing bracket </span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">this</span>.mappings.containsKey(c)) &#123;</span><br><span class="line">				</span><br><span class="line">				<span class="comment">// Get the top element of the stack. If the stack is empty, set a dummy value of &#x27;#&#x27; </span></span><br><span class="line">				<span class="type">char</span> <span class="variable">topElement</span> <span class="operator">=</span> stack.empty() ? <span class="string">&#x27;#&#x27;</span> : stack.pop();</span><br><span class="line"></span><br><span class="line">				<span class="comment">// If the mapping for this bracket doesn&#x27;t match the stack&#x27;s top element, return false. </span></span><br><span class="line">				<span class="keyword">if</span> (topElement != <span class="built_in">this</span>.mappings.get(c)) &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				</span><br><span class="line">				<span class="comment">//If it was an opening bracket, push to the stack  </span></span><br><span class="line">				</span><br><span class="line">				stack.push(c);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//If the stack still contains elements, then it is an invalid expression. </span></span><br><span class="line">		<span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Complexity Analysis</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Time Complexity: 	O(n)	We simply traverse the given string one character at a time and push </span><br><span class="line">				and pop operations on a stack take O(1) time </span><br><span class="line"></span><br><span class="line">Space Complexity: 	O(n)	In the worst case, when we push all opening brackets onto the stack, we</span><br><span class="line">				will end up pushing all the brackets onto the stack eg (((((((((((</span><br></pre></td></tr></table></figure>


<p><br><br><br></p>
<hr>
<p><a name="mergeTwoSortedLists"></a></p>
<h1 id="21-Merge-Two-Sorted-Lists"><a href="#21-Merge-Two-Sorted-Lists" class="headerlink" title="21-Merge Two Sorted Lists"></a>21-Merge Two Sorted Lists</h1><p>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing<br>together the nodes of the first two lists. </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Example: </span><br><span class="line"></span><br><span class="line">Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure>



<p><br><br><br><a name="mergeTwoSortedListsRecursive"></a></p>
<h2 id="Recursive"><a href="#Recursive" class="headerlink" title="Recursive"></a>Recursive</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (l1 == <span class="literal">null</span>) <span class="keyword">return</span> l2; </span><br><span class="line">		<span class="keyword">if</span> (l2 == <span class="literal">null</span>) <span class="keyword">return</span> l1;</span><br><span class="line">		<span class="keyword">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class="line">			</span><br><span class="line">			l1.next = mergeTwoLists(l1.next, l2);</span><br><span class="line">			<span class="keyword">return</span> l1;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			</span><br><span class="line">			l2.next = mergeTwoLists(l1, l2.next);</span><br><span class="line">			<span class="keyword">return</span> l2;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><br><br><br><a name="mergeTwoSortedListsNonRecursive"></a></p>
<h2 id="Non-Recursive-1"><a href="#Non-Recursive-1" class="headerlink" title="Non-Recursive"></a>Non-Recursive</h2><p>Similar approach and implemenation to the recursive solution above but a little more intuitive and<br>does not require memory being held on the stack (as the recursive program runs it has to store<br>variables on the stack so that when the program jumps back it is able to continue) </p>
<p>As with most other linked list solutions, a dummy node is utilized and two pointers are used to keep<br>track of where we are in the the two linked lists. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">		</span><br><span class="line">		<span class="type">ListNode</span> <span class="variable">returnNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>); </span><br><span class="line">		<span class="type">ListNode</span> <span class="variable">headNode</span> <span class="operator">=</span> returnNode; </span><br><span class="line">		</span><br><span class="line">		<span class="keyword">while</span> (l1 != <span class="literal">null</span> &amp;&amp; l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (l1.val &lt;= l2.val) &#123;</span><br><span class="line">				returnNode.next = l1;</span><br><span class="line">				l1 = l1.next;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				returnNode.next = l2;</span><br><span class="line">				l2 = l2.next; </span><br><span class="line">			&#125;</span><br><span class="line">			returnNode = returnNode.next;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (l1 == <span class="literal">null</span>) &#123;</span><br><span class="line">			returnNode.next = l2;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (l2 == <span class="literal">null</span>) &#123;</span><br><span class="line">			returnNode.next = l1; </span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> headNode.next; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><br><br><br></p>
<hr>
<p><a name="generateParentheses"></a></p>
<h1 id="22-Generate-Parentheses"><a href="#22-Generate-Parentheses" class="headerlink" title="22-Generate Parentheses"></a>22-Generate Parentheses</h1><p>Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">For example: </span><br><span class="line"></span><br><span class="line">Given n=3, a solution set is: </span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">  &quot;((()))&quot;,</span><br><span class="line">  &quot;(()())&quot;.</span><br><span class="line">  &quot;(())()&quot;,</span><br><span class="line">  &quot;()(())&quot;,</span><br><span class="line">  &quot;()()()&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>


<p><br><br><br><a name="generateParenthesesBruteForce"></a></p>
<h2 id="Brute-Force-4"><a href="#Brute-Force-4" class="headerlink" title="Brute Force"></a>Brute Force</h2><p><strong>Intuition</strong> </p>
<p>We can generate all 2^(2n) sequences of <code>(</code> and <code>)</code> characters. Then we can check if each one is valid</p>
<br>

<p><strong>Algorithm</strong> </p>
<p>To generate all sequences, we use recursion. All sequences of length <code>n</code> is just <code>(</code> plus all sequences<br>of length <code>n-1</code>, and then <code>)</code> plus all sequences of length <code>n-1</code>. </p>
<p>To check whether a sequence is valid, we keep track of <code>balance</code>, the net number of opening brackets<br>minuts closing brackets. If it falls below zero at any time, or doesn’t end in zero, the sequence is<br>invalid - otherwise it is valid. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> List&lt;String&gt; <span class="title function_">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">		</span><br><span class="line">		List&lt;String&gt; combinations = <span class="keyword">new</span> <span class="title class_">ArrayList</span>(); </span><br><span class="line">		generateAll(<span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">2</span>*n], <span class="number">0</span>, combinations);</span><br><span class="line">		<span class="keyword">return</span> combinations;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">generateAll</span><span class="params">(<span class="type">char</span>[] current, <span class="type">int</span> pos, List&lt;String&gt; result)</span> &#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(pos == current.length) &#123;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span> (valid(current)) &#123;</span><br><span class="line">				result.add(<span class="keyword">new</span> <span class="title class_">String</span>(current));</span><br><span class="line">			&#125; </span><br><span class="line"></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			current[pos] = <span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">			generateAll(current, pos+<span class="number">1</span>, result);</span><br><span class="line">			current[pos] = <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">			generateAll(current, pos+<span class="number">1</span>, result);</span><br><span class="line">		</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">valid</span><span class="params">(<span class="type">char</span>[] current)</span> &#123;</span><br><span class="line">		</span><br><span class="line">		<span class="type">int</span> <span class="variable">balance</span> <span class="operator">=</span> <span class="number">0</span>; </span><br><span class="line">		<span class="keyword">for</span> (<span class="type">char</span> c : current) &#123;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span>(c == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">				balance++;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				balance--;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span>(balance &lt; <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> (balance == <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Complexity Analysis</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Time Complexity: 	O(2^2n * n)	For each of 2^2n sequences, we need to create an validate the </span><br><span class="line">					sequence, which takes O(n) work in the worst case </span><br><span class="line"></span><br><span class="line">Space Complexity: 	O(2^2n * n) 	Naively, every sequence could be valid, see Closure number for</span><br><span class="line">					a tighter asymptotic bound </span><br></pre></td></tr></table></figure>




<p><br><br><br><a name="generateParenthesesBacktracking"></a></p>
<h2 id="Backtracking-1"><a href="#Backtracking-1" class="headerlink" title="Backtracking"></a>Backtracking</h2><p><strong>Intuition and Algorithm</strong> </p>
<p>Instead of adding <code>(</code> or <code>)</code> every time as we do in the Brute Force algorithm, let’s only add them<br>when we know it will remain a valid sequence. We can do this by keeping track of the number of opening<br>and closing brackets we have placed so far. </p>
<p>We can start an opening bracket if we still have one (of <code>n</code>) left to place. And we can start a closing<br>bracket if it would not exceed the number of opening brackets </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> List&lt;String&gt; <span class="title function_">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">		</span><br><span class="line">		List&lt;String&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>(); </span><br><span class="line">		backtrack(ans, <span class="string">&quot;&quot;</span>, <span class="number">0</span>, <span class="number">0</span>, n);</span><br><span class="line">		<span class="keyword">return</span> ans; </span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(List&lt;String&gt; ans, String cur, <span class="type">int</span> open, <span class="type">int</span> close, <span class="type">int</span> max)</span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (cur.length() == max*<span class="number">2</span>) &#123;</span><br><span class="line">			ans.add(cur);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(open &lt; max) &#123;</span><br><span class="line">			backtrack(ans, cur + <span class="string">&quot;(&quot;</span>, open + <span class="number">1</span>, close, max);</span><br><span class="line">		&#125; </span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (close &lt; open) &#123;</span><br><span class="line">			backtrack(ans, cur + <span class="string">&quot;)&quot;</span>, open, close +<span class="number">1</span>, max);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Complexity Analysis</strong> </p>
<p>Our complexity analysis rests on understanding how many elements there are in <code>generateParenthesis(n)</code>.<br>This analysis is outside the scope of this article, but it turns out this is the nth Catalan number<br>1&#x2F;(n+1) (2n choose n), which is bounded asymptotically by 4^n&#x2F;(n* sqrt(n)). </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Time Complexity: 	O((4^n)/sqrt(n))	Each valid sequence has at most n steps during the </span><br><span class="line">						backtracking procedure</span><br><span class="line"></span><br><span class="line">Space Complexity: 	O((4^n)/sqrt(n))	As described above and using O(n) space to store the</span><br><span class="line">						sequence</span><br></pre></td></tr></table></figure>

<p>Another way to think about the runtime of backtracking algorithms on interviewers is O(b^d), where b is<br>the branching factor and d is the maximum depth of recursion. </p>
<p>Backtracking is characterized by a number of decisions b that can be made at each level of recursion.<br>If you visualize the recursion tree, this is the number of children each internal node has. You can<br>also think of b as standing for “base”, which helps us remember that b is the base of the exponential.</p>
<p>If we make b decisions at each level of recursion, and we expand the recursion tree to d levels (ie.<br>each path has a length of d), then we get b^d nodes. Since backtracking is exhaustive and must visit<br>each of these nodes, the runtime is O(b^d)</p>
<p><br><br><br><a name="generateParenthesesClosureNumber"></a></p>
<h2 id="Closure-Number"><a href="#Closure-Number" class="headerlink" title="Closure Number"></a>Closure Number</h2><p>To enumerate something, generally we would like to express it as a sum of disjoint subsets that are<br>easier to count. </p>
<p>Consider the <em>closure number</em> of a valid parentheses sequence <code>s</code>: the least <code>index &gt;= 0</code> so that<br>&#96;S[0], S[1], … , S[2 * index + 1] is valid. Clearly, every parentheses sequence has a unique closure<br>number. We can try to enumerate them individually. </p>
<p><br><br></p>
<p><strong>Algorithm</strong> </p>
<p>For each closure number c, we know the starting and ending brackets must be at index <code>0</code> and<br><code>2 * c + 1</code>. Then, the <code>2 * c</code> elements between must be a valid sequence, plus the rest of the elements<br>must be a valid sequence.</p>
<p>This is just some minor improvement to the backtracking solution using the fact that for all valid<br>solutions the first char is always ‘(‘ and the lat char is always ‘)’. We initialize the starting<br>string to ‘(‘ and set the recursion bottom condition to string reaching length of <code>2 * n - 1</code> - we know<br>that we need to append a bracket at the end. There will not be much of an improvement in the runtime<br>however. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> List&lt;String&gt; <span class="title function_">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">		List&lt;String&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>(); </span><br><span class="line">		<span class="keyword">if</span> (n==<span class="number">0</span>) &#123;</span><br><span class="line">			ans.add(<span class="string">&quot;&quot;</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> c=<span class="number">0</span>; c&lt;n; ++c)</span><br><span class="line">				<span class="keyword">for</span> (String left: generateParenthesis(c))</span><br><span class="line">					<span class="keyword">for</span> (String right: generateParenthesis(n-<span class="number">1</span>-c))</span><br><span class="line">						ans.add(<span class="string">&quot;(&quot;</span> + left + <span class="string">&quot;)&quot;</span> + right);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Complexity Analysis</strong> </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Time Complexity: 	O((4^n)/sqrt(n))</span><br><span class="line"></span><br><span class="line">Space Complexity: 	O((4^n)/sqrt(n))</span><br></pre></td></tr></table></figure>













<p><br><br><br></p>
<hr>
<p><a name="mergeKSortedLists"></a></p>
<h1 id="23-Merge-k-Sorted-Lists"><a href="#23-Merge-k-Sorted-Lists" class="headerlink" title="23-Merge k Sorted Lists"></a>23-Merge k Sorted Lists</h1><p>Merge k sorted linked lists and return it as one sorted list. Analyze and descibe its complexity: </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Example: </span><br><span class="line"></span><br><span class="line">Input: </span><br><span class="line">[</span><br><span class="line">	1 -&gt; 4 -&gt; 5,</span><br><span class="line">	1 -&gt; 3 -&gt; 4,</span><br><span class="line">	2 -&gt; 6</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">Output: 1 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 4 -&gt; 5 -&gt; 6</span><br></pre></td></tr></table></figure>





<p><br><br><br><a name="mergeKSortedLists"></a></p>
<h2 id="Brute-Force-5"><a href="#Brute-Force-5" class="headerlink" title="Brute Force"></a>Brute Force</h2><p><strong>Intuition and Algorithm</strong> </p>
<ul>
<li>Traverse all the linked lists and collect the values of the nodes into an array</li>
<li>Sort and iterate over this array to get the proper value of nodes</li>
<li>Create a new sorted linked list and extend it with the new nodes</li>
</ul>
<p>As for sorting you can refer to the Algorithms&#x2F;Data Structures CheatSheet for more about sorting algorithms. </p>
<p><br><br><br></p>
<hr>
<p><a name="lruCache"></a></p>
<h1 id="146-LRU-Cache"><a href="#146-LRU-Cache" class="headerlink" title="146-LRU Cache"></a>146-LRU Cache</h1><p>Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: <code>get</code> and <code>put</code>. </p>
<p><code>get(key)</code> - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return <code>-1</code> </p>
<p><code>put(key, value)</code> - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item. </p>
<p><strong>Follow up:</strong><br>Could both of these operations be done in <strong>O(1)</strong> time complexity?</p>
<p><strong>Example:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LRUCache cache = new LRUCache(2 /* capacity */);</span><br><span class="line"></span><br><span class="line">cache.put(1, 1);</span><br><span class="line">cache.put(2, 2);</span><br><span class="line">cache.get(1); 			// returns 1 </span><br><span class="line">cache.put(3, 3); 		// evicts key 2</span><br><span class="line">cache.get(2);			// returns -1 (not found)</span><br><span class="line">	</span><br></pre></td></tr></table></figure>


<h1 id="Index"><a href="#Index" class="headerlink" title="Index"></a>Index</h1><ol>
<li><a href="#lowest-common-ancestor">Lowest Common Ancestor</a></li>
<li><a href="#count-and-say">Count And Say</a></li>
<li><a href="#maximum-subarray">Maximum SubArray</a></li>
<li><a href="#plus-one">Plus One</a></li>
<li><a href="#sqrt-of-x">Sqrt of X</a></li>
<li><a href="#climbing-stairs">Climbing Stairs</a></li>
<li><a href="#remove-duplicates-from-sorted-list">Remove Duplicates from sorted list</a></li>
<li><a href="#same-tree">Same Tree</a></li>
<li><a href="#symmetric-tree">Symmetric Tree</a></li>
<li><a href="#max-depth-of-binary-tree">Max Depth of Binary Tree</a></li>
<li><a href="#convert-sorted-array-to-binary-search-tree">Convert Sorted Array to Binary Search Tree</a></li>
<li><a href="#balanced-binary-tree">Balanced Binary Tree</a></li>
<li><a href="#minimum-depth-of-binary-tree">Minimum Depth of Binary Tree</a></li>
<li><a href="#path-sum">Path Sum</a></li>
<li><a href="#pascal's-triangle">Pascal’s Triangle</a></li>
<li><a href="#valid-palindrome">Valid Palindrome</a></li>
<li><a href="#pascal's-triangle-ii">Pascal’s Triangle II</a></li>
<li><a href="#best-time-to-buy-and-sell-stock">Best Time to Buy and Sell Stock</a></li>
<li><a href="#best-time-to-buy-and-sell-stock-ii">Best Time to Buy and Sell Stock II</a></li>
<li><a href="#single-number">Single Number</a></li>
<li><a href="#linked-list-cycle">Linked List Cycle</a></li>
<li><a href="#min-stack">Min Stack</a></li>
<li><a href="#intersection-of-two-linked-lists">Intersection of Two Linked Lists</a></li>
<li><a href="#two-sum-ii---input-array-is-sorted">Two Sum II - Input array is sorted</a></li>
<li><a href="#excel-sheet-column-title">Excel Sheet Column Title</a></li>
<li><a href="#majority-element">Majority Element</a></li>
<li><a href="#excel-sheet-column-number">Excel Sheet Column Number</a></li>
<li><a href="#factorial-trailing-zeroes">Factorial Trailing Zeroes</a></li>
<li><a href="#combine-two-tables">Combine Two Tables</a></li>
<li><a href="#second-highest-salary">Second Highest Salary</a></li>
<li><a href="#employees-earning-more-than-their-managers">Employees Earning More Than Their Managers</a></li>
<li><a href="#duplicate-emails">Duplicate Emails</a></li>
<li><a href="#customers-who-never-order">Customers Who Never Order</a></li>
<li><a href="#rotate-array">Rotate Array</a></li>
<li><a href="#delete-duplicate-emails">Delete Duplicate Emails</a></li>
<li><a href="#rising-temperature">Rising Temperature</a></li>
<li><a href="#x-of-a-kind-in-a-deck-of-cards">X of a Kind in a Deck of Cards</a></li>
<li><a href="#reverse-integer">Reverse Integer</a></li>
<li><a href="#add-two-numbers">Add Two Numbers</a></li>
<li><a href="#longest-substring-without-repeating-characters">Longest Substring Without Repeating Characters</a></li>
<li><a href="#house-robber">House Robber</a></li>
<li><a href="#happy-number">Happy Number</a></li>
<li><a href="#remove-linked-list-elements">Remove Linked List Elements</a></li>
<li><a href="#count-primes">Count Primes</a></li>
<li><a href="#isomorphic-strings">Isomorphic Strings</a></li>
<li><a href="#reverse-linkedlist">Reverse LinkedList</a></li>
<li><a href="#contains-duplicate">Contains Duplicate</a></li>
<li><a href="#contains-duplicate-ii">Contains Duplicate II</a></li>
<li><a href="#implement-stack-using-queues">Implement Stack Using Queues</a></li>
<li><a href="#invert-binary-tree">Invert Binary Tree</a></li>
<li><a href="#fibonacci-number">Fibonacci Number</a></li>
<li><a href="#kth-largest-element">kth Largest Element</a></li>
<li><a href="#power-of-two">Power Of Two</a></li>
<li><a href="#valid-sudoku">Valid Sudoku</a></li>
<li><a href="#implement-queue-using-stack">Implement Queue Using Stack</a></li>
<li><a href="#palindrome-linkedlist">Palindrome LinkedList</a></li>
<li><a href="#delete-node-in-a-linked-list">Delete Node in a Linked List</a></li>
<li><a href="#is-anagram">Is Anagram</a></li>
<li><a href="#binary-tree-paths">Binary Tree Paths</a></li>
<li><a href="#add-digits">Add Digits</a></li>
<li><a href="#largest-perimeter-triangle">Largest Perimeter Triangle</a></li>
<li><a href="#ugly-number">Ugly Number</a></li>
<li><a href="#missing-number">Missing Number</a></li>
<li><a href="#is-bad-version">Is Bad Version</a></li>
<li><a href="#move-zeroes">Move Zeroes</a></li>
<li><a href="#word-pattern">Word Pattern</a></li>
<li><a href="#can-win-nim">Can Win Nim</a></li>
<li><a href="#power-of-three">Power Of Three</a></li>
<li><a href="#power-of-four">Power of Four</a></li>
<li><a href="#reverse-string">Reverse String</a></li>
<li><a href="#implement-strstr()">Implement strStr()</a></li>
<li><a href="#reverse-vowels-of-a-string">Reverse Vowels of a String</a></li>
<li><a href="#intersection-of-two-arrays">Intersection of two arrays</a></li>
<li><a href="#is-perfect-square">Is Perfect Square</a></li>
<li><a href="#sum-of-two-integers">Sum of Two Integers</a></li>
<li><a href="#guess-number-higher-or-lower">Guess Number Higher or Lower</a></li>
<li><a href="#ransom-note">Ransom Note</a></li>
<li><a href="#first-unique-character-in-a-string">First Unique Character in a String</a></li>
<li><a href="#find-the-difference">Find the Difference</a></li>
<li><a href="#nth-digit">Nth Digit</a></li>
<li><a href="#sum-of-left-leaves">Sum of Left Leaves</a></li>
<li><a href="#longest-palindrome">Longest Palindrome</a></li>
<li><a href="#fizz-buzz">Fizz Buzz</a></li>
<li><a href="#third-maximum-number">Third maximum Number</a></li>
<li><a href="#add-two-strings">Add Two Strings</a></li>
<li><a href="#construct-quad-tree">Construct Quad Tree</a></li>
<li><a href="#n-ary-tree-level-order-traversal">N-ary Tree Level Order Traversal</a></li>
<li><a href="#number-of-segments-in-a-string">Number of Segments in a String</a></li>
<li><a href="#binary-tree-level-order-traversal">Binary Tree Level Order Traversal</a></li>
<li><a href="#path-sum-iii">Path Sum III</a></li>
<li><a href="#find-all-anagrams-in-a-string">Find All Anagrams in a String</a></li>
<li><a href="#arranging-coins">Arranging Coins</a></li>
<li><a href="#hamming-distance">Hamming Distance</a></li>
<li><a href="#string-compression">String Compression</a></li>
<li><a href="#number-of-boomerangs">Number of Boomerangs</a></li>
<li><a href="#find-all-numbers-disappeared-in-an-array">Find All Numbers Disappeared in an Array</a></li>
<li><a href="#assign-cookies">Assign Cookies</a></li>
<li><a href="#poor-pigs">Poor Pigs</a></li>
<li><a href="#find-pivot-index">Find Pivot Index</a></li>
<li><a href="#squares-of-a-sorted-array">Squares of a Sorted Array</a></li>
<li><a href="#repeated-substring-pattern">Repeated Substring Pattern</a></li>
<li><a href="#island-perimeter">Island Perimeter</a></li>
<li><a href="#number-complement">Number Complement</a></li>
<li><a href="#binary-watch">Binary Watch</a></li>
<li><a href="#minimum-moves-to-equal-array-elements">Minimum Moves to Equal Array Elements</a></li>
<li><a href="#license-key-formatting">License Key Formatting</a></li>
<li><a href="#max-consecutive-ones">Max Consecutive Ones</a></li>
<li><a href="#permutations">Permutations</a></li>
<li><a href="#construct-the-rectangle">Construct the Rectangle</a></li>
<li><a href="#merge-intervals">Merge Intervals</a></li>
<li><a href="#merged-sorted-lists">Merged sorted lists</a></li>
<li><a href="#next-greater-element-i">Next Greater Element I</a></li>
<li><a href="#string-without-aaa-or-bbb">String Without AAA or BBB</a></li>
<li><a href="#keyboard-row">Keyboard Row</a></li>
<li><a href="#find-mode-in-binary-search-tree">Find Mode in Binary Search Tree</a></li>
<li><a href="#base-7">Base 7</a></li>
<li><a href="#relative-ranks">Relative Ranks</a></li>
<li><a href="#perfect-number">Perfect Number</a></li>
<li><a href="#detect-capital">Detect Capital</a></li>
<li><a href="#longest-uncommon-subsequence-i">Longest Uncommon Subsequence I</a></li>
<li><a href="#course-schedule-ii">Course Schedule II</a></li>
<li><a href="#letter-combinations-of-a-phone-number">Letter Combinations of a Phone Number</a></li>
<li><a href="#sudoku-solver">Sudoku Solver</a></li>
<li><a href="#bulls-and-cows">Bulls and Cows</a></li>
<li><a href="#n-queens-1">N-Queens 1</a></li>
<li><a href="#k-diff-pairs-in-an-array">K-diff pairs in an Array</a></li>
<li><a href="#is-subsequence">Is Subsequence</a></li>
<li><a href="#minimum-absolute-difference-in-bst">Minimum Absolute Difference in BST</a></li>
<li><a href="#bst-tree-to-greater-tree">BST Tree to Greater Tree</a></li>
<li><a href="#student-attendance-record-I">Student Attendance Record I</a></li>
<li><a href="#reverse-words-in-string-iii">Reverse Words in String III</a></li>
<li><a href="#quad-tree-intersection">Quad Tree Intersection</a></li>
<li><a href="#long-pressed-name">Long Pressed Name</a></li>
<li><a href="#binary-tree-zigzag-level-order-traversal">Binary Tree Zigag Level Order Traversal</a></li>
<li><a href="#array-partition-I">Array Partition I</a></li>
<li><a href="#reshape-the-matrix">Reshape the matrix</a></li>
<li><a href="#swap-nodes-in-pairs">Swap Nodes in Pairs</a></li>
<li><a href="#generate-parentheses">Generate Parentheses</a></li>
<li><a href="#distribute-candies">Distribute Candies</a></li>
<li><a href="#maximum-subproduct-subarray">Maximum Subproduct Subarray</a></li>
<li><a href="#binary-tree-right-side-view">Binary Tree Right Side View</a></li>
<li><a href="#find-minimum-in-rotated-sorted-array">Find Minimum in Rotated Sorted Array</a></li>
<li><a href="#binary-search-tree-iterator">Binary Search Tree Iterator</a></li>
<li><a href="#find-peak-element">Find Peak Element</a></li>
<li><a href="#next-permutation">Next Permutation</a></li>
<li><a href="#search-in-rotated-sorted-array">Search in Rotated Sorted Array</a></li>
<li><a href="#transpose-matrix">Transpose Matrix</a></li>
<li><a href="#merge-k-sorted-lists">Merge K sorted lists</a></li>
</ol>
<hr>
<hr>
<h3 id="Lowest-Common-Ancestor"><a href="#Lowest-Common-Ancestor" class="headerlink" title="Lowest Common Ancestor"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/">Lowest Common Ancestor</a><a name="lowest-common-ancestor"></a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">current</span> <span class="operator">=</span> root;</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (p.val &lt; current.val &amp;&amp; q.val &lt; current.val)		<span class="comment">// Both located in left side.</span></span><br><span class="line">            current = current.left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p.val &gt; current.val &amp;&amp; q.val &gt; current.val)	<span class="comment">// Both located in right side</span></span><br><span class="line">            current = current.right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> current;		<span class="comment">// Seperate branches, therefore current is lca.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Count-And-Say"><a href="#Count-And-Say" class="headerlink" title="Count And Say"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/count-and-say/">Count And Say</a><a name="count-and-say"></a></h3><p>The updated version runs in 2ms and passes 96.85% submissions.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">countAndSay</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="string">&quot;1&quot;</span>;		<span class="comment">// initial result</span></span><br><span class="line">    StringBuilder temp;			<span class="comment">// to create intermediate strings efficiently.</span></span><br><span class="line">    <span class="type">int</span> len;					<span class="comment">// length of the result string.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; ++i)&#123;	<span class="comment">// We need to iterate n-1 times, because 1st result is 1</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">startIndex</span> <span class="operator">=</span> <span class="number">0</span>;			<span class="comment">// we will look at each index of result</span></span><br><span class="line">        temp = <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();	<span class="comment">// and store freq,char in the builder</span></span><br><span class="line">        len = result.length();</span><br><span class="line">        <span class="keyword">while</span> (startIndex &lt; len)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> result.charAt(startIndex++);	<span class="comment">// get the char at startIndex, and increment it, because we also want to look at the next character</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;					<span class="comment">// intialize it&#x27;s count to 1, we just saw it.</span></span><br><span class="line">            <span class="keyword">while</span> (startIndex &lt; len &amp;&amp; ch == result.charAt(startIndex))&#123;</span><br><span class="line">                count++;			<span class="comment">// If next also matches, increment count and startIndex</span></span><br><span class="line">                startIndex++;</span><br><span class="line">            &#125;</span><br><span class="line">            temp.append(count).append(ch);	<span class="comment">// No more match, Add the freq and the char</span></span><br><span class="line">        &#125;</span><br><span class="line">        result = temp.toString();	<span class="comment">// Update result to generate the next cound-and-say</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Maximum-SubArray"><a href="#Maximum-SubArray" class="headerlink" title="Maximum SubArray"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/maximum-subarray/">Maximum SubArray</a><a name="maximum-subarray"></a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">localMax</span> <span class="operator">=</span> nums[<span class="number">0</span>];		<span class="comment">// keeps track of max sum between the previous and current</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">globalMax</span> <span class="operator">=</span> nums[<span class="number">0</span>];	<span class="comment">// keeps track of global max sum.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    The idea is as follows:</span></span><br><span class="line"><span class="comment">    If the current element is greater than the previous local max, then we found an element that is a better option then before.</span></span><br><span class="line"><span class="comment">    Then, if that localmax changed and is greater than our global max, update our global max.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">        localMax = Math.max(localMax + nums[i], nums[i]);</span><br><span class="line">        globalMax = Math.max(localMax, globalMax);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> globalMax;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Plus-One"><a href="#Plus-One" class="headerlink" title="Plus One"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/plus-one/">Plus One</a><a name="plus-one"></a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] plusOne(<span class="type">int</span>[] digits)</span><br><span class="line">&#123;</span><br><span class="line">    digits[digits.length-<span class="number">1</span>]++;			<span class="comment">// Add one to the last place.</span></span><br><span class="line">    <span class="keyword">if</span> (digits[digits.length-<span class="number">1</span>] == <span class="number">10</span>)	<span class="comment">// If it became 10,</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> digits.length-<span class="number">1</span>; i &gt; <span class="number">0</span>; i--)	<span class="comment">// Then add one to its previous place</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (digits[i] == <span class="number">10</span>)&#123;	<span class="comment">// If that also results in 10, keep propogating that 1</span></span><br><span class="line">                digits[i-<span class="number">1</span>]++;		<span class="comment">// upstream</span></span><br><span class="line">                digits[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (digits[<span class="number">0</span>] == <span class="number">10</span>)&#123;	<span class="comment">// If the index 0 is 10, then the number is a multiple of 10.</span></span><br><span class="line">            digits = <span class="keyword">new</span> <span class="title class_">int</span>[digits.length+<span class="number">1</span>];</span><br><span class="line">            digits[<span class="number">0</span>] = <span class="number">1</span>;		<span class="comment">// So increase length by 1 and set index 0 to 1.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> digits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Sqrt-of-X"><a href="#Sqrt-of-X" class="headerlink" title="Sqrt of X"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/sqrtx/">Sqrt of X</a><a name="sqrt-of-x"></a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">mySqrt</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">x1</span> <span class="operator">=</span> <span class="number">10</span> - (<span class="number">100</span> - x)/<span class="number">20</span>;		<span class="comment">// Using Newton&#x27;s method of computing square roots.</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">done</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (!done)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">x2</span> <span class="operator">=</span> x1 - (x1*x1 - x)/(<span class="number">2</span>*x1);</span><br><span class="line">        <span class="keyword">if</span> (x2 == x1)</span><br><span class="line">            done = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            x1 = x2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>)x1-<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Climbing-Stairs"><a href="#Climbing-Stairs" class="headerlink" title="Climbing Stairs"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/climbing-stairs/">Climbing Stairs</a><a name="climbing-stairs"></a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">4</span>)		<span class="comment">// I chose n &lt; 4 because climbStairs(0 &lt;= n &lt;= 3) = n</span></span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        dp[i] = i;</span><br><span class="line">    <span class="comment">//return naiveDP(n, dp);</span></span><br><span class="line">    <span class="keyword">return</span> efficientDP(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">naiveDP</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> dp[])</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dp[n] != <span class="number">0</span>)		<span class="comment">// If already computed, return it.</span></span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    <span class="type">int</span> <span class="variable">ways</span> <span class="operator">=</span>  naiveDP(n-<span class="number">1</span>, dp) + naiveDP(n-<span class="number">2</span>, dp);	<span class="comment">// Just like Fibonacci.</span></span><br><span class="line">    dp[n] = ways;		<span class="comment">// Save it.</span></span><br><span class="line">    <span class="keyword">return</span> ways;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">efficientDP</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">4</span>)</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];		<span class="comment">// Initialize dp of length n+1 to store n&#x27;th way.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        dp[i] = i;					<span class="comment">// climbStairs(0 &lt;= n &lt;= 3) = n</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>; i &lt;= n; i++)	<span class="comment">// climbStairs(n) = climbStairs(n-1) + climbstairs(n-2);</span></span><br><span class="line">        dp[i] = dp[i-<span class="number">1</span>] + dp[i-<span class="number">2</span>];  <span class="comment">// So fetch those values from the dp array.</span></span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Remove-Duplicates-from-sorted-list"><a href="#Remove-Duplicates-from-sorted-list" class="headerlink" title="Remove Duplicates from sorted list"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/remove-duplicates-from-sorted-list/">Remove Duplicates from sorted list</a><a name="remove duplicates from sorted list"></a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">deleteDuplicates</span><span class="params">(ListNode head)</span>&#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">current</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="comment">// while we haven&#x27;t reached the tail</span></span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">null</span> &amp;&amp; current.next != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// if current&#x27;s next is the same as current, skip and update its next</span></span><br><span class="line">        <span class="keyword">while</span> (current.next != <span class="literal">null</span> &amp;&amp; current.val == current.next.val)</span><br><span class="line">            current.next = current.next.next;</span><br><span class="line">        current = current.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Same-Tree"><a href="#Same-Tree" class="headerlink" title="Same Tree"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/same-tree/">Same Tree</a><a name="same-tree"></a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">null</span> &amp;&amp; q == <span class="literal">null</span>)		<span class="comment">// Two empty trees</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// If one of the node is null, the two trees can&#x27;t be equal.</span></span><br><span class="line">    <span class="keyword">if</span> ((p == <span class="literal">null</span> &amp;&amp; q != <span class="literal">null</span>) || (p != <span class="literal">null</span> &amp;&amp; q == <span class="literal">null</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// If the values in the two nodes are same, compare its&#x27;s left and right sub-tree.</span></span><br><span class="line">    <span class="keyword">if</span> (p.val == q.val)</span><br><span class="line">        <span class="keyword">return</span> isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;		<span class="comment">// If nothing worked out, they can&#x27;t be same.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Symmetric-Tree"><a href="#Symmetric-Tree" class="headerlink" title="Symmetric Tree"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/symmetric-tree/">Symmetric Tree</a><a name="symmetric-tree"></a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> isSymmetricIterative(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetricIterative</span><span class="params">(TreeNode root)</span></span><br><span class="line">&#123;</span><br><span class="line">    Queue&lt;TreeNode&gt; track = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    track.add(root);		<span class="comment">// Add the root twice so we can compare its left and right</span></span><br><span class="line">    track.add(root);</span><br><span class="line">    <span class="keyword">while</span> (!track.isEmpty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">x</span> <span class="operator">=</span> track.poll();		<span class="comment">// Remove 2 nodes</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">y</span> <span class="operator">=</span> track.poll();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (x == <span class="literal">null</span> &amp;&amp; y == <span class="literal">null</span>)		<span class="comment">// If they are both null, skip it.</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="literal">null</span> || y == <span class="literal">null</span> || x.val != y.val)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;				<span class="comment">// If values don&#x27;t match or one is null</span></span><br><span class="line">        track.add(x.left);		<span class="comment">// Otherwise add them in this order -&gt; LRRL</span></span><br><span class="line">        track.add(y.right);		<span class="comment">// because we need to compare left most with the</span></span><br><span class="line">        track.add(x.right);		<span class="comment">// right most, then inner left with inner right.</span></span><br><span class="line">        track.add(y.left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;		<span class="comment">// Everything&#x27;s all right, so they must be symmetric.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetricRecursive</span><span class="params">(TreeNode root)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> helperRecursive(root, root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">helperRecursive</span><span class="params">(TreeNode x, TreeNode y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="literal">null</span> || y == <span class="literal">null</span>)		<span class="comment">// Base Case: Both or one is null, so true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> (x.val == y.val &amp;&amp; helperRecursive(x.left, y.right) &amp;&amp; helperRecursive(x.right, y.left));</span><br><span class="line">    <span class="comment">// Check if values match and 1.left matches with the 2.right and 1.right matches with 2.left</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Max-Depth-of-Binary-Tree"><a href="#Max-Depth-of-Binary-Tree" class="headerlink" title="Max Depth of Binary Tree"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/maximum-depth-of-binary-tree/">Max Depth of Binary Tree</a><a name="max depth of binary tree"></a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">If root is null, height is 0 else add 1 and find if the left or the right has a greater depth.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> root == <span class="literal">null</span> ? <span class="number">0</span> : <span class="number">1</span> + Math.max(maxDepth(root.left), maxDepth(root.right));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Convert-Sorted-Array-to-Binary-Search-Tree"><a href="#Convert-Sorted-Array-to-Binary-Search-Tree" class="headerlink" title="Convert Sorted Array to Binary Search Tree"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/">Convert Sorted Array to Binary Search Tree</a><a name="convert-sorted-array-to-binary-search-tree"></a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">sortedArrayToBST</span><span class="params">(<span class="type">int</span>[] nums)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> aux(nums, <span class="number">0</span>, nums.length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> TreeNode <span class="title function_">aux</span><span class="params">(<span class="type">int</span>[] n, <span class="type">int</span> left, <span class="type">int</span> right)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt; right)					<span class="comment">// Either empty, or return a null node</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left+right+<span class="number">1</span>)/<span class="number">2</span>;			<span class="comment">// Create a node with the middle value</span></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(n[mid]);</span><br><span class="line">    root.left = aux(n, left, mid-<span class="number">1</span>);	<span class="comment">// Compute the left (which is the mid in left side)</span></span><br><span class="line">    root.right = aux(n, mid+<span class="number">1</span>, right);	<span class="comment">// Compute the right (which is the mid in right side)</span></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Balanced-Binary-Tree"><a href="#Balanced-Binary-Tree" class="headerlink" title="Balanced Binary Tree"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/balanced-binary-tree/">Balanced Binary Tree</a><a name="balanced-binary-tree"></a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBalanced</span><span class="params">(TreeNode root)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> isBalancedBottomUp(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBalancedTopDown</span><span class="params">(TreeNode root)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// if difference between root&#x27;s left and right is &gt; 1, they&#x27;re not balanced</span></span><br><span class="line">    <span class="keyword">if</span> (Math.abs((getHeight(root.left) - getHeight(root.right))) &gt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// otherwise, we need to check if the left and right subtree are also balanced.</span></span><br><span class="line">    <span class="keyword">return</span> isBalanced(root.left) &amp;&amp; isBalanced(root.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getHeight</span><span class="params">(TreeNode node)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Standard height of a binary tree calculator</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + Math.max(getHeight(node.left), getHeight(node.right));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBalancedBottomUp</span><span class="params">(TreeNode root)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> getHeight2(root) != -<span class="number">1</span>;	<span class="comment">// -1 means not balanced.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getHeight2</span><span class="params">(TreeNode node)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">lHeight</span> <span class="operator">=</span> getHeight2(node.left);	<span class="comment">// Get the height of left and right tree</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">rHeight</span> <span class="operator">=</span> getHeight2(node.right);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If at any point there was a height difference of more than 1 or previous node&#x27;s leftheight || rightheight returned -1, return -1 to let the next node know there was an imbalance.</span></span><br><span class="line">    <span class="keyword">if</span> ((Math.abs(lHeight-rHeight) &gt; <span class="number">1</span>) || lHeight == -<span class="number">1</span> || rHeight == -<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + Math.max(lHeight, rHeight); <span class="comment">// Else carry on with the normal procedure</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="Minimum-Depth-of-Binary-Tree"><a href="#Minimum-Depth-of-Binary-Tree" class="headerlink" title="Minimum Depth of Binary Tree"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/minimum-depth-of-binary-tree/">Minimum Depth of Binary Tree</a><a name="minimum-depth-of-binary-tree"></a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="comment">// Base case</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Left is null, find minheight from right side</span></span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">1</span> + minDepth(root.right);</span><br><span class="line">    <span class="comment">// Right is null, find minheight from left side</span></span><br><span class="line">    <span class="keyword">if</span> (root.right == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">1</span> + minDepth(root.left);</span><br><span class="line">    <span class="comment">// Else, both are not null, so compute min height from the two sides.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + Math.min(minDepth(root.left), minDepth(root.right));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Path-Sum"><a href="#Path-Sum" class="headerlink" title="Path Sum"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/path-sum/">Path Sum</a><a name="path-sum"></a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPathSum</span><span class="params">(TreeNode root, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;	<span class="comment">// No sum exist</span></span><br><span class="line">    sum -= root.val;	<span class="comment">// Sum decreases</span></span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>)	<span class="comment">// If we are at a leaf</span></span><br><span class="line">        <span class="keyword">return</span> sum == <span class="number">0</span>;	<span class="comment">// Check if the sum is 0.</span></span><br><span class="line">    <span class="keyword">return</span> hasPathSum(root.left, sum) || hasPathSum(root.right, sum);</span><br><span class="line">    <span class="comment">// Otherwise look if you can make sum = 0 by exploring the left or right side.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Pascal’s-Triangle"><a href="#Pascal’s-Triangle" class="headerlink" title="Pascal’s Triangle"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/pascals-triangle/">Pascal’s Triangle</a><a name="pascal's-triangle"></a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">generate</span><span class="params">(<span class="type">int</span> numRows)</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; pt = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numRows; i++)	<span class="comment">// Need to add all n rows</span></span><br><span class="line">    &#123;</span><br><span class="line">        List&lt;Integer&gt; temp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();		<span class="comment">// temp list to store values</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">0</span> || i == j)		<span class="comment">// First and last values are always 1.</span></span><br><span class="line">                temp.add(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span>	<span class="comment">// Else, get the previous row and surrounding two values and add them</span></span><br><span class="line">                temp.add(pt.get(i-<span class="number">1</span>).get(j-<span class="number">1</span>) + pt.get(i-<span class="number">1</span>).get(j));</span><br><span class="line">        &#125;</span><br><span class="line">        pt.add(temp);		<span class="comment">// Add it to pt.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Valid-Palindrome"><a href="#Valid-Palindrome" class="headerlink" title="Valid Palindrome"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/valid-palindrome/">Valid Palindrome</a><a name="valid-palindrome"></a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s.length() &gt; <span class="number">0</span>)&#123;		<span class="comment">// Only do this is s is not empty</span></span><br><span class="line">        s = s.toLowerCase();	<span class="comment">// Convert it to lowercase</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;			<span class="comment">// Initialize left and right pointers</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> s.length()-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)	<span class="comment">// continue while we haven&#x27;t hit the middle of the string</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// If char at left is not a letter or a number, skip it.</span></span><br><span class="line">            <span class="keyword">if</span> (!Character.isLetter(s.charAt(left)) &amp;&amp; !Character.isDigit(s.charAt(left)))</span><br><span class="line">                left++;</span><br><span class="line">            <span class="comment">// Same with char at right.</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!Character.isLetter(s.charAt(right)) &amp;&amp; !Character.isDigit(s.charAt(right)))</span><br><span class="line">                right--;</span><br><span class="line">            <span class="comment">//Char&#x27;s are now alphanumeric.</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(left) != s.charAt(right))	<span class="comment">// If they don&#x27;t match</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;	<span class="comment">// return false</span></span><br><span class="line">            <span class="keyword">else</span>	<span class="comment">// They matched, so try to match the inner string</span></span><br><span class="line">            &#123;</span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;	<span class="comment">// No mismatch found, return true.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Pascal’s-Triangle-II"><a href="#Pascal’s-Triangle-II" class="headerlink" title="Pascal’s Triangle II"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/pascals-triangle-ii/">Pascal’s Triangle II</a><a name="pascal's-triangle-ii"></a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">getRow</span><span class="params">(<span class="type">int</span> rowIndex)</span></span><br><span class="line">&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; row = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    row.add(<span class="number">1</span>);	<span class="comment">// First is always 1.</span></span><br><span class="line">	<span class="comment">// Using the nth row formula to compute the coeeficients. You can google &quot;nth row Pascal&quot;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; rowIndex; i++)</span><br><span class="line">        row.add((<span class="type">int</span>)(<span class="number">1.0</span>*row.get(i)*(rowIndex-i)/(i+<span class="number">1</span>)));</span><br><span class="line">    <span class="keyword">return</span> row;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Best-Time-to-Buy-and-Sell-Stock"><a href="#Best-Time-to-Buy-and-Sell-Stock" class="headerlink" title="Best Time to Buy and Sell Stock"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/">Best Time to Buy and Sell Stock</a><a name="best-time-to-buy-and-sell-stock"></a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">The general idea is that if the price you are looking at right now in the array minus the minimum observed so far is greater than the maximum profit you recorded, update the max.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (prices.length == <span class="number">0</span>)		<span class="comment">// Empty array</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> prices[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; prices.length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (prices[i] &lt; min)</span><br><span class="line">            min = prices[i];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (prices[i] - min &gt; max)</span><br><span class="line">            max = prices[i]-min;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Best-Time-to-Buy-and-Sell-Stock-II"><a href="#Best-Time-to-Buy-and-Sell-Stock-II" class="headerlink" title="Best Time to Buy and Sell Stock II"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/">Best Time to Buy and Sell Stock II</a><a name="best-time-to-buy-and-sell-stock-ii"></a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">The general idea is that the moment you observe a valley and consecutive peak, make the trade by buying the stock on the valley day and selling it on the peak day.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; prices.length-<span class="number">1</span>; i++)</span><br><span class="line">        <span class="keyword">if</span> (prices[i+<span class="number">1</span>] &gt; prices[i])</span><br><span class="line">            sum += (prices[i+<span class="number">1</span>] - prices[i]);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Single-Number"><a href="#Single-Number" class="headerlink" title="Single Number"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/single-number/">Single Number</a><a name="single-number"></a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">The general idea is that XOR of two same numbers returns 0 and XOR with 0 returns the same number. So if there is only one element that doesn&#x27;t have a pair, all the remaining will XOR with themselves at one point and give 0 but not the singleton element.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">singleNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++)</span><br><span class="line">        num ^= nums[i];</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Linked-List-Cycle"><a href="#Linked-List-Cycle" class="headerlink" title="Linked List Cycle"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/linked-list-cycle/">Linked List Cycle</a><a name="linked-list-cycle"></a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Using the slow-fast runner technique.</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">first</span> <span class="operator">=</span> head;	<span class="comment">// Slow runner</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">second</span> <span class="operator">=</span> first.next;		<span class="comment">// Fast Runner</span></span><br><span class="line">    <span class="comment">// while second is not at the end or it isn&#x27;t the tail</span></span><br><span class="line">    <span class="keyword">while</span> (second != <span class="literal">null</span> &amp;&amp; second.next != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (second == first)	<span class="comment">// If fast made a full loop and met up with slow</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;		<span class="comment">// We got a cycle</span></span><br><span class="line">        first = first.next;		<span class="comment">// Slow moves one step</span></span><br><span class="line">        second = second.next.next;	<span class="comment">// Second advances two.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;		<span class="comment">// We don&#x27;t have a cycle</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Min-Stack"><a href="#Min-Stack" class="headerlink" title="Min Stack"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/min-stack/">Min Stack</a><a name="min-stack"></a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> min;</span><br><span class="line">    Stack&lt;Integer&gt; stack;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MinStack</span><span class="params">()</span> &#123;</span><br><span class="line">        min = Integer.MAX_VALUE;</span><br><span class="line">        stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        stack.push(x);		<span class="comment">// Push the value</span></span><br><span class="line">        <span class="keyword">if</span> (x &lt; min)		<span class="comment">// If that value is minimum than we have, update min</span></span><br><span class="line">            min = x;</span><br><span class="line">        stack.push(min);	<span class="comment">// Push the minimum on top of the stack for constant time</span></span><br><span class="line">    &#125;						<span class="comment">// minimum retrieval.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        stack.pop();		<span class="comment">// Pop the minimum.</span></span><br><span class="line">        stack.pop();		<span class="comment">// Pop the actual element meant to be popped</span></span><br><span class="line">        <span class="keyword">if</span> (stack.isEmpty())	<span class="comment">// If empty, min is Max int value</span></span><br><span class="line">            min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            min = stack.peek();	<span class="comment">// Otherwise, min would be the top most element since we</span></span><br><span class="line">    &#125;							<span class="comment">// always push the minimum on top of any element we push.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stack.elementAt(stack.size()-<span class="number">2</span>);	<span class="comment">// Top element is actually at second last</span></span><br><span class="line">    &#125;				<span class="comment">// index since the last element is the minimum.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMin</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Intersection-of-Two-Linked-Lists"><a href="#Intersection-of-Two-Linked-Lists" class="headerlink" title="Intersection of Two Linked Lists"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/intersection-of-two-linked-lists/">Intersection of Two Linked Lists</a><a name="intersection-of-two-linked-lists"></a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">The general idea is that if you are done traversing any of the lists, make it&#x27;s pointer point to the head of the other list and start iterating. The reasoning is that the second time they iterate, they will have traversed exactly the same distance (it&#x27;s length plus the other list&#x27;s head to the intersecting node) and will meet at the intersecting node.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pA</span> <span class="operator">=</span> headA;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pB</span> <span class="operator">=</span> headB;</span><br><span class="line">    <span class="keyword">while</span> (pA != pB)&#123;</span><br><span class="line">        pA = pA == <span class="literal">null</span> ? headB : pA.next;</span><br><span class="line">        pB = pB == <span class="literal">null</span> ? headA : pB.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Two-Sum-II-Input-array-is-sorted"><a href="#Two-Sum-II-Input-array-is-sorted" class="headerlink" title="Two Sum II - Input array is sorted"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/">Two Sum II - Input array is sorted</a><a name="two-sum-ii---input-array-is-sorted"></a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] numbers, <span class="type">int</span> target) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = numbers.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right)	<span class="comment">// Narrow down the window from both sides until they add up.</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> numbers[left] + numbers[right];</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; target)	<span class="comment">// We overshot, so decrease the window from right</span></span><br><span class="line">            right--;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target)	<span class="comment">// Undershot, increase windows from left so next sum is more</span></span><br><span class="line">            left++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;				<span class="comment">// Found the two numbers</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;left+<span class="number">1</span>, right+<span class="number">1</span>&#125;;	<span class="comment">// +1 because LeetCode followed 1-n indexing.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Excel-Sheet-Column-Title"><a href="#Excel-Sheet-Column-Title" class="headerlink" title="Excel Sheet Column Title"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/excel-sheet-column-title/">Excel Sheet Column Title</a><a name="excel-sheet-column-title"></a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">convertToTitle</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 1 is A and 26 is Z, so n-1 to change it to 0-25 scheme. Then, % 26 to find how</span></span><br><span class="line"><span class="comment">        much it is off on a full alphabet cycle, add 65 (ASCII for A) and convert it to char</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        res = String.valueOf((<span class="type">char</span>)(<span class="number">65</span>+((n-<span class="number">1</span>)%<span class="number">26</span>))) + res;</span><br><span class="line">        n = (n-<span class="number">1</span>) / <span class="number">26</span>;	<span class="comment">// Subtract 1 and divide by 26 to get prepare for the next character</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Majority-Element"><a href="#Majority-Element" class="headerlink" title="Majority Element"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/majority-element/">Majority Element</a><a name="majority-element"></a></h3><p>Uses <a target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/majority-element/">Moore’s Algorithm</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This is the implementation of Moore&#x27;s Algorithm for O(n) complexity.</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">majorityElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">major</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (major == nums[i])</span><br><span class="line">            count++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            count--;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>)&#123;</span><br><span class="line">            major = nums[i];</span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> major;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Excel-Sheet-Column-Number"><a href="#Excel-Sheet-Column-Number" class="headerlink" title="Excel Sheet Column Number"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/excel-sheet-column-number/">Excel Sheet Column Number</a><a name="excel-sheet-column-number"></a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Start from the end of String s, compute the ASCII for the char, +1 for 1-26 Alphabet-Scheme (hence -64 instead of -65) and multiply it to 26^&#123;distance from the end of the string&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">titleToNumber</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> s.length()-<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> length; i &gt; -<span class="number">1</span>; i--)</span><br><span class="line">        total += (<span class="type">int</span>)(s.charAt(i)-<span class="number">64</span>) * Math.pow(<span class="number">26</span>,length-i);</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Factorial-Trailing-Zeroes"><a href="#Factorial-Trailing-Zeroes" class="headerlink" title="Factorial Trailing Zeroes"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/factorial-trailing-zeroes/">Factorial Trailing Zeroes</a><a name="factorial-trailing-zeroes"></a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">The general idea is that every factorial that has 5 as a multiple also has 2 to multiply to 10. So if we can count the number of times we can divide n by 5, should gives us the number of trailing zeroes. O(log(n) base 5) complexity.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trailingZeroes</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        res += n / <span class="number">5</span>;</span><br><span class="line">        n /= <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Combine-Two-Tables"><a href="#Combine-Two-Tables" class="headerlink" title="Combine Two Tables"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/combine-two-tables/">Combine Two Tables</a><a name="combine-two-tables"></a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select FirstName, LastName, City, State</span><br><span class="line">from Person left join Address on Address.personId = person.personId;</span><br></pre></td></tr></table></figure>



<h3 id="Second-Highest-Salary"><a href="#Second-Highest-Salary" class="headerlink" title="Second Highest Salary"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/second-highest-salary/">Second Highest Salary</a><a name="second-highest-salary"></a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select max(salary) as SecondHighestSalary</span><br><span class="line">from Employee</span><br><span class="line">where salary not in (select max(salary) from employee);</span><br></pre></td></tr></table></figure>



<h3 id="Employees-Earning-More-Than-Their-Managers"><a href="#Employees-Earning-More-Than-Their-Managers" class="headerlink" title="Employees Earning More Than Their Managers"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/employees-earning-more-than-their-managers/">Employees Earning More Than Their Managers</a><a name="employees-earning-more-than-their-managers"></a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select emp.Name as Employee</span><br><span class="line">from Employee emp, Employee man</span><br><span class="line">where emp.managerId = man.Id and emp.salary &gt; man.salary;</span><br></pre></td></tr></table></figure>



<h3 id="Duplicate-Emails"><a href="#Duplicate-Emails" class="headerlink" title="Duplicate Emails"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/duplicate-emails/">Duplicate Emails</a><a name="duplicate-emails"></a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select email</span><br><span class="line">from person</span><br><span class="line">group by (email)</span><br><span class="line">having count(*) &gt; 1;</span><br></pre></td></tr></table></figure>



<h3 id="Customers-Who-Never-Order"><a href="#Customers-Who-Never-Order" class="headerlink" title="Customers Who Never Order"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/customers-who-never-order/">Customers Who Never Order</a><a name="customers-who-never-order"></a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select name as Customers</span><br><span class="line">from Customers</span><br><span class="line">where customers.id not in (select customerId from orders);</span><br></pre></td></tr></table></figure>



<h3 id="Rotate-Array"><a href="#Rotate-Array" class="headerlink" title="Rotate Array"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/rotate-array/">Rotate Array</a><a name="rotate-array"></a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    k %= nums.length;		<span class="comment">// k == nums.length ? Then it&#x27;s a full rotation and no change</span></span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    reverse(nums, <span class="number">0</span> , nums.length-<span class="number">1</span>);	<span class="comment">// First reverse the full array</span></span><br><span class="line">    reverse(nums, <span class="number">0</span>, k-<span class="number">1</span>);				<span class="comment">// Then reverse element from index 0 to k-1</span></span><br><span class="line">    reverse(nums, k, nums.length-<span class="number">1</span>);	<span class="comment">// Then reverse all elements from k to end of Array</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reverse function that reverses the array from specified indices.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start, <span class="type">int</span> end)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (start &lt; end)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[start];</span><br><span class="line">        nums[start] = nums[end];</span><br><span class="line">        nums[end] = temp;</span><br><span class="line">        start++;</span><br><span class="line">        end--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Delete-Duplicate-Emails"><a href="#Delete-Duplicate-Emails" class="headerlink" title="Delete Duplicate Emails"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/delete-duplicate-emails/">Delete Duplicate Emails</a><a name="delete-duplicate-emails"></a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">delete from Person</span><br><span class="line">where Id not in (select min_id from</span><br><span class="line">(select min(Id) as min_id from Person group by Email) as a)</span><br></pre></td></tr></table></figure>



<h3 id="Rising-Temperature"><a href="#Rising-Temperature" class="headerlink" title="Rising Temperature"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/rising-temperature/">Rising Temperature</a><a name="rising-temperature"></a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select w2.id</span><br><span class="line">from weather w1, weather w2</span><br><span class="line">where Datediff(w2.recorddate, w1.recorddate) = 1 and w2.temperature &gt; w1.temperature;</span><br></pre></td></tr></table></figure>



<h3 id="X-of-a-Kind-in-a-Deck-of-Cards"><a href="#X-of-a-Kind-in-a-Deck-of-Cards" class="headerlink" title="X of a Kind in a Deck of Cards"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/x-of-a-kind-in-a-deck-of-cards/">X of a Kind in a Deck of Cards</a><a name="x-of-a-kind-in-a-deck-of-cards"></a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasGroupsSizeX</span><span class="params">(<span class="type">int</span>[] deck)</span> &#123;</span><br><span class="line">    HashMap&lt;Integer, Integer&gt; freq = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; deck.length; i++)		<span class="comment">// Record the frequencies</span></span><br><span class="line">        freq.put(deck[i],freq.getOrDefault(deck[i],<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">deck = [1,1,2,2,2,2,3,3,3,3,3,3]</span></span><br><span class="line"><span class="comment">number 1 has len of 2, number 2 has len of 4, number 3 has len of 6, they share a Greatest common divisor of 2, which means diving them into group of size X = 2, will be valid. Thus we just have to ensure each length (of a number) shares a Greatest Common Divisor that&#x27;s &gt;= 2.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">hcf</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i: freq.keySet())</span><br><span class="line">        hcf = gcd(hcf, freq.get(i));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> hcf &gt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">gcd</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (y != <span class="number">0</span>)&#123;</span><br><span class="line">        temp = y;</span><br><span class="line">        y = x % y;</span><br><span class="line">        x = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Reverse-Integer"><a href="#Reverse-Integer" class="headerlink" title="Reverse Integer"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/reverse-integer/solution/">Reverse Integer</a><a name="reverse-integer"></a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sign</span> <span class="operator">=</span> x &lt; <span class="number">0</span> ? -<span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">    x = x * sign;							<span class="comment">// Make x positive</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        n = n * <span class="number">10</span> + x % <span class="number">10</span>;				<span class="comment">// Start adding from the end.</span></span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>)n == n ? (<span class="type">int</span>)n*sign : <span class="number">0</span>;	<span class="comment">// Try converting to int from long, if no change,</span></span><br><span class="line">&#125;											<span class="comment">// Return n * sign, else 0 cause overflow.</span></span><br></pre></td></tr></table></figure>



<h3 id="Add-Two-Numbers"><a href="#Add-Two-Numbers" class="headerlink" title="Add Two Numbers"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/add-two-numbers/submissions/">Add Two Numbers</a><a name="add-two-numbers"></a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">carry</span> <span class="operator">=</span> <span class="number">0</span>;							<span class="comment">// To record the carry</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;							<span class="comment">// To record the total of two vals</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);		<span class="comment">// Dummy&#x27;s next is the actual head</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">curr</span> <span class="operator">=</span> dummy;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l1 == <span class="literal">null</span>)						<span class="comment">// If one of the node is null, we set it to a</span></span><br><span class="line">            l1 = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);			<span class="comment">// dummy value of 0 so we can adjust for</span></span><br><span class="line">        <span class="keyword">if</span> (l2 == <span class="literal">null</span>)						<span class="comment">// different length of the two lists.</span></span><br><span class="line">            l2 = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        sum = l1.val + l2.val + carry;		<span class="comment">// Add the two vals and the carry.</span></span><br><span class="line">        carry = sum &lt; <span class="number">10</span> ? <span class="number">0</span> : <span class="number">1</span>;			<span class="comment">// Record the carry for the next iteration</span></span><br><span class="line">        curr.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(sum % <span class="number">10</span>);	<span class="comment">// next node&#x27;s value is sum % 10.</span></span><br><span class="line">        curr = curr.next;					<span class="comment">// advance current, l1 and l2.</span></span><br><span class="line">        l1 = l1.next;</span><br><span class="line">        l2 = l2.next;</span><br><span class="line">    &#125; <span class="keyword">while</span>(l1 != <span class="literal">null</span> || l2 != <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">if</span> (carry == <span class="number">1</span>)							<span class="comment">// In the end, if carry is 1, it was from</span></span><br><span class="line">        curr.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(carry);	<span class="comment">// from adding last terms, so make next node 1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummy.next;						<span class="comment">// Return the actual head.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Longest-Substring-Without-Repeating-Characters"><a href="#Longest-Substring-Without-Repeating-Characters" class="headerlink" title="Longest Substring Without Repeating Characters"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/longest-substring-without-repeating-characters/">Longest Substring Without Repeating Characters</a><a name="longest-substring-without-repeating-characters"></a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">null</span> || s.length() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[] hash = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">128</span>];					<span class="comment">// To store the occurence of characters</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">maxLength</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>; j &lt; s.length(); j++)&#123;</span><br><span class="line">        i = Math.max(hash[s.charAt(j)], i);		<span class="comment">// Check the most recent index of character.</span></span><br><span class="line">        maxLength = Math.max(maxLength, j-i+<span class="number">1</span>);	<span class="comment">// That minus current pointer gives length</span></span><br><span class="line">        hash[s.charAt(j)] = j+<span class="number">1</span>;				<span class="comment">// Record the index of the next character.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="House-Robber"><a href="#House-Robber" class="headerlink" title="House Robber"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/house-robber">House Robber</a><a name="house-robber"></a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">The basic idea is that if you are robbing house i, the maximum loot may come from by robbing the i-2th house or by robbing the i-3th house. Therefore rob both and then find the path that gave the maximum profit.</span></span><br><span class="line"><span class="comment">Example: loot = [1,9,3,8,4,3,6,4,3,5,7,6]</span></span><br><span class="line"><span class="comment">Profit DP = [1,9,4,17,13,20,23,24,26,29,33,35]</span></span><br><span class="line"><span class="comment">Here,</span></span><br><span class="line"><span class="comment">	dp[2] = loot[2] + loot[1]</span></span><br><span class="line"><span class="comment">	dp[4] = loot[4] + max(dp[2], dp[1])</span></span><br><span class="line"><span class="comment">	dp[5] = loot[5] + max(dp[3], dp[2]) and so on.</span></span><br><span class="line"><span class="comment">In the end, just compare the last two elements to check which path gave us the maximum profit.</span></span><br><span class="line"><span class="comment">Some people might not prefer modifying the original nums array. In that case, you can initialize another dp array of same length, initialize the first two elements as dp[0] = nums[0] and dp[1] = nums[1] and dp[3] = nums[0] + nums[2] and then performing the same loop. In that case, you would be using O(n) space.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span> || nums == <span class="literal">null</span>)			<span class="comment">// 3 Base Case</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (nums.length == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        nums[<span class="number">2</span>] = nums[<span class="number">0</span>] + nums[<span class="number">2</span>];				<span class="comment">// House 3 profit is rob House 1 and 3.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>; i &lt; nums.length; i++)</span><br><span class="line">            nums[i] = nums[i] + Math.max(nums[i-<span class="number">2</span>], nums[i-<span class="number">3</span>]);</span><br><span class="line">        <span class="keyword">return</span> Math.max(nums[nums.length-<span class="number">1</span>], nums[nums.length-<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Happy-Number"><a href="#Happy-Number" class="headerlink" title="Happy Number"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/happy-number/submissions/">Happy Number</a><a name="happy-number"></a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isHappy</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> isHappyConstantSpace(n);		<span class="comment">// Much faster than set method</span></span><br><span class="line">        <span class="comment">//return isHappySet(n);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isHappyConstantSpace</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">numSeenLessThan10</span> <span class="operator">=</span> <span class="number">0</span>;		<span class="comment">// If I see 10 single digits, then it means that I am</span></span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">1</span>)&#123;					<span class="comment">// now starting to see repititions.</span></span><br><span class="line">            <span class="keyword">if</span> (n &lt; <span class="number">10</span>)					<span class="comment">// Each time I see a num &lt; 10, increment the counter</span></span><br><span class="line">                numSeenLessThan10++;</span><br><span class="line">            <span class="keyword">if</span> (numSeenLessThan10 &gt; <span class="number">9</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            n = getSquare(n);			<span class="comment">// Get the total of square of its digits.</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">The general idea is that the moment you see a repition, it can&#x27;t be a happy number, so keep track of digit square obtained so far. If they hit 1, well and good, otherwise there will be some repition, so return false.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isHappySet</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        HashSet&lt;Integer&gt; seen = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();		<span class="comment">// Keep track of numbers</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            n = getSquare(n);							<span class="comment">// Get the sum of digits square</span></span><br><span class="line">            <span class="keyword">if</span> (n == <span class="number">1</span>)									<span class="comment">// If it&#x27;s 1, it&#x27;s a happy number</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (seen.contains(n))					<span class="comment">// If it&#x27;s a repition of something</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;							<span class="comment">// seen before, it&#x27;s not a happy no.</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                seen.add(n);							<span class="comment">// If not seen, add it.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getSquare</span><span class="params">(<span class="type">int</span> n)</span>&#123;		<span class="comment">// Add the squares of the digits.</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">digit</span> <span class="operator">=</span> n % <span class="number">10</span>;</span><br><span class="line">            total += digit * digit;</span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Remove-Linked-List-Elements"><a href="#Remove-Linked-List-Elements" class="headerlink" title="Remove Linked List Elements"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/remove-linked-list-elements/">Remove Linked List Elements</a><a name="remove-linked-list-elements"></a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="literal">null</span> &amp;&amp; head.val == val)				<span class="comment">// While head contains the val, skip</span></span><br><span class="line">        head = head.next;								<span class="comment">// the head</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">current</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">null</span> &amp;&amp; current.next != <span class="literal">null</span>)&#123;	<span class="comment">// While we have something to iterate</span></span><br><span class="line">        <span class="keyword">if</span> (current.next.val == val)					<span class="comment">// If current&#x27;s val match, skip the</span></span><br><span class="line">            current.next = current.next.next;			<span class="comment">// next node.</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            current = current.next;						<span class="comment">// Else advance to the next node.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Count-Primes"><a href="#Count-Primes" class="headerlink" title="Count Primes"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/count-primes/submissions/">Count Primes</a><a name="count-primes"></a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countPrimes</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;							<span class="comment">// No prime numbers for numbers &lt; 2</span></span><br><span class="line">    <span class="type">boolean</span>[] store = <span class="keyword">new</span> <span class="title class_">boolean</span>[n];		<span class="comment">// Using Sieve of Eratosthenes</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i*i &lt;= n; i++)			<span class="comment">// Start from i = 2 to sqrt(n)</span></span><br><span class="line">        <span class="keyword">if</span> (!store[i])						<span class="comment">// If store[i] = false, then mark all its</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i*i; j &lt; n; j += i)<span class="comment">// multiples in the store as true</span></span><br><span class="line">                store[j] = <span class="literal">true</span>;			<span class="comment">// True = not a prime, false = prime</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; n; i++)				<span class="comment">// Loop through the array, count</span></span><br><span class="line">        <span class="keyword">if</span> (!store[i])</span><br><span class="line">            count++;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Isomorphic-Strings"><a href="#Isomorphic-Strings" class="headerlink" title="Isomorphic Strings"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/isomorphic-strings/submissions/">Isomorphic Strings</a><a name="isomorphic-strings"></a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isIsomorphic</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s.length() != t.length())			<span class="comment">// Can&#x27;t be isomorphic is string lengths do not</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;						<span class="comment">// match</span></span><br><span class="line">    <span class="type">char</span>[] hashS = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">128</span>];			<span class="comment">// To store String s&#x27; match</span></span><br><span class="line">    <span class="type">char</span>[] hashT = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">128</span>];			<span class="comment">// To store String t&#x27;s match</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">charS</span> <span class="operator">=</span> s.charAt(i), charT = t.charAt(i);</span><br><span class="line">        <span class="keyword">if</span> (hashS[charS] != hashT[charT])	<span class="comment">// If the values at respective characters index</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;					<span class="comment">// do not match, return false</span></span><br><span class="line">        hashS[charS] = (<span class="type">char</span>)(i+<span class="number">1</span>);			<span class="comment">// Otherwise, mark those index with the same</span></span><br><span class="line">        hashT[charT] = (<span class="type">char</span>)(i+<span class="number">1</span>);			<span class="comment">// arbitrary value. I chose a simple (i+1) to</span></span><br><span class="line">    &#125;										<span class="comment">// to mark both the hash with the same value.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;							<span class="comment">// Everything worked out, return true;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Reverse-LinkedList"><a href="#Reverse-LinkedList" class="headerlink" title="Reverse LinkedList"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/reverse-linked-list/solution/">Reverse LinkedList</a><a name="reverse-linkedlist"></a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Recursive</span></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;	<span class="comment">// Very tricky. Refer to the demo below</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> reverseList(head.next);</span><br><span class="line">    head.next.next = head;</span><br><span class="line">    head.next = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Iterative</span></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> head;						<span class="comment">// No point in reversing empty or 1-sized list</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">curr</span> <span class="operator">=</span> head, prev = <span class="literal">null</span>;</span><br><span class="line">    ListNode nextNode;</span><br><span class="line">    <span class="keyword">while</span> (curr != <span class="literal">null</span>)&#123;					<span class="comment">// While we haven&#x27;t reached the tail</span></span><br><span class="line">        nextNode = curr.next;				<span class="comment">// Store the next node</span></span><br><span class="line">        curr.next = prev;					<span class="comment">// Current&#x27;s next becomes it&#x27;s previous</span></span><br><span class="line">        prev = curr;						<span class="comment">// Advance previous to current.</span></span><br><span class="line">        curr = nextNode;					<span class="comment">// Make current the actual next node</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev;							<span class="comment">// Current is at null, so it&#x27;s previous is the</span></span><br><span class="line">&#125;											<span class="comment">// new head.</span></span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/SamirPaulb/assets/main/reverse-a-linked-list-image.webp" alt="reverse Linked list"></p>
<h3 id="Contains-Duplicate"><a href="#Contains-Duplicate" class="headerlink" title="Contains Duplicate"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/contains-duplicate/submissions/">Contains Duplicate</a><a name="contains-duplicate"></a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsDuplicate</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;							<span class="comment">// There can&#x27;t be any duplicates.</span></span><br><span class="line">    HashSet&lt;Integer&gt; store = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();	<span class="comment">// Store unique values.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n: nums)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!store.add(n))						<span class="comment">// Add func returns true if n was&#x27;nt present,</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;						<span class="comment">// false if duplicate. Therefore if it was a</span></span><br><span class="line">    &#125;											<span class="comment">// duplicate, return true.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;								<span class="comment">// No duplicates, so return false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Contains-Duplicate-II"><a href="#Contains-Duplicate-II" class="headerlink" title="Contains Duplicate II"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/contains-duplicate-ii/">Contains Duplicate II</a><a name="contains-duplicate-ii"></a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsNearbyDuplicate</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    HashSet&lt;Integer&gt; store = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();	<span class="comment">// Use a rotating window of size k</span></span><br><span class="line">    <span class="keyword">while</span> (right &lt; nums.length)&#123;				<span class="comment">// While we haven&#x27;t processed everything</span></span><br><span class="line">        <span class="keyword">if</span> (store.contains(nums[right]))		<span class="comment">// If our current window contains duplicate</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        store.add(nums[right]);					<span class="comment">// No duplicates in the window</span></span><br><span class="line">        right++;								<span class="comment">// Increase right to visit the new element</span></span><br><span class="line">        <span class="keyword">if</span> (right - left &gt; k)&#123;					<span class="comment">// If window becomes &gt; k</span></span><br><span class="line">            store.remove(nums[left]);			<span class="comment">// remove the number on the left side of</span></span><br><span class="line">            left++;								<span class="comment">// the window and increase the left counter</span></span><br><span class="line">        &#125;										<span class="comment">// for new window from the next index</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;								<span class="comment">// No duplicates found in any window.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Implement-Stack-Using-Queues"><a href="#Implement-Stack-Using-Queues" class="headerlink" title="Implement Stack Using Queues"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/implement-stack-using-queues/">Implement Stack Using Queues</a><a name="implement-stack-using-queues"></a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line">    Deque&lt;Integer&gt; stack;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">()</span> &#123;</span><br><span class="line">        stack = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Push element x onto stack. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        stack.add(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Removes the element on top of the stack and returns that element. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stack.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Get the top element. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stack.peekLast();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns whether the stack is empty. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Invert-Binary-Tree"><a href="#Invert-Binary-Tree" class="headerlink" title="Invert Binary Tree"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/invert-binary-tree/">Invert Binary Tree</a><a name="invert-binary-tree"></a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> root.left;		<span class="comment">// Swap the left and right nodes</span></span><br><span class="line">    root.left = root.right;</span><br><span class="line">    root.right = temp;</span><br><span class="line">    invertTree(root.left);			<span class="comment">// Then swap the subsequent trees of those nodes.</span></span><br><span class="line">    invertTree(root.right);</span><br><span class="line">    <span class="keyword">return</span> root;					<span class="comment">// Return the original root.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Fibonacci-Number"><a href="#Fibonacci-Number" class="headerlink" title="Fibonacci Number"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/fibonacci-number/">Fibonacci Number</a><a name="fibonacci-number"></a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Iterative</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> N)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (N &lt; <span class="number">2</span>)						<span class="comment">// fib(0) = 0; fib(1) = 1</span></span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    <span class="type">int</span> <span class="variable">f0</span> <span class="operator">=</span> <span class="number">0</span>, f1 = <span class="number">1</span>, fn = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= N; i++)&#123;</span><br><span class="line">        fn = f0 + f1;				<span class="comment">// fib(n) = fib(n-1) + fib(n-2)</span></span><br><span class="line">        f0 = f1;					<span class="comment">// f0 becomes f1</span></span><br><span class="line">        f1 = fn;					<span class="comment">// f1 becomes fn</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Dynamic Programming</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">fibDP</span><span class="params">(<span class="type">int</span> N)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (N &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[N+<span class="number">1</span>];		<span class="comment">// To store intermediate result</span></span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span>;						<span class="comment">// fib(0) = 0; fib(1) = 1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= N; i++)</span><br><span class="line">        dp[i] = dp[i-<span class="number">1</span>]+dp[i-<span class="number">2</span>];	<span class="comment">// fib(i) = fib(i-1) + fib(i-2)</span></span><br><span class="line">    <span class="keyword">return</span> dp[N];					<span class="comment">// Return the last number in the array</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="kth-Largest-Element"><a href="#kth-Largest-Element" class="headerlink" title="kth Largest Element"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/kth-largest-element-in-an-array/">kth Largest Element</a><a name="kth-largest-element"></a></h3><ol>
<li>   The minheap algorithm has $O(n lg n) $ complexity and $O(1)$ space. The idea here is that we use a minheap to keep only the k greatest elements. If size becomes more than k, we remove the smallest element at the top of the heap. Thereby, at the end, our kth largest element will be at the top.</li>
<li>   QuickSelect Algorithm performs in $O(n)$ best case, $O(n^2)$ worst case when the pivot chosen is always the largest, so we use a random pivot.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MinHeap Algorithm</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">kthLargest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span>&#123;</span><br><span class="line">    PriorityQueue&lt;Integer&gt; q = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((n1,n2) -&gt; n1 - n2);	<span class="comment">// Initialize minheap</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n: nums)&#123;</span><br><span class="line">        q.add(n);				<span class="comment">// Add number one by one</span></span><br><span class="line">        <span class="keyword">if</span> (q.size() &gt; k)		<span class="comment">// If size is greater than k</span></span><br><span class="line">            q.poll();			<span class="comment">// Remove the topmost element</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> q.poll();			<span class="comment">// The topmost element is our answer</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// QuickSelect Algorithm - Hoare&#x27;s Partition Scheme</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span>[] arr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">kthLargest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span>&#123;</span><br><span class="line">	arr = nums;</span><br><span class="line">	<span class="keyword">return</span> quickselect(<span class="number">0</span>, nums.length-<span class="number">1</span>, nums.length-k);<span class="comment">// kth largest is (n-k)th largest</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">quickselect</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> k)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (left == right)					<span class="comment">// Array contains only 1 element, that&#x27;s the answer</span></span><br><span class="line">  		<span class="keyword">return</span> arr[left];</span><br><span class="line">	<span class="type">Random</span> <span class="variable">rand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();				<span class="comment">// Choose a random pivot between left and right</span></span><br><span class="line">	<span class="type">int</span> <span class="variable">pivotIndex</span> <span class="operator">=</span> left + rand.nextInt(right-left);	<span class="comment">// but not left</span></span><br><span class="line">	pivotIndex = partition(left, right, pivotIndex);	<span class="comment">// Partition, and find it&#x27;s correct index</span></span><br><span class="line">	<span class="keyword">if</span> (k == pivotIndex)					<span class="comment">// That index is equal to kth statistic</span></span><br><span class="line">  		<span class="keyword">return</span> arr[pivotIndex];</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (k &lt; pivotIndex)			<span class="comment">// If it&#x27;s less than the index, our ans lies in the</span></span><br><span class="line">  		<span class="keyword">return</span> quickselect(left, pivotIndex-<span class="number">1</span>, k);	<span class="comment">// left side</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">  		<span class="keyword">return</span> quickselect(pivotIndex+<span class="number">1</span>, right, k);	<span class="comment">// Otherwise, it&#x27;s on the right side.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> pivotIndex)</span>&#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> arr[pivotIndex];			<span class="comment">// Partition element</span></span><br><span class="line">	swap(pivotIndex, right);				<span class="comment">// Move that element to the end</span></span><br><span class="line">	<span class="type">int</span> <span class="variable">wall</span> <span class="operator">=</span> left - <span class="number">1</span>;					<span class="comment">// wall is initially before everything</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left; i &lt; right; i++)&#123;</span><br><span class="line">  		<span class="keyword">if</span> (arr[i] &lt; pivot)				<span class="comment">// If the current element is &lt; than the pivot, then</span></span><br><span class="line">    		swap(i, ++wall);			<span class="comment">// we need to swap it with the element next to wall.</span></span><br><span class="line">	&#125;</span><br><span class="line">	swap(right, ++wall);					<span class="comment">// Lastly, swap the element at wall and the end.</span></span><br><span class="line">	<span class="keyword">return</span> wall;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">	arr[i] = arr[j];</span><br><span class="line">	arr[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Power-Of-Two"><a href="#Power-Of-Two" class="headerlink" title="Power Of Two"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/power-of-two/">Power Of Two</a><a name="power-of-two"></a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPowerOfTwo</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;		<span class="comment">// n &lt; 0 cannot be powers of 2</span></span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> != <span class="number">0</span>)		<span class="comment">// If n is odd, it can&#x27;t be a power of 2.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        n = n / <span class="number">2</span>;			<span class="comment">// It is a multiple of 2, so divide it by 2.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;			<span class="comment">// n came out to be 1 which is a power of 2, so return true.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Valid-Sudoku"><a href="#Valid-Sudoku" class="headerlink" title="Valid Sudoku"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/valid-sudoku/">Valid Sudoku</a><a name="valid-sudoku"></a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">char</span>[][] board;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidSudoku</span><span class="params">(<span class="type">char</span>[][] board)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.board = board;</span><br><span class="line"><span class="keyword">return</span> rowCheck() &amp;&amp; colCheck() &amp;&amp; boxCheck();	<span class="comment">// Check row first, then column and at</span></span><br><span class="line">&#125;												<span class="comment">// last, boxes because they are time</span></span><br><span class="line">                                                <span class="comment">// consuming.</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">onePassCheck</span><span class="params">()</span>&#123;</span><br><span class="line">  HashSet&lt;Integer&gt;[] rows = <span class="keyword">new</span> <span class="title class_">HashSet</span>[<span class="number">9</span>];		<span class="comment">// 1 HashSet for each row</span></span><br><span class="line">  HashSet&lt;Integer&gt;[] columns = <span class="keyword">new</span> <span class="title class_">HashSet</span>[<span class="number">9</span>];	<span class="comment">// 1 HashSet for each column</span></span><br><span class="line">  HashSet&lt;Integer&gt;[] boxes = <span class="keyword">new</span> <span class="title class_">HashSet</span>[<span class="number">9</span>];	<span class="comment">// 1 HashSet for each box.</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)&#123;</span><br><span class="line">      rows[i] = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">      columns[i] = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">      boxes[i] = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">9</span>; j++)&#123;</span><br><span class="line">          <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> (<span class="type">int</span>)(board[i][j]);</span><br><span class="line">          <span class="keyword">if</span> (n != -<span class="number">2</span>)&#123;							<span class="comment">// -2 = &#x27;.&#x27;		</span></span><br><span class="line">              <span class="type">int</span> <span class="variable">boxIndex</span> <span class="operator">=</span> (i/<span class="number">3</span>) * <span class="number">3</span> + j/<span class="number">3</span>;	<span class="comment">// Calculate which box we are in.</span></span><br><span class="line">              <span class="keyword">if</span> (!rows[i].add(n) || !columns[j].add(n) || !boxes[boxIndex].add(n))</span><br><span class="line">                  <span class="keyword">return</span> <span class="literal">false</span>;					<span class="comment">// If the row set or the column set or the</span></span><br><span class="line">          &#125;										<span class="comment">// box set contains that val, return false.</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">rowCheck</span><span class="params">()</span>&#123;						<span class="comment">// Horizontal check</span></span><br><span class="line">    <span class="type">boolean</span>[] arr;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span>[] row: board)&#123;</span><br><span class="line">      arr = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">9</span>];</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">char</span> c: row)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> c-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (val != -<span class="number">2</span>)&#123;								<span class="comment">// val = -2 means &#x27;.&#x27; in the board</span></span><br><span class="line">          <span class="keyword">if</span> (arr[val-<span class="number">1</span>])							<span class="comment">// If val already seen, invalid sudoku</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">          arr[val-<span class="number">1</span>] = <span class="literal">true</span>;						<span class="comment">// else, Mark that index as seen.</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">colCheck</span><span class="params">()</span>&#123;						<span class="comment">// Vertical Check.</span></span><br><span class="line">    <span class="type">boolean</span>[] arr;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> <span class="number">0</span>; col &lt; board.length; col++)&#123;</span><br><span class="line">      arr = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">9</span>];</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> <span class="number">0</span>; row &lt; board[<span class="number">0</span>].length; row++)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> board[row][col]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (val != -<span class="number">2</span>)&#123;</span><br><span class="line">          <span class="keyword">if</span> (arr[val-<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">          arr[val-<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">boxCheck</span><span class="params">()</span>&#123;					<span class="comment">// For the 9 sub boxes, let the single</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">9</span>; i+=<span class="number">3</span>)&#123;				<span class="comment">// box checker check it&#x27;s validity.</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">9</span>; j+=<span class="number">3</span>)				<span class="comment">// If any of the subbox was invalid,</span></span><br><span class="line">        <span class="keyword">if</span> (!singleBoxCheck(i,j))				<span class="comment">// we abort and return false.</span></span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">singleBoxCheck</span><span class="params">(<span class="type">int</span> topRightRow, <span class="type">int</span> topRightCol)</span>&#123;</span><br><span class="line">    <span class="type">boolean</span>[] arr = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">9</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;				<span class="comment">// Each sub box has 3 rows and 3 columns</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> board[topRightRow+i][topRightCol+j]-<span class="string">&#x27;0&#x27;</span>;	<span class="comment">// This gives us the value at </span></span><br><span class="line">        <span class="keyword">if</span> (val != -<span class="number">2</span>)&#123;							<span class="comment">// each cell in the sub box and we fill the</span></span><br><span class="line">          <span class="keyword">if</span> (arr[val-<span class="number">1</span>])						<span class="comment">// arr with all values that are seen.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;						<span class="comment">// If seen twice, return false;</span></span><br><span class="line">          arr[val-<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Implement-Queue-Using-Stack"><a href="#Implement-Queue-Using-Stack" class="headerlink" title="Implement Queue Using Stack"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/implement-queue-using-stacks/submissions/">Implement Queue Using Stack</a><a name="implement-queue-using-stack"></a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Since we reverse stack1 into stack2, stack2 is basically our queue, so if stack2 isn&#x27;t empty, then the topmost element is what we need when we pop or peek. If it is empty, then again fill it with whatever&#x27;s there is stack1, and it again becomes the correct queue.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Stack&lt;Integer&gt; stack1;</span><br><span class="line">Stack&lt;Integer&gt; stack2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">MyQueue</span><span class="params">()</span> &#123;</span><br><span class="line">    stack1 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    stack2 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    stack1.push(x);			<span class="comment">// Push onto stack1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">    peek();					<span class="comment">// First call the peek function, to make sure stack 2 isn&#x27;t</span></span><br><span class="line">    <span class="keyword">return</span> stack2.pop();	<span class="comment">// empty. Then, the topmost element of stack2 is what we want</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Get the front element. */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (stack2.isEmpty())&#123;			</span><br><span class="line">        <span class="keyword">while</span> (!stack1.isEmpty())</span><br><span class="line">            stack2.push(stack1.pop());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack2.peek();	<span class="comment">// stack2 is basically the queue, so return whatever&#x27;s on the top</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Returns whether the queue is empty. */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> stack1.isEmpty() &amp;&amp; stack2.isEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Palindrome-LinkedList"><a href="#Palindrome-LinkedList" class="headerlink" title="Palindrome LinkedList"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/palindrome-linked-list/submissions/">Palindrome LinkedList</a><a name="palindrome-linkedlist"></a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>)		<span class="comment">// Size 0 or 1 list, must be unique.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (head.next.next == <span class="literal">null</span>)					<span class="comment">// Size 2 list, compare the head and tail</span></span><br><span class="line">        <span class="keyword">return</span> head.val == head.next.val;		<span class="comment">// values</span></span><br><span class="line"></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">middleNode</span> <span class="operator">=</span> head;					<span class="comment">// Standard Rabbit-Tortoise pointers.</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">fastPointer</span> <span class="operator">=</span> head;				<span class="comment">// Fast pointer jumps twice so by the time</span></span><br><span class="line">												<span class="comment">// it reaches the end of the list, middlenode</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">curr</span> <span class="operator">=</span> head;						<span class="comment">// is at the middle of the linkedlist.</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    ListNode nextNode;							<span class="comment">// These three nodes are for reversing the </span></span><br><span class="line">												<span class="comment">// first half of the list</span></span><br><span class="line">    <span class="keyword">while</span> (fastPointer != <span class="literal">null</span> &amp;&amp; fastPointer.next != <span class="literal">null</span>)&#123;</span><br><span class="line">        middleNode = middleNode.next;			<span class="comment">// Advance middle once, fastpointer twice</span></span><br><span class="line">        fastPointer = fastPointer.next.next;</span><br><span class="line"></span><br><span class="line">        nextNode = curr.next;					<span class="comment">// Reverse the curr node, but first store the</span></span><br><span class="line">        curr.next = prev;						<span class="comment">// next newNode. By doing this, we would have</span></span><br><span class="line">        prev = curr;							<span class="comment">// reversed exactly half of the list because</span></span><br><span class="line">        curr = nextNode;						<span class="comment">// fastpointer advacnes at double the speed.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fastPointer != <span class="literal">null</span>)					<span class="comment">// If faspointer isn&#x27;t null, then we have an</span></span><br><span class="line">        middleNode = middleNode.next;			<span class="comment">// odd length list, so advance middle once,</span></span><br><span class="line">												<span class="comment">// List looks like 1-&gt;2-&gt;3-&gt;2-&gt;1 instead of</span></span><br><span class="line">    <span class="keyword">while</span> (middleNode != <span class="literal">null</span>)&#123;					<span class="comment">// 1-&gt;2-&gt;3-&gt;3-&gt;2-&gt;1</span></span><br><span class="line">        <span class="keyword">if</span> (middleNode.val != prev.val)			<span class="comment">// While middle isn&#x27;t null, check middlenode</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;						<span class="comment">// val and prev val. Prev is basically the</span></span><br><span class="line">        middleNode = middleNode.next;			<span class="comment">// the point where the list reverses.</span></span><br><span class="line">        prev = prev.next;						<span class="comment">// Advance middle and next.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;								<span class="comment">// Values matched, so return true.</span></span><br><span class="line">&#125;												<span class="comment">// Reversed list looks like this:</span></span><br><span class="line">												<span class="comment">// 1&lt;-2&lt;-3&lt;-prev middle-&gt;3-&gt;2-&gt;1 in even len</span></span><br><span class="line">												<span class="comment">// 1&lt;-2&lt;-prev middle-&gt;2-&gt;1 in odd lengths.</span></span><br></pre></td></tr></table></figure>



<h3 id="Delete-Node-in-a-Linked-List"><a href="#Delete-Node-in-a-Linked-List" class="headerlink" title="Delete Node in a Linked List"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/delete-node-in-a-linked-list/submissions/">Delete Node in a Linked List</a><a name="delete-node-in-a-linked-list"></a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteNode</span><span class="params">(ListNode node)</span> &#123;</span><br><span class="line">    node.val = node.next.val;		<span class="comment">// Node&#x27;s value becomes its next node&#x27;s value</span></span><br><span class="line">    node.next = node.next.next;  	<span class="comment">// Node&#x27;s next is it&#x27;s next&#x27;s next.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Is-Anagram"><a href="#Is-Anagram" class="headerlink" title="Is Anagram"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/valid-anagram/submissions/">Is Anagram</a><a name="is-anagram"></a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAnagram</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s.length() != t.length())			<span class="comment">// Can&#x27;t be anagram if size aren&#x27;t the same</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span>[] store = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];				<span class="comment">// Acts like a hashmap</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++)	<span class="comment">// Increment the count by 1 in the store for the</span></span><br><span class="line">        store[s.charAt(i)-<span class="string">&#x27;a&#x27;</span>]++;			<span class="comment">// index = position of char in the alphabet</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; t.length(); i++)&#123;	<span class="comment">// Loop throught the second string, decrement</span></span><br><span class="line">        <span class="keyword">if</span> (--store[t.charAt(i)-<span class="string">&#x27;a&#x27;</span>] &lt; <span class="number">0</span>)	<span class="comment">// count of each character in store by 1, but if</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;					<span class="comment">// it goes below 0, then it means that character</span></span><br><span class="line">    &#125;										<span class="comment">// occurred more than it did in s. So false.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;							<span class="comment">// Everything matched, so return true.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Binary-Tree-Paths"><a href="#Binary-Tree-Paths" class="headerlink" title="Binary Tree Paths"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/binary-tree-paths/">Binary Tree Paths</a><a name="binary-tree-paths"></a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; paths = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">public</span> List&lt;String&gt; <span class="title function_">binaryTreePaths</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>)					<span class="comment">// No paths</span></span><br><span class="line">        <span class="keyword">return</span> paths;</span><br><span class="line">    <span class="type">String</span> <span class="variable">rootval</span> <span class="operator">=</span> root.val + <span class="string">&quot;&quot;</span>;		<span class="comment">// Converting int to string.</span></span><br><span class="line">    traverse(root, rootval);</span><br><span class="line">    <span class="keyword">return</span> paths;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root, String s)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>)		<span class="comment">// It&#x27;s a leaf, and you found a path</span></span><br><span class="line">        paths.add(s);									<span class="comment">// so add it to the list</span></span><br><span class="line">    <span class="keyword">if</span> (root.left != <span class="literal">null</span>)								<span class="comment">// Left side is traversable, so</span></span><br><span class="line">        traverse(root.left, s + <span class="string">&quot;-&gt;&quot;</span> + root.left.val);	<span class="comment">// visit it and record its value.</span></span><br><span class="line">    <span class="keyword">if</span> (root.right != <span class="literal">null</span>)								<span class="comment">// Same as above, but for right side.</span></span><br><span class="line">        traverse(root.right, s + <span class="string">&quot;-&gt;&quot;</span> + root.right.val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Add-Digits"><a href="#Add-Digits" class="headerlink" title="Add Digits"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/add-digits/">Add Digits</a><a name="add-digits"></a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">constantTime</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">10</span>)</span><br><span class="line">        <span class="keyword">return</span> n;			<span class="comment">// Already a single digit</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> n % <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="number">0</span>)		<span class="comment">// If perfectly divisible by 9, then sum will be 9.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">return</span> result;			<span class="comment">// Otherwise, the result is going to be n % 9.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">iterative</span><span class="params">(<span class="type">int</span> num)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (num &gt; <span class="number">9</span>)&#123;				<span class="comment">// While number isn&#x27;t between 2-9</span></span><br><span class="line">        num = sumOfDigits(num);		<span class="comment">// make num = sum of it&#x27;s digits.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">sumOfDigits</span><span class="params">(<span class="type">int</span> n)</span>&#123;		<span class="comment">// Standard method to add the digits of a number.</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n != <span class="number">0</span>)&#123;</span><br><span class="line">        sum += n % <span class="number">10</span>;				<span class="comment">// Extract the last digit, add it to sum.</span></span><br><span class="line">        n /= <span class="number">10</span>;					<span class="comment">// Divide the num by 10.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Largest-Perimeter-Triangle"><a href="#Largest-Perimeter-Triangle" class="headerlink" title="Largest Perimeter Triangle"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/largest-perimeter-triangle/">Largest Perimeter Triangle</a><a name="largest-perimeter-triangle"></a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">largestPerimeter</span><span class="params">(<span class="type">int</span>[] A)</span> &#123;</span><br><span class="line">    Arrays.sort(A);							<span class="comment">// Sort so the largest sides are at the end.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> A.length-<span class="number">3</span>; i &gt;= <span class="number">0</span>; --i)	<span class="comment">// Triangle inequality Theorem : a + b &gt; c</span></span><br><span class="line">        <span class="keyword">if</span> (A[i] + A[i+<span class="number">1</span>] &gt; A[i+<span class="number">2</span>])			<span class="comment">// If sum of last two is greater than the last</span></span><br><span class="line">            <span class="keyword">return</span> A[i] + A[i+<span class="number">1</span>] + A[i+<span class="number">2</span>];	<span class="comment">// we found out max perimeter, otherwise</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;								<span class="comment">// decrease i by i, then check the next three</span></span><br><span class="line">&#125;											<span class="comment">// triplets</span></span><br><span class="line">											<span class="comment">// In the end if nothing works out, we return 0.</span></span><br></pre></td></tr></table></figure>



<h3 id="Ugly-Number"><a href="#Ugly-Number" class="headerlink" title="Ugly Number"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/ugly-number/submissions/">Ugly Number</a><a name="ugly-number"></a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isUgly</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;		<span class="comment">// Negative numbers are automatically non ugly</span></span><br><span class="line">    <span class="keyword">while</span> (num % <span class="number">2</span> == <span class="number">0</span>)	<span class="comment">// Keep dividing number by 2 till it is divisible</span></span><br><span class="line">        num /= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (num % <span class="number">3</span> == <span class="number">0</span>)	<span class="comment">// Keep dividing by 3</span></span><br><span class="line">        num /= <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">while</span> (num % <span class="number">5</span> == <span class="number">0</span>)	<span class="comment">// and 5</span></span><br><span class="line">        num /= <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">return</span> num == <span class="number">1</span>;		<span class="comment">// If num isn&#x27;t 1, that means that there are other prime factors</span></span><br><span class="line">&#125;							<span class="comment">// except 2,3 and 5.</span></span><br></pre></td></tr></table></figure>



<h3 id="Missing-Number"><a href="#Missing-Number" class="headerlink" title="Missing Number"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/missing-number/">Missing Number</a><a name="missing-number"></a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">missingNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;			<span class="comment">// Since it&#x27;s given that the array contains</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">nsum</span> <span class="operator">=</span> (nums.length*(nums.length+<span class="number">1</span>))/<span class="number">2</span>;	<span class="comment">// all numbers from 0-n, we use the formula</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">arraySum</span> <span class="operator">=</span> nums[<span class="number">0</span>];						<span class="comment">// to compute sum of n numbers.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++)		<span class="comment">// Then we loop through the array to compute</span></span><br><span class="line">        arraySum += nums[i];					<span class="comment">// the sum of the array.</span></span><br><span class="line">    <span class="keyword">return</span> nsum - arraySum;						<span class="comment">// Subtract the array sum from the required</span></span><br><span class="line">&#125;												<span class="comment">// sum, and that gives us the missing number</span></span><br></pre></td></tr></table></figure>



<h3 id="Is-Bad-Version"><a href="#Is-Bad-Version" class="headerlink" title="Is Bad Version"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/first-bad-version/submissions/">Is Bad Version</a><a name="is-bad-version"></a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">firstBadVersion</span><span class="params">(<span class="type">int</span> n)</span> &#123;		<span class="comment">// Basic Binary Search Algorithm</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> <span class="number">1</span>, high = n;</span><br><span class="line">    <span class="type">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span> (low &lt; high)&#123;</span><br><span class="line">        mid = low + (high - low)/<span class="number">2</span>;		<span class="comment">// high - low to prefent integer overflow.</span></span><br><span class="line">        <span class="keyword">if</span> (isBadVersion(mid))			<span class="comment">// if the model at mid was bad version, then we</span></span><br><span class="line">            high = mid;					<span class="comment">// could possibly have a bad version before it</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            low = mid+<span class="number">1</span>;				<span class="comment">// If it wasn&#x27;t, then our first bad version lies</span></span><br><span class="line">    &#125;									<span class="comment">// beyond the middle element.</span></span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Move-Zeroes"><a href="#Move-Zeroes" class="headerlink" title="Move Zeroes"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/move-zeroes/solution/">Move Zeroes</a><a name="move-zeroes"></a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">The general idea is that we know the end of the array is going to contain zeroes. So first, iterate over the array, if you find any non-zero value, copy it down to the front of the array. Then we you are done, length of the array minus the last index where you copied the non-zero element is the number of zeroes you need to fill in. So iterate from that last non-zero index to the end of the array and fill in zeroes.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">moveZeroes</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">lastNonZeroIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++)</span><br><span class="line">        <span class="keyword">if</span> (nums[i] != <span class="number">0</span>)</span><br><span class="line">            nums[lastNonZeroIndex++] = nums[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> lastNonZeroIndex; i &lt; nums.length; i++)</span><br><span class="line">        nums[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">This solution is an extension of the above, but a better one because we only swap elements when needed and do not do any unnecessary writes. Start from the beginning of the array, maintain the last position of non-zero value you saw, and the current element. If you see a non-zero value, swap the current value with the index just after the last non-zero index you have, and then increment the non-zero index by 1 because you just found a new non-zero value. This helps us prepare for the next non-zero value we find and copy it at this index+1. By doing so, we are basically partitioning the array into non-zeroes and zero values.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">moveZeroes</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">lastNonZeroIndex</span> <span class="operator">=</span> <span class="number">0</span>, i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] != <span class="number">0</span>)</span><br><span class="line">            swap(nums, i , lastNonZeroIndex++);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> a[i];</span><br><span class="line">    a[i] = a[j];</span><br><span class="line">    a[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Word-Pattern"><a href="#Word-Pattern" class="headerlink" title="Word Pattern"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/word-pattern/">Word Pattern</a><a name="word-pattern"></a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">wordPattern</span><span class="params">(String pattern, String str)</span> &#123;</span><br><span class="line">    String[] words = str.split(<span class="string">&quot; &quot;</span>);		<span class="comment">// Split str into words</span></span><br><span class="line">    <span class="keyword">if</span> (pattern.length() != words.length)	<span class="comment">// If length of pattern and words mismatch</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;						<span class="comment">// then pattern do not match</span></span><br><span class="line">    HashMap&lt;Character, String&gt; patternStore = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();	<span class="comment">// Map pattern char to word</span></span><br><span class="line">    HashMap&lt;String, Character&gt; wordMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();		<span class="comment">// Map word to pattern char</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; words.length; i++)&#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> pattern.charAt(i);					<span class="comment">// Get the char</span></span><br><span class="line">        patternStore.putIfAbsent(c, words[i]);		<span class="comment">// Put it in patternStore if absent</span></span><br><span class="line">        <span class="keyword">if</span> (!patternStore.get(c).equals(words[i]))	<span class="comment">// If it was already there and it doesn&#x27;t</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;							<span class="comment">// map to words[i], we have a violation</span></span><br><span class="line">        wordMap.putIfAbsent(words[i], c);			<span class="comment">// Now check the other way around. If</span></span><br><span class="line">        <span class="keyword">if</span> (wordMap.get(words[i]) != c)				<span class="comment">// words is absent in the map, map it to</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;							<span class="comment">// the char. If present, then fetch it&#x27;s</span></span><br><span class="line">    &#125;												<span class="comment">// mapping and check if both match to c.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;							<span class="comment">// No violation, so return true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Can-Win-Nim"><a href="#Can-Win-Nim" class="headerlink" title="Can Win Nim"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/nim-game/">Can Win Nim</a><a name="can-win-nim"></a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canWinNim</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> n % <span class="number">4</span> != <span class="number">0</span>;			<span class="comment">// You can always win the game if n is not divisible by 4.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Power-Of-Three"><a href="#Power-Of-Three" class="headerlink" title="Power Of Three"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/power-of-three/">Power Of Three</a><a name="power-of-three"></a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPowerOfThree</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">1</span>)				<span class="comment">// If negative, it can&#x27;t be a power of 3.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (n % <span class="number">3</span> == <span class="number">0</span>)		<span class="comment">// While n is divisible by 3, keep dividing it.</span></span><br><span class="line">        n /= <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">return</span> n == <span class="number">1</span>;			<span class="comment">// In the end, if it was a power of 3, then n should be 1.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Power-of-Four"><a href="#Power-of-Four" class="headerlink" title="Power of Four"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/power-of-four/submissions/">Power of Four</a><a name="power-of-four"></a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">You can also use the iterative method that I have used in Power of Two and Power of Three problems. I just wanted to try a different approach here. This is a constant time function.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPowerOfFour</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="variable">pow</span> <span class="operator">=</span> Math.log(num)/Math.log(<span class="number">4</span>);	<span class="comment">// Calculate x in 4^x = num using logs.</span></span><br><span class="line">    <span class="keyword">return</span> pow == (<span class="type">int</span>)pow;					<span class="comment">// Making sure that x is an integer and not a</span></span><br><span class="line">&#125;											<span class="comment">// fractional exponent.</span></span><br></pre></td></tr></table></figure>



<h3 id="Reverse-String"><a href="#Reverse-String" class="headerlink" title="Reverse String"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/reverse-string/">Reverse String</a><a name="reverse-string"></a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1 Liner solution. Basically, create a StringBuilder of the string, the builder already has a reverse method, so reverse it and then return it&#x27;s toString.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">reverseString</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(s).reverse().toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Golfing aside, here is how one is expected to solve it in an interview.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">reverseString</span><span class="params">(String s)</span> &#123;</span><br><span class="line">	<span class="type">char</span>[] array = s.toCharArray();		<span class="comment">// Create a char array of the string</span></span><br><span class="line">	<span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> array.length;				<span class="comment">// length of the array</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len/<span class="number">2</span>; i++)&#123;	<span class="comment">// We only need to iterate over half the array.</span></span><br><span class="line">		<span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> array[i];			<span class="comment">// Swap the 0th index element with (len-1)th,</span></span><br><span class="line">		array[i] = array[len-i-<span class="number">1</span>];		<span class="comment">// 1st index element with (len-2)th, until you get</span></span><br><span class="line">		array[len-i-<span class="number">1</span>] = temp;			<span class="comment">// to the middle element.</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(array);			<span class="comment">// Return a new string with the reversed array.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Implement-strStr"><a href="#Implement-strStr" class="headerlink" title="Implement strStr()"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/implement-strstr/submissions/">Implement strStr()</a><a name="implement-strstr()"></a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">The basic idea here is that you only need to iterate haystack length - needle length, and then check the substring of size = needle length in haystack from each index. If you are successfully able to match each character of the needle in the corresponding substring in haystack, return the index you start from. </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">strStr</span><span class="params">(String haystack, String needle)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (needle.length() &gt; haystack.length())	<span class="comment">// Needle length can&#x27;t be &gt; than haystack</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">hl</span> <span class="operator">=</span> haystack.length();</span><br><span class="line">    <span class="type">int</span> <span class="variable">nl</span> <span class="operator">=</span> needle.length();</span><br><span class="line">    <span class="keyword">if</span> (nl == <span class="number">0</span>)								<span class="comment">// Empty strings are always a match starting</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;								<span class="comment">// from 0.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= hl-nl; i++)&#123;			<span class="comment">// Iterate haystack length - needle length.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; nl &amp;&amp; haystack.charAt(i+j) == needle.charAt(j); ++j)&#125;</span><br><span class="line">            <span class="keyword">if</span> (j == nl-<span class="number">1</span>)						<span class="comment">// We are checking how far from i can we</span></span><br><span class="line">                <span class="keyword">return</span> i;						<span class="comment">// match. If i matched with j, increment j</span></span><br><span class="line">        &#125;										<span class="comment">// and then match the character i+1 to j.</span></span><br><span class="line">    &#125;											<span class="comment">// If that matches, increment j and match i+2</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;									<span class="comment">// j == n-1 checked wether or not if we were</span></span><br><span class="line">&#125;												<span class="comment">// able to match the full needle string, if</span></span><br><span class="line">												<span class="comment">// yes, then i is our index</span></span><br><span class="line">												<span class="comment">// in the end, nothing matched, so return -1</span></span><br></pre></td></tr></table></figure>



<h3 id="Reverse-Vowels-of-a-String"><a href="#Reverse-Vowels-of-a-String" class="headerlink" title="Reverse Vowels of a String"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/reverse-vowels-of-a-string/">Reverse Vowels of a String</a><a name="reverse-vowels-of-a-string"></a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">reverseVowels</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s.length() &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> s;					<span class="comment">// No need to reverse a string of length 0 or 1</span></span><br><span class="line">    <span class="type">char</span>[] str = s.toCharArray();	<span class="comment">// Get the char array</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> str.length-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right)&#123;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; !isVowel(str[left]))		<span class="comment">// While left is pointing to a</span></span><br><span class="line">            left++;										<span class="comment">// consonant, increment it/</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; !isVowel(str[right]))	<span class="comment">// While right is pointing to a</span></span><br><span class="line">            right--;									<span class="comment">// consonant, decrement it.</span></span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> str[left];							<span class="comment">// Left and right are now pointing</span></span><br><span class="line">        str[left] = str[right];							<span class="comment">// to vowels, so swap it.</span></span><br><span class="line">        str[right] = temp;								<span class="comment">// And then increment left and</span></span><br><span class="line">        left++;											<span class="comment">// decrement right to process the</span></span><br><span class="line">        right--;										<span class="comment">// inner string</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(str);			<span class="comment">// Return a string from the reveresed array.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isVowel</span><span class="params">(<span class="type">char</span> c)</span>&#123;	<span class="comment">// Function to check if a character is a vowel.</span></span><br><span class="line">    <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;i&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;o&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;u&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;E&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;I&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;O&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;U&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Intersection-of-two-arrays"><a href="#Intersection-of-two-arrays" class="headerlink" title="Intersection of two arrays"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/intersection-of-two-arrays/">Intersection of two arrays</a><a name="intersection-of-two-arrays"></a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] intersection(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">    Set&lt;Integer&gt; set1 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Integer&gt;();		<span class="comment">// Record all unique values in set 1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i: nums1)</span><br><span class="line">        set1.add(i);</span><br><span class="line">    Set&lt;Integer&gt; intersect = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();		<span class="comment">// We will use it to record intersection</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i: nums2)								<span class="comment">// For each value in nums2 array</span></span><br><span class="line">        <span class="keyword">if</span> (set1.contains(i))						<span class="comment">// If set1 contains it, we found an</span></span><br><span class="line">            intersect.add(i);						<span class="comment">// intersecting element, so add it.</span></span><br><span class="line">    <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[intersect.size()];			<span class="comment">// We will now convert the set to an</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;										<span class="comment">// array and then return the array.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n: intersect)</span><br><span class="line">        res[i++] = n;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Is-Perfect-Square"><a href="#Is-Perfect-Square" class="headerlink" title="Is Perfect Square"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/valid-perfect-square/">Is Perfect Square</a><a name="is-perfect-square"></a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">The basic idea here is to close in on the square root using binary search algorithm. </span></span><br><span class="line"><span class="comment">I handle 4 seperately because it&#x27;s root is the only one where 4/3 &lt; it&#x27;s square root. </span></span><br><span class="line"><span class="comment">All other numbers square root is greater than its value/3.</span></span><br><span class="line"><span class="comment">So we create a lowerBound of 1 and an upperBound of num/3. Then if the middle value&#x27;s square</span></span><br><span class="line"><span class="comment">overshoots, we make upperBound = mid-1, otherwise increment lowerBound to mid+1. This way, we</span></span><br><span class="line"><span class="comment">close on the square root from both sides, and if the middle values is the square root, it&#x27;s</span></span><br><span class="line"><span class="comment">square will yield num.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPerfectSquare</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt; <span class="number">2</span> || num == <span class="number">4</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="type">long</span> <span class="variable">lowerBound</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">long</span> <span class="variable">upperBound</span> <span class="operator">=</span> num/<span class="number">3</span>;</span><br><span class="line">    <span class="type">long</span> mid;</span><br><span class="line">    <span class="type">long</span> square;</span><br><span class="line">    <span class="keyword">while</span> (lowerBound &lt;= upperBound)&#123;</span><br><span class="line">        mid = lowerBound + (upperBound-lowerBound)/<span class="number">2</span>;</span><br><span class="line">        square = mid*mid;</span><br><span class="line">        <span class="keyword">if</span> (square == num)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (square &gt; num)</span><br><span class="line">            upperBound = mid-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            lowerBound = mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Sum-of-Two-Integers"><a href="#Sum-of-Two-Integers" class="headerlink" title="Sum of Two Integers"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/sum-of-two-integers/">Sum of Two Integers</a><a name="sum-of-two-integers"></a></h3><p>I cannot explain it better than this <a target="_blank" rel="noopener" href="https://leetcode.com/problems/sum-of-two-integers/discuss/132479/Simple-explanation-on-how-to-arrive-at-the-solution">post</a>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> a ^ b;</span><br><span class="line">    <span class="type">int</span> <span class="variable">carry</span> <span class="operator">=</span> a &amp; b;</span><br><span class="line">    <span class="keyword">if</span> (carry == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    <span class="keyword">return</span> getSum(sum, carry &lt;&lt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Guess-Number-Higher-or-Lower"><a href="#Guess-Number-Higher-or-Lower" class="headerlink" title="Guess Number Higher or Lower"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/guess-number-higher-or-lower/">Guess Number Higher or Lower</a><a name="guess-number-higher-or-lower"></a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">guessNumber</span><span class="params">(<span class="type">int</span> n)</span> &#123;				<span class="comment">// Standard binary search algorithm</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> <span class="number">1</span>, high = n, result = -<span class="number">2</span>;		<span class="comment">// Arbitrary result, but not 0</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (result != <span class="number">0</span>)&#123;</span><br><span class="line">        mid = low + (high-low)/<span class="number">2</span>;			<span class="comment">// Check the mid.</span></span><br><span class="line">        result = guess(mid);				<span class="comment">// Check if our guess is correct</span></span><br><span class="line">        <span class="keyword">if</span> (result == -<span class="number">1</span>)					<span class="comment">// If result == -1, then we overshot</span></span><br><span class="line">            high = mid-<span class="number">1</span>;					<span class="comment">// So we can discard all values &gt; mid</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (result == <span class="number">1</span>)				<span class="comment">// If result == 1, we undershot</span></span><br><span class="line">            low = mid+<span class="number">1</span>;					<span class="comment">// Need to discard all the values &lt; mid</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mid;								<span class="comment">// Result == 0, so return the mid.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Ransom-Note"><a href="#Ransom-Note" class="headerlink" title="Ransom Note"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/ransom-note/submissions/">Ransom Note</a><a name="ransom-note"></a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canConstruct</span><span class="params">(String ransomNote, String magazine)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] store = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c: magazine.toCharArray())		<span class="comment">// First, fill the store with available</span></span><br><span class="line">        store[c-<span class="string">&#x27;a&#x27;</span>]++;							<span class="comment">// characters from the magazine</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c: ransomNote.toCharArray())		<span class="comment">// Then, scan through the note, decrement</span></span><br><span class="line">        <span class="keyword">if</span> (--store[c-<span class="string">&#x27;a&#x27;</span>] &lt; <span class="number">0</span>)					<span class="comment">// each char&#x27;s index by 1 because we used</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;						<span class="comment">// it. If it&#x27;s frequency drops below 0,</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;								<span class="comment">// then it means that we need more chars</span></span><br><span class="line">&#125;												<span class="comment">// than available. In the end, return</span></span><br><span class="line">												<span class="comment">// true if everything worked out.</span></span><br></pre></td></tr></table></figure>



<h3 id="First-Unique-Character-in-a-String"><a href="#First-Unique-Character-in-a-String" class="headerlink" title="First Unique Character in a String"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/first-unique-character-in-a-string/submissions/">First Unique Character in a String</a><a name="first-unique-character-in-a-string"></a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">firstUniqChar</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] freq = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];			<span class="comment">// Preprocess freq array to maintain freq of each</span></span><br><span class="line">    <span class="type">char</span>[] chars = s.toCharArray();		<span class="comment">// character in the string s</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c: chars)</span><br><span class="line">        ++freq[c-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; chars.length; i++)	<span class="comment">// Make a second pass through the chars of the</span></span><br><span class="line">        <span class="keyword">if</span> (freq[chars[i]-<span class="string">&#x27;a&#x27;</span>] == <span class="number">1</span>)		<span class="comment">// string in order, and if any of the char&#x27;s</span></span><br><span class="line">            <span class="keyword">return</span> i;						<span class="comment">// frequency is 1, that&#x27;s our unique char</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;								<span class="comment">// Otherwise, no unique character</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Find-the-Difference"><a href="#Find-the-Difference" class="headerlink" title="Find the Difference"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/find-the-difference/">Find the Difference</a><a name="find-the-difference"></a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">The general idea here is same as the problem where we are required to find a unique int</span></span><br><span class="line"><span class="comment">in an array containing duplicates except one. We use the xor operator between each character</span></span><br><span class="line"><span class="comment">of the string s and t, and the ones that are duplicate will xor to give 0. XOR of any element</span></span><br><span class="line"><span class="comment">with 0 is the element itself, and XOR of two same elements gives 0. This way, since string s</span></span><br><span class="line"><span class="comment">and t basically has pairs of repeating characters except one, the unique element will XOR</span></span><br><span class="line"><span class="comment">with 0 and give us it&#x27;s ASCII code. The only thing we need to take care of is to now shift it</span></span><br><span class="line"><span class="comment">up by 26, so we add &#x27;a&#x27; and convert it to char.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">char</span> <span class="title function_">findTheDifference</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">xor</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c: s.toCharArray())</span><br><span class="line">        xor ^= c-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c: t.toCharArray())</span><br><span class="line">        xor ^= c-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">char</span>)(xor+<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Nth-Digit"><a href="#Nth-Digit" class="headerlink" title="Nth Digit"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/nth-digit/">Nth Digit</a><a name="nth-digit"></a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">Notice that # of digits between 0-9 is 1*9, 10-99 is 2*90, 100-999 is 3*900. If we generalize</span></span><br><span class="line"><span class="comment">it, it is exactly equal to 9 * (num of digits in the number) * 10^&#123;# of digits - 1&#125;.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findNthDigit</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">10</span>)</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pow</span> <span class="operator">=</span> <span class="number">1</span>;				<span class="comment">// First we need to figure out how many digits there are</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">upperBound</span> <span class="operator">=</span> <span class="number">9</span>;		<span class="comment">// in the number.</span></span><br><span class="line">    <span class="keyword">while</span> (n &gt; upperBound)&#123;</span><br><span class="line">        n -= upperBound;		<span class="comment">// If n is a two digit number, subtract the 9 single digit</span></span><br><span class="line">        ++pow;					<span class="comment">// numbers, if 3 digit, subtract the first 189 digits.</span></span><br><span class="line">        upperBound = (<span class="type">long</span>)Math.pow(<span class="number">10</span>, pow-<span class="number">1</span>) * pow * <span class="number">9</span>;</span><br><span class="line">    &#125;							<span class="comment">// pow allows us to track how many digits there are in num.</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> (<span class="type">int</span>)Math.pow(<span class="number">10</span>,pow-<span class="number">1</span>) + (n-<span class="number">1</span>)/pow;		<span class="comment">// Calculate which number we want</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">position</span> <span class="operator">=</span> pow - <span class="number">1</span> - (n-<span class="number">1</span>) % pow;				<span class="comment">// Calculate which index we want</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; position; i++)					<span class="comment">// Divide num that many times</span></span><br><span class="line">        num /= <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> num % <span class="number">10</span>;									<span class="comment">// num % 10 gives us that digit.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Sum-of-Left-Leaves"><a href="#Sum-of-Left-Leaves" class="headerlink" title="Sum of Left Leaves"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/sum-of-left-leaves/">Sum of Left Leaves</a><a name="sum-of-left-leaves"></a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>)		<span class="comment">// Empty tree, therefore total is 0.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;			<span class="comment">// Initialize sum.</span></span><br><span class="line">    <span class="comment">// Look ahead and check. If left is not null but left is a leaf, then sum is the value of the left leaf.</span></span><br><span class="line">    <span class="comment">// But if left is null or left is an inner node, then we need to explore it, so sum is whatever the subtree from the left node returns.</span></span><br><span class="line">    <span class="keyword">if</span> (root.left != <span class="literal">null</span> &amp;&amp; root.left.left == <span class="literal">null</span> &amp;&amp; root.left.right == <span class="literal">null</span>)</span><br><span class="line">        sum = root.left.val;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        sum = sumOfLeftLeaves(root.left);</span><br><span class="line">    <span class="comment">// We computed the sum of the left side. Now we need to traverse the right side and fetch</span></span><br><span class="line">    <span class="comment">// the sum, so total sum is sum of the left side as computed above + sum returned by</span></span><br><span class="line">    <span class="comment">// traversing the right side.</span></span><br><span class="line">    <span class="keyword">return</span> sum + sumOfLeftLeaves(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Longest-Palindrome"><a href="#Longest-Palindrome" class="headerlink" title="Longest Palindrome"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/longest-palindrome/">Longest Palindrome</a><a name="longest-palindrome"></a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] freq = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">128</span>];		<span class="comment">// To record the frequency of each char</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c: s.toCharArray())</span><br><span class="line">        freq[c]++;					<span class="comment">// Increment count by 1 for each character observed</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;					<span class="comment">// length of the longest palindrome</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isOdd</span> <span class="operator">=</span> <span class="literal">false</span>;			<span class="comment">// Check if our palindrome length is odd</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">128</span>; i++)&#123;	<span class="comment">// Go through each character&#x27;s index</span></span><br><span class="line">        <span class="keyword">if</span> (freq[i] != <span class="number">0</span>)&#123;			<span class="comment">// Only if it has been observed atleast once</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> freq[i];		<span class="comment">// Store it&#x27;s frequency</span></span><br><span class="line">            <span class="type">int</span> used;				<span class="comment">// Record how many of it&#x27;s occurrences we will use</span></span><br><span class="line">            <span class="keyword">if</span> (val % <span class="number">2</span> == <span class="number">0</span>)		<span class="comment">// If a perfect multiple of 2, we will use all</span></span><br><span class="line">                used = val;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                used = val-<span class="number">1</span>;		<span class="comment">// If odd occurrences, then the max we can use to form a</span></span><br><span class="line">                isOdd = <span class="literal">true</span>;		<span class="comment">// valid palindrome is val-1. It also tells us that the</span></span><br><span class="line">            &#125;						<span class="comment">// palindrome is going to be of odd length.</span></span><br><span class="line">            len += used;			<span class="comment">// Finally, increment length by the number of chars used</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isOdd)						<span class="comment">// If length is odd, we can always insert any single</span></span><br><span class="line">        <span class="keyword">return</span> len+<span class="number">1</span>;				<span class="comment">// character in the middle to keep the palindrome valid.</span></span><br><span class="line">    <span class="keyword">return</span> len;						<span class="comment">// If the length is even, then we can&#x27;t do anything.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Fizz-Buzz"><a href="#Fizz-Buzz" class="headerlink" title="Fizz Buzz"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/fizz-buzz/">Fizz Buzz</a><a name="fizz-buzz"></a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;String&gt; <span class="title function_">fizzBuzz</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    List&lt;String&gt; nums = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; ++i)&#123;				<span class="comment">// Loop from 1 to n</span></span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">15</span> == <span class="number">0</span>)						<span class="comment">// If i divisible by 15, add &quot;FizzBuzz&quot;</span></span><br><span class="line">            nums.add(<span class="string">&quot;FizzBuzz&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (i % <span class="number">5</span> == <span class="number">0</span>)					<span class="comment">// i&#x27;s not a multiple of 15, check if it&#x27;s a</span></span><br><span class="line">            nums.add(<span class="string">&quot;Buzz&quot;</span>);					<span class="comment">// multiple of 5. If so, add &quot;Buzz&quot;</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">0</span>)					<span class="comment">// i&#x27;s not a multiple of 5, check if it&#x27;s a</span></span><br><span class="line">            nums.add(<span class="string">&quot;Fizz&quot;</span>);					<span class="comment">// multiple of 3, if so, add &quot;Fizz&quot;</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            nums.add(i+<span class="string">&quot;&quot;</span>);						<span class="comment">// Otherwise, just add the String type of the</span></span><br><span class="line">    &#125;											<span class="comment">// number</span></span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Third-maximum-Number"><a href="#Third-maximum-Number" class="headerlink" title="Third maximum Number"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/third-maximum-number/">Third maximum Number</a><a name="third-maximum-number"></a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">thirdMax</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>)		<span class="comment">// Empty array</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">1</span>)		<span class="comment">// Size 1 array</span></span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">2</span>)		<span class="comment">// Size 2 array, check between 0th element or 1st element</span></span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>] &gt; nums[<span class="number">1</span>] ? nums[<span class="number">0</span>] : nums[<span class="number">1</span>];</span><br><span class="line">    <span class="type">long</span> <span class="variable">firstMax</span> <span class="operator">=</span> Long.MIN_VALUE;		<span class="comment">// Lowest values for all three</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">secondMax</span> <span class="operator">=</span> Long.MIN_VALUE;</span><br><span class="line">    <span class="type">long</span> <span class="variable">thirdMax</span> <span class="operator">=</span> Long.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i: nums)&#123;					<span class="comment">// For each number in the array</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; firstMax)&#123;				<span class="comment">// If num &gt; than the largest, then old largest</span></span><br><span class="line">            thirdMax = secondMax;		<span class="comment">// becomes second largest and second largest becomes</span></span><br><span class="line">            secondMax = firstMax;		<span class="comment">// first largest, then update the largest.</span></span><br><span class="line">            firstMax = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; secondMax &amp;&amp; i != firstMax)&#123;	<span class="comment">// If num &gt; second and num is not is the</span></span><br><span class="line">            thirdMax = secondMax;					<span class="comment">// same as first, first largets becomes</span></span><br><span class="line">            secondMax = i;							<span class="comment">// second largest and update the second</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; thirdMax &amp;&amp; i != secondMax &amp;&amp; i != firstMax) <span class="comment">// // If num &gt; third, we</span></span><br><span class="line">            	thirdMax = i;						<span class="comment">// need to check that it is not the same</span></span><br><span class="line">    &#125;												<span class="comment">// as the first and second largest.</span></span><br><span class="line">    <span class="keyword">if</span> (thirdMax == Long.MIN_VALUE)					<span class="comment">// This check allows us to make sure that</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)firstMax;						<span class="comment">// we do indeed have a third max and is</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>)thirdMax;							<span class="comment">// not what we initialized initially.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Add-Two-Strings"><a href="#Add-Two-Strings" class="headerlink" title="Add Two Strings"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/add-strings/">Add Two Strings</a><a name="add-two-strings"></a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">addStrings</span><span class="params">(String num1, String num2)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (num1.equals(<span class="string">&quot;0&quot;</span>))</span><br><span class="line">        <span class="keyword">return</span> num2;</span><br><span class="line">    <span class="keyword">if</span> (num2.equals(<span class="string">&quot;0&quot;</span>))</span><br><span class="line">        <span class="keyword">return</span> num1;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** We use a char array to maintain the digit at each index. We want the array to be of</span></span><br><span class="line"><span class="comment">    the size of the largest string + 1 to handle carry bit if any at the end. We start</span></span><br><span class="line"><span class="comment">    adding each digit of the string from the end, and place it in it&#x27;s correct index at the</span></span><br><span class="line"><span class="comment">    end of the sum array. This way, we avoid reversing it and return the answer in constant</span></span><br><span class="line"><span class="comment">    time. Take care to convert the digit you compute by adding &#x27;0&#x27;. Lastly, if the carry bit</span></span><br><span class="line"><span class="comment">    is 1, we need to make the 0th index as 1, and return the string by using the sum array.</span></span><br><span class="line"><span class="comment">    If it&#x27;s not 1, then the sum array has a leading 0 which we don&#x27;t want. So we use Java&#x27;s</span></span><br><span class="line"><span class="comment">    String constructor that takes in the char array, startingIndex in that array and the</span></span><br><span class="line"><span class="comment">    number of elements of that array we want. So if the carry isn&#x27;t 1, we technically want</span></span><br><span class="line"><span class="comment">    everything from index 1 and # of elements = sum.length - 1 because we discard 0 index.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">char</span>[] sum = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1</span> + Math.max(num1.length(), num2.length())];</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> sum.length-<span class="number">1</span>, idx1 = num1.length()-<span class="number">1</span>, idx2 = num2.length()-<span class="number">1</span>, carry = <span class="number">0</span>, total = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> n1, n2;</span><br><span class="line">    <span class="keyword">while</span> (idx1 &gt;= <span class="number">0</span> || idx2 &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">        n1 = idx1 &lt; <span class="number">0</span> ? <span class="number">0</span> : num1.charAt(idx1--)-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        n2 = idx2 &lt; <span class="number">0</span> ? <span class="number">0</span> : num2.charAt(idx2--)-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        total = n1 + n2 + carry;</span><br><span class="line">        carry = total/<span class="number">10</span>;</span><br><span class="line">        sum[index--] = (<span class="type">char</span>)(total % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (carry == <span class="number">1</span>)&#123;</span><br><span class="line">        sum[<span class="number">0</span>] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(sum, <span class="number">1</span>, sum.length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Construct-Quad-Tree"><a href="#Construct-Quad-Tree" class="headerlink" title="Construct Quad Tree"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/construct-quad-tree/">Construct Quad Tree</a><a name="construct-quad-tree"></a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span>[][] grid;					<span class="comment">// Store it once, instead of passing it over &amp; over.</span></span><br><span class="line"><span class="keyword">public</span> Node <span class="title function_">construct</span><span class="params">(<span class="type">int</span>[][] _grid)</span> &#123;</span><br><span class="line">    grid = _grid;</span><br><span class="line">    <span class="keyword">return</span> helper(<span class="number">0</span>,<span class="number">0</span>,grid.length);		<span class="comment">// Ask helper to build the tree.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">helper</span><span class="params">(<span class="type">int</span> top, <span class="type">int</span> left, <span class="type">int</span> len)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">0</span>)						<span class="comment">// Base case: if empty grid or if we are done</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;					<span class="comment">// checking the full grid, return null</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> grid[top][left];			<span class="comment">// Get the topleft value, and start checking the box</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; ++i)&#123;		<span class="comment">// of len*len. If at any point, the value doesn&#x27;t</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; len; ++j)&#123;	<span class="comment">// match the key, we have found a breakpoint from</span></span><br><span class="line">            <span class="keyword">if</span> (grid[top+i][left+j] != key)&#123;	<span class="comment">// where we need to break the grid into four</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> len/<span class="number">2</span>;		<span class="comment">// grids, each of len = len/2. The topleft grid has</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="literal">true</span>, <span class="literal">false</span>, 	<span class="comment">// the same top and left point, the topright</span></span><br><span class="line">                                helper(top,left, offset),	<span class="comment">// grid has left point shifted to</span></span><br><span class="line">                                helper(top, left + offset, offset),	<span class="comment">// the right by offset.</span></span><br><span class="line">                                helper(top+offset, left, offset),	<span class="comment">// The bottom left grid</span></span><br><span class="line">                                helper(top+offset, left+offset, offset));	<span class="comment">// is shifted</span></span><br><span class="line">            &#125;	<span class="comment">// downwards by offset with the same left point. The bottom right grid will</span></span><br><span class="line">        &#125;		<span class="comment">// have an index where it&#x27;s top is shifted down by len/2 and left by left/2.</span></span><br><span class="line">    &#125;			<span class="comment">// We know that the node will have a value = true if 1 else false and it won&#x27;t be a leaf, so true, false, topleft, topright, bottomleft, bottomright.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Node</span>(key == <span class="number">1</span>, <span class="literal">true</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>);	<span class="comment">// Everything passed, so we return a new Node whose value is true if key is 1, else false and it will be a leaf, with</span></span><br><span class="line"><span class="comment">// no children, so 4 nulls.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="N-ary-Tree-Level-Order-Traversal"><a href="#N-ary-Tree-Level-Order-Traversal" class="headerlink" title="N-ary Tree Level Order Traversal"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/n-ary-tree-level-order-traversal/">N-ary Tree Level Order Traversal</a><a name="n-ary-tree-level-order-traversal"></a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();	<span class="comment">// Result list</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>)								<span class="comment">// If root is null, return empty list.</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    Queue&lt;Node&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();				<span class="comment">// BFS Queue. Add the root.</span></span><br><span class="line">    q.add(root);</span><br><span class="line">    <span class="keyword">while</span> (!q.isEmpty())&#123;							<span class="comment">// While q isn&#x27;t empty</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> q.size();						<span class="comment">// Check how many elements in that level</span></span><br><span class="line">        List&lt;Integer&gt; level = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(size);<span class="comment">// level list to store elements.</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)&#123;				<span class="comment">// Remove each node for whatever the size</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">n</span> <span class="operator">=</span> q.poll();						<span class="comment">// Add that node&#x27;s value and add all of</span></span><br><span class="line">            level.add(n.val);						<span class="comment">// its children to the queue.</span></span><br><span class="line">            <span class="keyword">for</span> (Node child: n.children)</span><br><span class="line">                q.add(child);</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(level);								<span class="comment">// Add the level array to the result</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;										<span class="comment">// Return the result list.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Number-of-Segments-in-a-String"><a href="#Number-of-Segments-in-a-String" class="headerlink" title="Number of Segments in a String"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/number-of-segments-in-a-string/">Number of Segments in a String</a><a name="number-of-segments-in-a-string"></a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countSegments</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s.length() == <span class="number">0</span>)					<span class="comment">// Empty String</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">segments</span> <span class="operator">=</span> <span class="number">0</span>;						<span class="comment">// Record segments</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> <span class="variable">prev</span> <span class="operator">=</span> s.charAt(<span class="number">0</span>);				<span class="comment">// We will compare adjacent characters.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; s.length(); ++i)&#123;	<span class="comment">// Start looking at chars from index 0</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">curr</span> <span class="operator">=</span> s.charAt(i);			<span class="comment">// Get the current char</span></span><br><span class="line">        <span class="keyword">if</span> (prev != <span class="string">&#x27; &#x27;</span> &amp;&amp; curr == <span class="string">&#x27; &#x27;</span>)		<span class="comment">// If previous char wasn&#x27;t a space but the</span></span><br><span class="line">            ++segments;						<span class="comment">// current char is, we found a segment.</span></span><br><span class="line">        prev = curr;						<span class="comment">// Make previous = current for next iteration</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">This line is important. If prev was an empty space, that means that all we have been looking</span></span><br><span class="line"><span class="comment">at was empty spaces towards the end. So return whatever segments we found in the beginning</span></span><br><span class="line"><span class="comment">of the string. But if prev wasn&#x27;t a space, that means the char next to prev might have been</span></span><br><span class="line"><span class="comment">an empty space or just a normal character. In any case, we would want to include that last</span></span><br><span class="line"><span class="comment">segment, so we return segment+1.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">return</span> prev == <span class="string">&#x27; &#x27;</span> ? segments : segments+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Binary-Tree-Level-Order-Traversal"><a href="#Binary-Tree-Level-Order-Traversal" class="headerlink" title="Binary Tree Level Order Traversal"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/binary-tree-level-order-traversal/">Binary Tree Level Order Traversal</a><a name="binary-tree-level-order-traversal"></a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>)						<span class="comment">// Empty Tree</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();	<span class="comment">// BFS Queue</span></span><br><span class="line">    q.add(root);</span><br><span class="line">    <span class="keyword">while</span> (!q.isEmpty())&#123;					<span class="comment">// While we have something to process</span></span><br><span class="line">        List&lt;Integer&gt; level = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> q.size();				<span class="comment">// Check how many elements at the current level</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> q.poll();		<span class="comment">// Remove one element each time</span></span><br><span class="line">            <span class="keyword">if</span> (node != <span class="literal">null</span>)&#123;				<span class="comment">// If not null, add it&#x27;s val to the level list,</span></span><br><span class="line">                level.add(node.val);		<span class="comment">// and it&#x27;s left and right children to the queue</span></span><br><span class="line">                q.add(node.left);			<span class="comment">// to process in order</span></span><br><span class="line">                q.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!level.isEmpty())				<span class="comment">// If level list wasn&#x27;t empty,</span></span><br><span class="line">            result.add(level);				<span class="comment">// add it to the result list.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Path-Sum-III"><a href="#Path-Sum-III" class="headerlink" title="Path Sum III"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/path-sum-iii/submissions/">Path Sum III</a><a name="path-sum-iii"></a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;Integer, Integer&gt; sumToWays;			<span class="comment">// Record how many ways there are to form sum</span></span><br><span class="line"><span class="type">int</span> ways;										<span class="comment">// Total number of ways.</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">    sumToWays = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    ways = <span class="number">0</span>;</span><br><span class="line">    sumToWays.put(<span class="number">0</span>,<span class="number">1</span>);							<span class="comment">// 1 way to form a sum of 0.</span></span><br><span class="line">    helper(root, <span class="number">0</span>, sum);</span><br><span class="line">    <span class="keyword">return</span> ways;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">The idea here is as follows. Start with the root node, and keep a running total. We maintain</span></span><br><span class="line"><span class="comment">how many ways there to form a running sum. Then we check how many ways there are to form</span></span><br><span class="line"><span class="comment">(running sum) - (sum we are looking for). If there is a way to form it, then we increase the</span></span><br><span class="line"><span class="comment">number of ways to form sum. We then have to update the map to record how many ways can the</span></span><br><span class="line"><span class="comment">running sum be formed. If it&#x27;s something we could form before, increment it, or else set it</span></span><br><span class="line"><span class="comment">to 1. Now, traverse the left side and then the right side. In the end, for each time we</span></span><br><span class="line"><span class="comment">incremented the count for a running sum, we need to decrement it because we are backtracking.</span></span><br><span class="line"><span class="comment">We are first going down, incrementing the count for runningSum, then we move up and decrement</span></span><br><span class="line"><span class="comment">it by 1 for each time we observed it. This is to maintain the Pre-Order traversal.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">helper</span><span class="params">(TreeNode node, <span class="type">int</span> runningSum, <span class="type">int</span> sum)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    runningSum += node.val;</span><br><span class="line">    ways += sumToWays.getOrDefault(runningSum-sum, <span class="number">0</span>);</span><br><span class="line">    sumToWays.put(runningSum, sumToWays.getOrDefault(runningSum, <span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    helper(node.left, runningSum, sum);</span><br><span class="line">    helper(node.right, runningSum, sum);</span><br><span class="line"></span><br><span class="line">    sumToWays.put(runningSum, sumToWays.get(runningSum)-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Find-All-Anagrams-in-a-String"><a href="#Find-All-Anagrams-in-a-String" class="headerlink" title="Find All Anagrams in a String"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/find-all-anagrams-in-a-string/">Find All Anagrams in a String</a><a name="find-all-anagrams-in-a-string"></a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">findAnagrams</span><span class="params">(String s, String p)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>, end = <span class="number">0</span>, slen = s.length(), plen = p.length();</span><br><span class="line">    <span class="keyword">if</span> (slen == <span class="number">0</span> || slen &lt; plen || plen == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    <span class="type">int</span>[] freq = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];				<span class="comment">// Store the freq of chars in p</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c: p.toCharArray())</span><br><span class="line">        freq[c-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">    <span class="type">char</span>[] sArr = s.toCharArray();			<span class="comment">// Get the chars of the string s as an array</span></span><br><span class="line">    <span class="keyword">while</span> (end &lt; slen)&#123;						<span class="comment">// While everything is not processed</span></span><br><span class="line">        <span class="keyword">if</span> (--freq[sArr[end]-<span class="string">&#x27;a&#x27;</span>] &gt;= <span class="number">0</span>)		<span class="comment">// decrease the freq of the char at index end</span></span><br><span class="line">            plen--;							<span class="comment">// if it&#x27;s &gt; 0, then we matched something in p</span></span><br><span class="line">											<span class="comment">// so decrease plen by 1.</span></span><br><span class="line">        <span class="keyword">while</span> (plen == <span class="number">0</span>)&#123;					<span class="comment">// If plen goes to 0, we were able to match all</span></span><br><span class="line">            <span class="keyword">if</span> (end-start+<span class="number">1</span> == p.length())	<span class="comment">// chars of p. If length of the matched chars is</span></span><br><span class="line">                result.add(start);			<span class="comment">// equal to length p, we found a start point.</span></span><br><span class="line">            <span class="keyword">if</span> (freq[sArr[start]-<span class="string">&#x27;a&#x27;</span>] &gt;= <span class="number">0</span>)	<span class="comment">// Check if the freq of char at start index is</span></span><br><span class="line">                plen++;						<span class="comment">// &gt;= 0. If it is, shift the window to the right</span></span><br><span class="line">            ++freq[sArr[start++]-<span class="string">&#x27;a&#x27;</span>];		<span class="comment">// but first restore the frequency of the char</span></span><br><span class="line">        &#125;									<span class="comment">// at the index start.</span></span><br><span class="line"></span><br><span class="line">        end++;								<span class="comment">// Get ready to inspect the new element</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;							<span class="comment">// Return the answer.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Arranging-Coins"><a href="#Arranging-Coins" class="headerlink" title="Arranging Coins"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/arranging-coins/">Arranging Coins</a><a name="arranging-coins"></a></h3><p>The idea is as follows. Sum of first n numbers is given by $\frac{n^2+n}{2}$. We need to find $n$ such that sum of $n$ numbers is closest to the number of coins we have. That is, $\frac{n^2+n}{2} &#x3D; k$ where $k$ is the number of coins we have. So, everything boils down to solving the quadratic equation $n^2 + n - 2k &#x3D; 0$. We use the quadratic formula where for any quadratic equation $ax^2 -bx + c$ is solved substituting for $a$, $b$ and $c$ in $x &#x3D; \frac{-b \pm \sqrt{b^2 - 4ac}}{2}$. Here, $a$ and $b$ are always going to be 1, while $c$ is always going to be $2k$. Substitute those, and solve the equation.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">arrangeCoins</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">// return solveQuadratic(n);</span></span><br><span class="line">    <span class="keyword">return</span> iterative(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">solveQuadratic</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>)(Math.sqrt(<span class="number">1</span> + <span class="number">8</span>*(<span class="type">long</span>)n)-<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">iterative</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">used</span> <span class="operator">=</span> <span class="number">1</span>, level = <span class="number">0</span>;		<span class="comment">// Coins used, and level completed.</span></span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span>)&#123;					<span class="comment">// While coins left are greater than 0.</span></span><br><span class="line">        n-=used;					<span class="comment">// Calculcate remaining coins.</span></span><br><span class="line">        <span class="keyword">if</span> (n &gt; -<span class="number">1</span>)					<span class="comment">// If there are still some coins left,</span></span><br><span class="line">            ++level;				<span class="comment">// we were able to fill the level.</span></span><br><span class="line">        ++used;						<span class="comment">// Prepare used for the next level, which is plus 1.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> level;					<span class="comment">// Return level</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Hamming-Distance"><a href="#Hamming-Distance" class="headerlink" title="Hamming Distance"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/hamming-distance/">Hamming Distance</a><a name="hamming-distance"></a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hammingDistance</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">diff</span> <span class="operator">=</span> <span class="number">0</span>;				<span class="comment">// Track differences</span></span><br><span class="line">    <span class="keyword">while</span> (x != <span class="number">0</span> || y != <span class="number">0</span>) &#123;	<span class="comment">// While both of them aren&#x27;t 0</span></span><br><span class="line">        <span class="keyword">if</span> (x % <span class="number">2</span> != y % <span class="number">2</span>)		<span class="comment">// Check the bit of x and y by mod 2. If they are unequal</span></span><br><span class="line">            diff++;				<span class="comment">// increment difference.</span></span><br><span class="line">        x /= <span class="number">2</span>;					<span class="comment">// Divide x and y by 2.</span></span><br><span class="line">        y /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> diff;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="String-Compression"><a href="#String-Compression" class="headerlink" title="String Compression"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/string-compression/">String Compression</a><a name="string-compression"></a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compress</span><span class="params">(<span class="type">char</span>[] chars)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> chars.length;			<span class="comment">// No need to reverse array of length 0 or 1</span></span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    <span class="type">int</span> <span class="variable">arrayIndex</span> <span class="operator">=</span> <span class="number">0</span>;				<span class="comment">// To maintain the length of new array.</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;					<span class="comment">// start index</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> <span class="number">0</span>;					<span class="comment">// end index</span></span><br><span class="line">    <span class="keyword">while</span> (end &lt; len)&#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">first</span> <span class="operator">=</span> chars[start];	<span class="comment">// Record the char we are looking at.</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;				<span class="comment">// count is 0.</span></span><br><span class="line">        <span class="keyword">while</span> (end &lt; len &amp;&amp; chars[end] == first)&#123;	<span class="comment">// while the char is the same</span></span><br><span class="line">            ++end;					<span class="comment">// increment end to check next char</span></span><br><span class="line">            ++count;				<span class="comment">// and increment the count.</span></span><br><span class="line">        &#125;</span><br><span class="line">        start = end;				<span class="comment">// shift start to end to check next sequence of chars</span></span><br><span class="line">        chars[arrayIndex++] = first;	<span class="comment">// our arrayIndex points to to the new array&#x27;s </span></span><br><span class="line">        <span class="keyword">if</span> (count != <span class="number">1</span>)&#123;				<span class="comment">// indices. So copy the first char to arrayIndex.</span></span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">1</span> &amp;&amp; count &lt; <span class="number">10</span>)	<span class="comment">//Only if count isn&#x27;t 1, if count is less than 10</span></span><br><span class="line">                chars[arrayIndex++] = (<span class="type">char</span>)(count+<span class="string">&#x27;0&#x27;</span>);	<span class="comment">// then we simply convert count to char and write it next to the char we just overwrote.</span></span><br><span class="line">            <span class="keyword">else</span>						<span class="comment">// Otherwise, it has many digits. So convert it to</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">char</span> c: String.valueOf(count).toCharArray())&#123;	<span class="comment">// string and add all it&#x27;s digit to the array one by one while increment arrayIndex.</span></span><br><span class="line">                    chars[arrayIndex++] = c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arrayIndex;			<span class="comment">// Wherever arrayIndex is, is the new length for the array.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Number-of-Boomerangs"><a href="#Number-of-Boomerangs" class="headerlink" title="Number of Boomerangs"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/number-of-boomerangs/">Number of Boomerangs</a><a name="number-of-boomerangs"></a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numberOfBoomerangs</span><span class="params">(<span class="type">int</span>[][] points)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">boomerangs</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    HashMap&lt;Double, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();	<span class="comment">// To record points with same dist</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>[] i: points)&#123;		<span class="comment">// Compute distance between one point and every other.</span></span><br><span class="line">        map.clear()				<span class="comment">// clear map before each relative distance computation</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] j: points)&#123;	<span class="comment">// Compute distance with other points</span></span><br><span class="line">            <span class="keyword">if</span> (i == j)			<span class="comment">// Don&#x27;t compare the same two points.</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">double</span> <span class="variable">dist</span> <span class="operator">=</span> Math.sqrt(Math.pow(i[<span class="number">0</span>]-j[<span class="number">0</span>],<span class="number">2</span>) + Math.pow(i[<span class="number">1</span>]-j[<span class="number">1</span>],<span class="number">2</span>));</span><br><span class="line">            <span class="type">int</span> <span class="variable">prevCount</span> <span class="operator">=</span> map.getOrDefault(dist, <span class="number">0</span>);	<span class="comment">// Check how many points are equidistant from point i.</span></span><br><span class="line">            boomerangs += prevCount * <span class="number">2</span>;	<span class="comment">//  Number of boomerangs = whatever pairs there were before times 2, because you can form twice the number of different orders.</span></span><br><span class="line">            map.put(dist, prevCount+<span class="number">1</span>);	<span class="comment">// Increase the count of points observed for that distance.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> boomerangs;	<span class="comment">// return number of boomerangs</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Find-All-Numbers-Disappeared-in-an-Array"><a href="#Find-All-Numbers-Disappeared-in-an-Array" class="headerlink" title="Find All Numbers Disappeared in an Array"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/">Find All Numbers Disappeared in an Array</a><a name="find-all-numbers-disappeared-in-an-array"></a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">The idea is simple. For each number in the array, since it&#x27;s gauranteed that that the values</span></span><br><span class="line"><span class="comment">lie are inclusive [1,n], we can look at the index value-1. So check that index, and mark</span></span><br><span class="line"><span class="comment">that value as negative. That is why I take the absolute value. Check value at that index, if</span></span><br><span class="line"><span class="comment">negative, it means we have visited it via some other duplicate value. But if it&#x27;s positive,</span></span><br><span class="line"><span class="comment">then we are seeing it for the first time, so make it&#x27;s value negative. Make a second pass.</span></span><br><span class="line"><span class="comment">For values that are still positive, that means those indices were never visited, hence left</span></span><br><span class="line"><span class="comment">positive. So add 1 to them and add it to the set. Eg:</span></span><br><span class="line"><span class="comment">	Given array a = [4,3,2,7,8,2,3,1],</span></span><br><span class="line"><span class="comment">1.	val = 4 =&gt; idx = 3 &amp; a[3] &gt; 0, therefore, a[3] *= -1</span></span><br><span class="line"><span class="comment">	a = [4,3,2,-7,8,2,3,1]</span></span><br><span class="line"><span class="comment">2.	val = 3 =&gt; idx = 2 &amp; a[2] &gt; 0, therefore a[2] *= -1</span></span><br><span class="line"><span class="comment">	a = [4,3,-2,-7,8,2,3,1]</span></span><br><span class="line"><span class="comment">3.	val = -2 =&gt; idx = abs(-2)-1 = 1 &amp; a[1] &gt; 0, therefore a[1] *= -1</span></span><br><span class="line"><span class="comment">	a = [4,-3,-2,-7,8,2,3,1]</span></span><br><span class="line"><span class="comment">4.	val = -7 =&gt; idx = abs(-7)-1 = 6 &amp; a[6] &gt; 0, therfore a[6] *= -1</span></span><br><span class="line"><span class="comment">	a = [4,-3,-2,-7,8,2,-3,1]</span></span><br><span class="line"><span class="comment">5.	val = 8 =&gt; idx = abs(8)-1 = 7 &amp; a[7] &gt; 0, therfore a[7] *= -1</span></span><br><span class="line"><span class="comment">	a = [4,-3,-2,-7,8,2,-3,-1]</span></span><br><span class="line"><span class="comment">6.	val = 2 =&gt; idx = 1 but a[2] &lt; 0. No change.</span></span><br><span class="line"><span class="comment">7.	val = -3 =&gt; idx = abs(-3)-1 = 2 but a[2] &lt; 0. No change.</span></span><br><span class="line"><span class="comment">8.	val = -1 =&gt; idx = abs(-1)-1 = 0 &amp; a[0] &gt; 0, therefore a[0] *= -1</span></span><br><span class="line"><span class="comment">	a = [-4,-3,-2,-7,8,2,-3,-1]</span></span><br><span class="line"><span class="comment">Observation: Notice index 4 and 5 have positive values, since those values were never</span></span><br><span class="line"><span class="comment">encountered, so the values at those indexes never became negative. Hence missing values are</span></span><br><span class="line"><span class="comment">5 and 6.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">findDisappearedNumbers</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i: nums)&#123;				<span class="comment">// For each number in the array</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> Math.abs(i)-<span class="number">1</span>;	<span class="comment">// Look at the index that the number corresponds to</span></span><br><span class="line">        <span class="keyword">if</span> (nums[idx] &gt; <span class="number">0</span>)			<span class="comment">// If val is -ve, then it means we have encountered it.</span></span><br><span class="line">            nums[idx] *= -<span class="number">1</span>;  		<span class="comment">// If not, make it -ve.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; ++i)</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>)			<span class="comment">// Make another pass through the array, and the indices</span></span><br><span class="line">            result.add(i+<span class="number">1</span>);		<span class="comment">// where value was positive, index+1 was missing from</span></span><br><span class="line">    <span class="keyword">return</span> result;					<span class="comment">// the array</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Assign-Cookies"><a href="#Assign-Cookies" class="headerlink" title="Assign Cookies"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/assign-cookies/">Assign Cookies</a><a name="assign-cookies"></a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">We will employ a greedy algorithm where we first try to content children whose requirements</span></span><br><span class="line"><span class="comment">are small. We do this by sorting both the arrays, so we can match the child with least</span></span><br><span class="line"><span class="comment">requirement with the smallest cookie available.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findContentChildren</span><span class="params">(<span class="type">int</span>[] g, <span class="type">int</span>[] s)</span> &#123;</span><br><span class="line">    Arrays.sort(g);</span><br><span class="line">    Arrays.sort(s);</span><br><span class="line">    <span class="type">int</span> <span class="variable">satisfied</span> <span class="operator">=</span> <span class="number">0</span>, i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; g.length &amp;&amp; j &lt; s.length)&#123;	<span class="comment">// While children are left and we have cookies,</span></span><br><span class="line">        <span class="keyword">if</span> (s[j] &gt;= g[i])&#123;		<span class="comment">// Check if the cookie at index j &gt;= child i&#x27;s requirement</span></span><br><span class="line">            satisfied++;		<span class="comment">// If so, increment the number of content child and we will</span></span><br><span class="line">            i++;				<span class="comment">// process the next child.</span></span><br><span class="line">        &#125;						<span class="comment">// If cookie j &lt; child i&#x27;s demand, check the next cookie by</span></span><br><span class="line">        j++;					<span class="comment">// incrementing j. If cookie j &gt; child i&#x27;s demand, we will</span></span><br><span class="line">    &#125;							<span class="comment">// still need to increment j, hence outside the conditional.</span></span><br><span class="line">    <span class="keyword">return</span> satisfied;			<span class="comment">// Return number of satisfied children</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Poor-Pigs"><a href="#Poor-Pigs" class="headerlink" title="Poor Pigs"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/poor-pigs/">Poor Pigs</a><a name="poor-pigs"></a></h3><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/poor-pigs/discuss/94305/1-line-solution-with-detailed-problem-clarification-and-math-proof-(please-read-if-you-really-want-to-know-what-this-problem-means)">Link</a> to the solution explanation. This problem is phrased poorly and I had to read the comments by other users to understand what it required from me. The link I marked here explains the logic pretty good. But the simple logic is this: The number of rounds $r &#x3D; \frac{Total Test Time}{Minutes To Die} +1$. Each pig has chances of dying in each round or staying alive till the end, so we plus 1. Now given the number of rounds $r$ and the number of samples $s$, how many volunteers $v$ will you need? $r^v &#x3D; s$. Each round has some volunteers which in total at the end should be able to test out all the samples. Therefore, $v &#x3D;\log_rs$.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">poorPigs</span><span class="params">(<span class="type">int</span> buckets, <span class="type">int</span> minutesToDie, <span class="type">int</span> minutesToTest)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">base</span> <span class="operator">=</span> minutesToTest/minutesToDie+<span class="number">1</span>;		<span class="comment">// How many rounds can you perform?</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>)Math.ceil(Math.log(buckets)/Math.log(base));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Find-Pivot-Index"><a href="#Find-Pivot-Index" class="headerlink" title="Find Pivot Index"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/find-pivot-index/">Find Pivot Index</a><a name="find-pivot-index"></a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pivotIndex</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>, leftSum = <span class="number">0</span>;		<span class="comment">// We will test each index as a pivot by sliding it -&gt;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i: nums)				<span class="comment">// Precalculate the sum of the array</span></span><br><span class="line">        sum += i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; ++i)&#123;	<span class="comment">// Check if the sum of the leftSide of i is</span></span><br><span class="line">        <span class="keyword">if</span> (leftSum == sum - leftSum - nums[i])	<span class="comment">// equal to totalSum - leftSideSum - pivot</span></span><br><span class="line">            <span class="keyword">return</span> i;							<span class="comment">// which is i. If so, return i.</span></span><br><span class="line">        leftSum += nums[i];						<span class="comment">// Otherwise add nums[i] to the leftSum and</span></span><br><span class="line">    &#125;											<span class="comment">// slide pivot to the -&gt;.</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;								<span class="comment">// No pivot found. Return -1.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Squares-of-a-Sorted-Array"><a href="#Squares-of-a-Sorted-Array" class="headerlink" title="Squares of a Sorted Array"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/squares-of-a-sorted-array/">Squares of a Sorted Array</a><a name="squares-of-a-sorted-array"></a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] sortedSquares(<span class="type">int</span>[] A) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> A.length;		<span class="comment">// Length of array A</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> <span class="number">0</span>;			<span class="comment">// Pivot is the index where values goes from -ve to +ve.</span></span><br><span class="line">    <span class="keyword">while</span> (pivot &lt; len &amp;&amp; A[pivot] &lt; <span class="number">0</span>) <span class="comment">// While values are -ve.</span></span><br><span class="line">        ++pivot;			<span class="comment">// increment pivot. We exit when we find a positive.</span></span><br><span class="line">    <span class="type">int</span>[] squares = <span class="keyword">new</span> <span class="title class_">int</span>[len];	<span class="comment">// Result array</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;			<span class="comment">// Keeps track of where to where to put elements in result array</span></span><br><span class="line">    <span class="keyword">if</span> (pivot == <span class="number">0</span>)			<span class="comment">// pivot = 0 means pivot didn&#x27;t shift, there are only +ve values</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i: A)		<span class="comment">// So fill in the array with squares of numbers.</span></span><br><span class="line">            squares[index++] = i*i;</span><br><span class="line">    <span class="keyword">else</span>&#123;					<span class="comment">// Otherwise we have a negative somewhere.</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> pivot-<span class="number">1</span>;	<span class="comment">// So we will compare values left and right of the pivot</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> pivot;	<span class="comment">// and whichever&#x27;s smaller fills up the array first.</span></span><br><span class="line">        <span class="keyword">while</span> (left &gt; -<span class="number">1</span> &amp;&amp; right &lt; len)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">lsquare</span> <span class="operator">=</span> A[left] * A[left];</span><br><span class="line">            <span class="type">int</span> <span class="variable">rsquare</span> <span class="operator">=</span> A[right] * A[right];</span><br><span class="line">            <span class="keyword">if</span> (lsquare &lt; rsquare)&#123;		<span class="comment">// left &lt; right, so add left square. decrement left</span></span><br><span class="line">                squares[index++] = lsquare;</span><br><span class="line">                --left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (rsquare &lt; lsquare)&#123;	<span class="comment">// right &lt; left, add right square and increment.</span></span><br><span class="line">                squares[index++] = rsquare;</span><br><span class="line">                ++right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                squares[index++] = lsquare;	<span class="comment">// both are equal. add both square and</span></span><br><span class="line">                squares[index++] = rsquare;	<span class="comment">// decrement left, increment right.</span></span><br><span class="line">                --left;						<span class="comment">// Continue doing this until we hit either end</span></span><br><span class="line">                ++right;					<span class="comment">// of the array.</span></span><br><span class="line">            &#125;								<span class="comment">// In the end we need to check if elements on</span></span><br><span class="line">        &#125;									<span class="comment">// either side are left to be filled in.</span></span><br><span class="line">        <span class="keyword">while</span> (left &gt; -<span class="number">1</span>)					<span class="comment">// Left side elements remain, so fill their</span></span><br><span class="line">            squares[index++] = A[left] * A[left--]; <span class="comment">// squares one by one till none left.</span></span><br><span class="line">        <span class="keyword">while</span> (right &lt; len)					<span class="comment">// Right side elements remain, so fill their</span></span><br><span class="line">            squares[index++] = A[right] * A[right++];	<span class="comment">// squares in</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> squares;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Repeated-Substring-Pattern"><a href="#Repeated-Substring-Pattern" class="headerlink" title="Repeated Substring Pattern"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/repeated-substring-pattern/submissions/">Repeated Substring Pattern</a><a name="repeated-substring-pattern"></a></h3><p>We use the <a target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/kmp-algorithm-for-pattern-searching/">KMP Algorithm</a> that allows us to match a string ‘s’ with another string ‘p’ to find the longest sequence of characters in ‘s’ that match ‘p’. We can use a Naive Pattern match where we start from the beginning of the string and start comparing the characters of ‘s’ with ‘p’. Initially, we keep the partition at index 0. If the character’s match, we move partition to the right by 1 till we get to the end of the string. If something doesn’t match, we don’t move the partition but look at the next character to match. In the end, wherever the partition is, that’s our longest length we could match with string ‘p’. The complexity of that is <i>O(len(p)(len(s)-len(p)+1))</i>.</p>
<p>KMP fixes it by skipping characters that we know already match. In this problem, we aren’t matching with any other string but itself. So, we start from index 1 of the string and compare it from the beginning. If they match, we increase j by 1, note it down in lps array and then increase i by 1 to check the next character. j basically measures the longest chain of characters we were able to match. If we couldn’t match character at index i and if streak was greater than 0, then our new streak becomes whatever it was in the previous round of matching characters. If the streak is 0, then we simply note down at index i in our lps array 0, meaning longest length measured upto index i was 0. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">repeatedSubstringPattern</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxLength</span> <span class="operator">=</span> lps(s);</span><br><span class="line">        <span class="keyword">return</span> maxLength &gt; <span class="number">0</span> &amp;&amp; s.length() % (s.length() - maxLength) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">lps</span><span class="params">(String s)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line">    <span class="type">int</span>[] lps = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;		<span class="comment">// To match the string with itself.</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; len)&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i) == s.charAt(j))&#123;	<span class="comment">// if the chars match</span></span><br><span class="line">            lps[i] = ++j;					<span class="comment">// we record that # of matches at index i was</span></span><br><span class="line">            ++i;							<span class="comment">// 1+j and increment i to check next character</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;								<span class="comment">// character did not match</span></span><br><span class="line">            <span class="keyword">if</span> (j &gt; <span class="number">0</span>)						<span class="comment">// If our matching streak &gt; 0</span></span><br><span class="line">                j = lps[j-<span class="number">1</span>];				<span class="comment">// our new streak becomes the previous round&#x27;s streak</span></span><br><span class="line">            <span class="keyword">else</span>							<span class="comment">// Otherwise, streak is already 0.</span></span><br><span class="line">                lps[i++] = <span class="number">0</span>;				<span class="comment">// So we record that # of matches made at i is 0</span></span><br><span class="line">        &#125;									<span class="comment">// We increment i to check next index.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lps[len-<span class="number">1</span>];						<span class="comment">// Longest prefix length that was also a suffix</span></span><br><span class="line">&#125;											<span class="comment">// is whatever was recorded at the end of array.</span></span><br></pre></td></tr></table></figure>



<h3 id="Island-Perimeter"><a href="#Island-Perimeter" class="headerlink" title="Island Perimeter"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/island-perimeter/">Island Perimeter</a><a name="island-perimeter"></a></h3><p>The idea is simple. Count the number of cells with value 1 which denotes the land. Check towards the left and up to that cell and check if it shares any edge with another cell with value 1. If it does record that. In the end, the formula for perimeter is 4 * (the number of land cells) - 2 * (overlapping edges).</p>
<p><strong>Reasoning:</strong> Perimeter of a square is 4 times the length of it’s side. Here all squares are of length 1. So total perimeter is 4*(number of cells with value &#x3D; 1). But we also need to account the edges that are common between two adjacent land cells. If one square shares an edge with another, we just lost one side from both the square, resulting in a loss of two sides. Therefore, we need to subtract twice the number of overlapping edges from the total perimeter to get  the total perimeter. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">islandPerimeter</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">land</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">overlap</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> <span class="number">0</span>; row &lt; grid.length; ++row)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> <span class="number">0</span>; col &lt; grid[<span class="number">0</span>].length; ++col)&#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[row][col] == <span class="number">1</span>)&#123;</span><br><span class="line">                ++land;</span><br><span class="line">                <span class="keyword">if</span> (row-<span class="number">1</span> &gt; -<span class="number">1</span> &amp;&amp; grid[row-<span class="number">1</span>][col] == <span class="number">1</span>)	<span class="comment">// Check above the current cell.</span></span><br><span class="line">                    ++overlap;		<span class="comment">// If it&#x27;s a land, we need to record one overlap.</span></span><br><span class="line">                <span class="keyword">if</span> (col-<span class="number">1</span> &gt; -<span class="number">1</span> &amp;&amp; grid[row][col-<span class="number">1</span>] == <span class="number">1</span>)	<span class="comment">// Similarly, check to the left.</span></span><br><span class="line">                    ++overlap;		<span class="comment">// If it&#x27;s a land, we need to increment overlap</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span>*land - <span class="number">2</span>*overlap;		<span class="comment">// Check the reasoning above.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Number-Complement"><a href="#Number-Complement" class="headerlink" title="Number Complement"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/number-complement/">Number Complement</a><a name="number-complement"></a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findComplement</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pow2</span> <span class="operator">=</span> <span class="number">1</span>;				<span class="comment">// Easily keep track of power of 2.</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">comp</span> <span class="operator">=</span> <span class="number">0</span>;				<span class="comment">// Complement number</span></span><br><span class="line">    <span class="keyword">while</span> (num != <span class="number">0</span>)&#123;			<span class="comment">// Since num gets divided by 2, it will be 0 in the end.</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">bit</span> <span class="operator">=</span> num % <span class="number">2</span> == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;	<span class="comment">// If bit is 0 then complement is 1 &amp; vice versa.</span></span><br><span class="line">        comp += bit * pow2;		<span class="comment">// Multiply it by the appropriate power of 2 and add to comp</span></span><br><span class="line">        pow2 *= <span class="number">2</span>;				<span class="comment">// Update power of 2 for next iteration.</span></span><br><span class="line">        num /= <span class="number">2</span>;				<span class="comment">// Divide num by 2 to get the next bit.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> comp;				<span class="comment">// Comp is now the complement.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Binary-Watch"><a href="#Binary-Watch" class="headerlink" title="Binary Watch"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/binary-watch/">Binary Watch</a><a name="binary-watch"></a></h3><p>The idea is as follows. We have 10 lights. First 4 represent hours. Namely 1, 2, 4 and 8, which are the first four powers of 2. The next 6 lights, represent minutes. Those are 1, 2, 4, 8, 16 and 32. These are powers of 2 from 0-5. So if we iterate from 1 to 9, powers of numbers 1-3 gives us hours and powers of numbers 4-9 minus 4 gives us minutes. So, if we have, let’s say 2 lights, we need to find every combination of 2 lights. So in our helper function, we iterate from 1-9 to check every hour and minute combination. We also need to keep a track of the lights that we used, so we don’t use the same light again. If hours are &gt; 11 or minutes are &gt; 59, we have an invalid time and we can abort. If the number of lights are 0, that means we found a valid time and we should add it to the result. Now, if the lights are not 0, then we need to check every possible combination from the last light used to 9. If i &lt; 4, then we are looking at an hourly combination, otherwise it’s a minute combination. So we recurse with updated lights used, decrease the numOfLights since we used one, update respective hours or minutes until we hit base case.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; result;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;String&gt; <span class="title function_">readBinaryWatch</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    helper(<span class="number">0</span>, num, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">helper</span><span class="params">(<span class="type">int</span> lightsUsed, <span class="type">int</span> numOfLights, <span class="type">int</span> hrs, <span class="type">int</span> min)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hrs &gt; <span class="number">11</span> || min &gt; <span class="number">59</span>)		<span class="comment">// Base case. Invalid time</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (numOfLights == <span class="number">0</span>)&#123;			<span class="comment">// All lights used, so add time to the list.</span></span><br><span class="line">        result.add(hrs + <span class="string">&quot;:&quot;</span> + (min &lt; <span class="number">10</span> ? <span class="string">&quot;0&quot;</span> + min : min));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> lightsUsed; i &lt; <span class="number">10</span>; i++)&#123;	<span class="comment">// Otherwise start recursing from number of prev</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">4</span>)							<span class="comment">// light used. i &lt; 4 means hours</span></span><br><span class="line">            helper(i+<span class="number">1</span>, numOfLights-<span class="number">1</span>, hrs + (<span class="type">int</span>)Math.pow(<span class="number">2</span>, i), min);</span><br><span class="line">        <span class="keyword">else</span>								<span class="comment">// i = [4,9] means minute. So recurse.</span></span><br><span class="line">            helper(i+<span class="number">1</span>, numOfLights-<span class="number">1</span>, hrs, min + (<span class="type">int</span>)Math.pow(<span class="number">2</span>,i-<span class="number">4</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Minimum-Moves-to-Equal-Array-Elements"><a href="#Minimum-Moves-to-Equal-Array-Elements" class="headerlink" title="Minimum Moves to Equal Array Elements"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/minimum-moves-to-equal-array-elements/">Minimum Moves to Equal Array Elements</a><a name="minimum-moves-to-equal-array-elements"></a></h3><p>This was an interesting problem. But after working out a few examples by hand, you can notice that it is always a question of bringing the minimum element in par with everyone. So if you know the minimum of the array, we can check how many steps it will take to bring the minimum in par with other element by calculating the distance between them. For example,</p>
<blockquote>
<p>Let the array be [1,2,3]</p>
<p>We can observe that the minimum here is 1. Let us list down all steps to make all elements equal.</p>
<ol>
<li>[2,2,4], Keeping the second element fixed. Notice that distance between the element where 1 was and where 3 was is till the same.</li>
<li>[3,3,4], Keeping the last element fixed.</li>
<li>[4,4,4], Keeping last element fixed.</li>
</ol>
<p>Here, we first tried to make 1 equal to it’s neighbor, which required us 1 step. Now, once it becomes equal to 1, the problem is how to make the last element in the original array, which is 3 equal to 1. It requires 2 steps, resulting in a total of of 3. The reason is that the moment you decide to increment the minimum element to match the next element, you fix the neighboring element and have to increment everything else. This will make the minimum and its neighbor the same, but it will also keep the distance between the minimum and all other elements the same because we just incremented everything. </p>
<p>So, the total number of moves required is the distance between the elements of the array and the minimum.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minMoves</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i: nums)</span><br><span class="line">        <span class="keyword">if</span> (i &lt; min)</span><br><span class="line">            min = i;</span><br><span class="line">    <span class="type">int</span> <span class="variable">moves</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i: nums)</span><br><span class="line">        moves += i-min;</span><br><span class="line">    <span class="keyword">return</span> moves;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Now the above solution required two passes of the array. Can we do even better? Notice that in the end, all we are doing is finding the min and subtracting min from all the elements in the array. That means we are subtracting min <em>n</em> times where n is the length of the array. Why <em>n</em> times? Because there are <em>n</em> elements in the array. Shouldn’t it be <em>(n-1)</em> times? No, because the distance of the min from min is 0. So we need to subtract min from itself too, so <em>n</em> times. We can achieve this by first calculating the total of the array while simultaneously keeping track of the minimum. Once done, all we need to do is subtract min <em>n</em> times from the sum, which is equivalent to subtracting min from each element. This results in a much overall better algorithm, requiring only 1 pass of the array.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minMoves</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>, min = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i: nums)&#123;</span><br><span class="line">        sum += i;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; min)</span><br><span class="line">            min = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum - min*nums.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="License-Key-Formatting"><a href="#License-Key-Formatting" class="headerlink" title="License Key Formatting"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/license-key-formatting/">License Key Formatting</a><a name="license-key-formatting"></a></h3><p>The idea is simple. </p>
<ol>
<li>I maintain a temporary array <em>s</em> that contains only the characters in string <em>S</em> after converting them to uppercase.</li>
<li>I maintain a variable <em>length</em> that counts how many characters I found in the string <em>S</em>. If length is 0, that means it contains only dashes (-). </li>
<li>Then I record the <em>offset</em>. <em>Offset</em> basically measures how many characters of the String <em>S</em> will be grouped unevenly in the beginning part of the string. I can check that by using the modulus operator and finding out the remainder. That many characters (of <em>length &lt; K</em>) will be in the beginning part of the string.</li>
<li>Next step is to calculate how many dashes I will need. It’s basically <em>length &#x2F; K</em>.</li>
<li>Then I create the char array that will hold the characters of the formatted key. It’s length will be number of characters + the dashes we will need. We need to take care of a special case here. If the <em>offset</em> is 0, meaning I was able to divide characters in equal group, I need to subtract 1. Eg, let’s say we had 8 characters and <em>K</em> was 4.  dashes &#x3D; 8 &#x2F; 4 &#x3D; 2. We can divide 8 characters equally into 2 groups using only 1 dash. But since dashes was 2, it is clearly off by 1. This is the case when <em>offset</em> is 0.</li>
<li><em>kIndex</em> tracks where character is to be inserted in the key array.</li>
<li><em>used</em> tracks how many characters of the array <em>s</em>, which indirectly holds the characters of String <em>S</em>, are used.</li>
<li>First I copy down the characters of length <em>offset</em>. Because those are the ones of uneven length. <em>kIndex</em> and <em>used</em> variables are updated.</li>
<li>Last thing to do is to use all the remaining characters in array <em>s</em>, but we take <em>K</em> characters at a time, because we know that the segments are going to be of equal length. We also need to insert ‘-‘ after each segment, but only if <em>kIndex</em> is not at the beginning or at the end of the key array, because inserting it at those points is invalid.</li>
<li>Create a new string and return it.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">licenseKeyFormatting</span><span class="params">(String S, <span class="type">int</span> K)</span> &#123;</span><br><span class="line">    <span class="type">char</span>[] s = <span class="keyword">new</span> <span class="title class_">char</span>[S.length()];</span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c: S.toCharArray())</span><br><span class="line">      <span class="keyword">if</span> (c != <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">        s[length++] = Character.toUpperCase(c);</span><br><span class="line">    <span class="keyword">if</span> (length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> length % K;</span><br><span class="line">    <span class="type">int</span> <span class="variable">dashes</span> <span class="operator">=</span> length / K; </span><br><span class="line">    <span class="type">char</span>[] key = <span class="keyword">new</span> <span class="title class_">char</span>[length + dashes + (offset == <span class="number">0</span> ? -<span class="number">1</span> : <span class="number">0</span>)];</span><br><span class="line">    <span class="type">int</span> <span class="variable">kIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">used</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (used &lt; offset)</span><br><span class="line">      key[kIndex++] = s[used++];</span><br><span class="line">    <span class="keyword">while</span> (used &lt; index)&#123;</span><br><span class="line">      <span class="keyword">if</span> (kIndex &gt; <span class="number">0</span> &amp;&amp; kIndex &lt; key.length)</span><br><span class="line">        key[kIndex++] = <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; K; ++i)</span><br><span class="line">        key[kIndex++] = s[used++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Max-Consecutive-Ones"><a href="#Max-Consecutive-Ones" class="headerlink" title="Max Consecutive Ones"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/max-consecutive-ones/">Max Consecutive Ones</a><a name="max-consecutive-ones"></a></h3><p>Solution 1: I came up with this solution initially. 4 ms runtime and passes 99.97% submissions.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMaxConsecutiveOnes</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;					<span class="comment">// Keep track of start of a streak, if any</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;					<span class="comment">// max length of the streak</span></span><br><span class="line">    <span class="keyword">while</span> (start &lt; nums.length)&#123;	<span class="comment">// While we are not at the end of the array</span></span><br><span class="line">        <span class="keyword">if</span> (nums[start] == <span class="number">1</span>)&#123;		<span class="comment">// Check if we have a 1 at start, if so</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">streak</span> <span class="operator">=</span> <span class="number">0</span>;			<span class="comment">// initialize streak and check how long can we continue</span></span><br><span class="line">            <span class="keyword">while</span> (start &lt; nums.length &amp;&amp; nums[start] == <span class="number">1</span>)&#123;	<span class="comment">// that streak.</span></span><br><span class="line">                ++streak;			<span class="comment">// Increment streak and left for each consecutive 1</span></span><br><span class="line">                ++start;			<span class="comment">// make sure you don&#x27;t forget that start &lt; nums.length</span></span><br><span class="line">            &#125;						<span class="comment">// before checking nums[start] to prevent out-of-bounds</span></span><br><span class="line">            <span class="keyword">if</span> (streak &gt; max)		<span class="comment">// Check if the current streak is better than the</span></span><br><span class="line">                max = streak;		<span class="comment">// previous streak.</span></span><br><span class="line">        &#125;</span><br><span class="line">        ++start;					<span class="comment">// Increment start in either case to check for new</span></span><br><span class="line">    &#125;								<span class="comment">// streaks.</span></span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>Solution 2: After analyzing the problem further, I noticed that 0 denotes the end of a streak. If we observe 1, we increment streak by 1. But if I see a 0, I reset my streak to 0. This solution too had a 4 ms runtime and passed 99.97% submissions.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMaxConsecutiveOnes</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;				<span class="comment">// Global max streak</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">streak</span> <span class="operator">=</span> <span class="number">0</span>;				<span class="comment">// Local max streak.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i: nums)&#123;			<span class="comment">// For each number in nums</span></span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">1</span>)&#123;			<span class="comment">// If we see a 1</span></span><br><span class="line">            ++streak;			<span class="comment">// increment our ongoing streak.</span></span><br><span class="line">            <span class="keyword">if</span> (streak &gt; max)	<span class="comment">// If the local streak &gt; global max</span></span><br><span class="line">                max = streak;	<span class="comment">// update global max streak.</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>					<span class="comment">// otherwise we just saw a 0.</span></span><br><span class="line">            streak = <span class="number">0</span>;			<span class="comment">// So our streak resets to 0.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;					<span class="comment">// return the global max streak.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Permutations"><a href="#Permutations" class="headerlink" title="Permutations"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/permutations/">Permutations</a><a name="permutations"></a></h3><p>The idea is as follows. Given an array a &#x3D; {1,2,3}, we want to generate all it’s possible combinations. What we are trying to do here is that we first take the element at index 0, and find permutations of the remaining thing. When we do that, we insert the element at index 0 in front of the list to get 1 permutation. Similarly, we then take the element at index 1, and permute the remaining contents of the array and insert the element at index 1 in the beginning of the array to get another permutation and so on. In this problem, we are asked to return a list of list, so we first copy the numbers of the array into an ArrayList. Let’s run this code for the above example.</p>
<blockquote>
<p>Given nums &#x3D; {1,2,3}, our ArrayList will be the same, al &#x3D; [1,2,3]. Our result list is empty, result &#x3D; [] and index &#x3D; 0.</p>
<p><strong>helper([1,2,3], 0)</strong></p>
<blockquote>
<p>swap (0, 0) → al &#x3D; [1,2,3]</p>
<p><strong>helper(1,2,3, 1)</strong></p>
<blockquote>
<p>swap(1, 1) → al &#x3D; [1,2,3]</p>
<p><strong>helper([1,2,3], 2)</strong></p>
<blockquote>
<p>swap(2, 2) → [1,2,3]</p>
<p><strong>helper([1,2,3], 3)</strong></p>
<blockquote>
<p>We update our result list now, because index &#x3D;&#x3D; length. Therefore, result &#x3D; [[1,2,3]]. Our recursive stack collapses and we move on to the next instruction, which is undo the step, al &#x3D; [1,2,3].</p>
</blockquote>
</blockquote>
<p>swap(1, 2) → al &#x3D; [1,3,2]</p>
<p><strong>helper([1,3,2], 3)</strong></p>
<blockquote>
<p>Again, index &#x3D;&#x3D; length, add it to the list. result &#x3D; [[1,2,3], [1,3,2]]. Recursion stack collapses, we undo the swap, al &#x3D; [1,2,3]</p>
</blockquote>
</blockquote>
<p>swap(0, 1) → al &#x3D; [2,1,3]</p>
<p><strong>helper([2,1,3], 1)</strong></p>
<blockquote>
<p>swap(1,1) → al &#x3D; [2,1,3]</p>
<p><strong>helper([2,1,3], 2)</strong></p>
<blockquote>
<p>swap(2, 2) → al &#x3D; [2,1,3]</p>
<p><strong>helper([2,1,3], 3)</strong></p>
<blockquote>
<p>index &#x3D;&#x3D; length, add the current order to the list. result &#x3D; [[1,2,3], [1,3,2], [2,1,3]]</p>
</blockquote>
</blockquote>
<p>swap(1, 2) → al &#x3D; [2,3,1]</p>
<p><strong>helper([2,3,1], 3)</strong></p>
<blockquote>
<p>index &#x3D;&#x3D; length, add the order to the list. Result &#x3D; [[1,2,3], [1,3,2], [2,1,3], [2,3,1]]</p>
</blockquote>
</blockquote>
<p>swap(0, 2) → al &#x3D; [3,2,1]</p>
<p><strong>helper([3,2,1], 2)</strong></p>
<blockquote>
<p>swap(2,2) → al &#x3D; [3,2,1]</p>
<p><strong>helper([3,2,1], 3)</strong></p>
<blockquote>
<p>index &#x3D;&#x3D; length, add the order to the list. Result &#x3D; [[1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,2,1]] </p>
</blockquote>
</blockquote>
<p>swap(1,2) → al &#x3D; [3,1,2]</p>
<p><strong>helper([3,1,2], 3)</strong></p>
<blockquote>
<p>index &#x3D;&#x3D; length, add the order to the list. Result &#x3D; [[1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,2,1], [3,1,2]]</p>
</blockquote>
</blockquote>
<p>All branches have been explored now, since the iteration ends and we return the result list.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> len;						<span class="comment">// To store the length of the input array</span></span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; result;		<span class="comment">// Result list</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; numList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();	<span class="comment">// Creating a copy of the nums array</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i: nums)			<span class="comment">// because it&#x27;s easier to create a list from a list.</span></span><br><span class="line">        numList.add(i);			<span class="comment">// Add everything to the list.</span></span><br><span class="line">    len = nums.length;</span><br><span class="line">    helper(numList, <span class="number">0</span>);			<span class="comment">// Call the aux function.</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">helper</span><span class="params">(List&lt;Integer&gt; order, <span class="type">int</span> index)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index == len)			<span class="comment">// If we have checked all the numbers in the array, add a</span></span><br><span class="line">        result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(order));	<span class="comment">// clone of the list to the array.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index; i &lt; len; ++i)&#123;	<span class="comment">// Otherwise from index to the end of the array,</span></span><br><span class="line">        swap(order, i, index);	<span class="comment">// take one element, swap it with itself, then the next and</span></span><br><span class="line">        helper(order, index+<span class="number">1</span>);	<span class="comment">// so on. Recurse again, but on the next index we just swapped.</span></span><br><span class="line">        swap(order, i, index);	<span class="comment">// Undo the swap so that it helps us in generating the next</span></span><br><span class="line">    &#125;							<span class="comment">// permutation.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(List&lt;Integer&gt; list, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;	<span class="comment">// Swap elements in a list.</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> list.get(i);</span><br><span class="line">    list.set(i, list.get(j));</span><br><span class="line">    list.set(j, temp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Construct-the-Rectangle"><a href="#Construct-the-Rectangle" class="headerlink" title="Construct the Rectangle"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/construct-the-rectangle/">Construct the Rectangle</a><a name="construct-the-rectangle"></a></h3><p>The idea is very simple. We just need to iterate from width &#x3D; sqrt(area) to 1 and check if area is perfectly divisible by width. If at any point, width is divisible, then that must be our minimum difference length and width, because we are diverging from the center on both sides. Width decreases while length keeps increasing. Think of it like this, for area &#x3D; 24, we have many factors of 24, namely 1, 2, 3,4, 6, 8, 12, 24. It’s sqrt when rounded down is 4. So we check for width &#x3D; 4, is 24 perfectly divisible by 4? Yes, so divide it and whatever you get is going to be the minimal difference values. Suppose 4 and 6 weren’t the factors for 24. In that case we decrease width by 1, which is 3. Check again, is 24 divisible by 3. Yes? Then that must be our answer. We are diverging away from the center on both sides equally, width to the left towards 1 and length to the right towards area . Therefore the moment we find one value that divides area perfectly, that’s our required values.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] constructRectangle(<span class="type">int</span> area) &#123;</span><br><span class="line">    <span class="type">int</span>[] dimensions = &#123;area, <span class="number">1</span>&#125;;		<span class="comment">// We know that if nothing works out, n*1 is always</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">done</span> <span class="operator">=</span> <span class="literal">false</span>;				<span class="comment">// going to be the answer</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> (<span class="type">int</span>)Math.sqrt(area);	<span class="comment">// We only need to check width from sqrt(area)</span></span><br><span class="line">    <span class="keyword">while</span> (!done)&#123;						<span class="comment">// While not done</span></span><br><span class="line">        <span class="keyword">if</span> (area % length == <span class="number">0</span>)&#123;		<span class="comment">// check if area is perfectly divisible by width</span></span><br><span class="line">            dimensions[<span class="number">0</span>] = width;		<span class="comment">// if so, we found our width and the length.</span></span><br><span class="line">            dimensions[<span class="number">1</span>] = area/width;</span><br><span class="line">            done = <span class="literal">true</span>;				<span class="comment">// mark done as false</span></span><br><span class="line">        &#125;</span><br><span class="line">        --width;						<span class="comment">// otherwise decrease the length</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dimensions;					<span class="comment">// return the dimensions found.</span></span><br></pre></td></tr></table></figure>



<h3 id="Merge-Intervals"><a href="#Merge-Intervals" class="headerlink" title="Merge Intervals"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/merge-intervals/">Merge Intervals</a><a name="merge-intervals"></a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Interval&gt; <span class="title function_">merge</span><span class="params">(List&lt;Interval&gt; intervals)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (intervals == <span class="literal">null</span> || intervals.size() &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> intervals;</span><br><span class="line">    Collections.sort(intervals, (a,b) -&gt; a.start-b.start);	<span class="comment">// Sort the list so we can </span></span><br><span class="line">													<span class="comment">// compare adjacent intervals.</span></span><br><span class="line">    List&lt;Interval&gt; merged = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    merged.add(intervals.get(<span class="number">0</span>));					<span class="comment">// Add the initial interval.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Interval i: intervals)&#123;					<span class="comment">// For each interval</span></span><br><span class="line">        <span class="type">Interval</span> <span class="variable">last</span> <span class="operator">=</span> merged.get(merged.size()-<span class="number">1</span>);<span class="comment">// Get the last added time.</span></span><br><span class="line">        <span class="keyword">if</span> (i.start &gt; last.end)						<span class="comment">// If it&#x27;s time is greater than the last</span></span><br><span class="line">            merged.add(i);							<span class="comment">// interval&#x27;s end, it doesn&#x27;t overlap</span></span><br><span class="line">        <span class="keyword">else</span>&#123;										<span class="comment">// otherwise it does.</span></span><br><span class="line">            last.end = last.end &gt; i.end ? last.end : i.end;	<span class="comment">// So check which has greater end time, and make the last added interval&#x27;s time equals that</span></span><br><span class="line">            merged.set(merged.size()-<span class="number">1</span>, last);		<span class="comment">// And set it as the last added interval</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> merged;									<span class="comment">// Return the merged list.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Merged-sorted-lists"><a href="#Merged-sorted-lists" class="headerlink" title="Merged sorted lists"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/merge-sorted-array/">Merged sorted lists</a><a name="merged-sorted-lists"></a></h3><ol>
<li>counterA keeps track of which element we are looking at in array ‘a’. Same with counterB</li>
<li>counterK keeps track of where to insert the element in array ‘a’, since a has enough space. The problem states that it might have more than enough space, so we use only the spaces we need, which is the total of both their sizes. Since indexing in an array is 0-based, we subtract 1.</li>
<li>We insert elements from the end, since the end part of ‘a’ is empty. We can insert from the front, but then we would need to shift elements to the right after each insertion from ‘b’.</li>
<li>If array values are equal, add them to the end, and decrease both their counter to check new values in the next iteration</li>
<li>If not equal, then check which one is greater, since the last part of the array should contain larger values. Whichever’s greater, put it in ‘a’ at index ‘counterA’ and decrement the respective counter.</li>
<li>In the end, we might have some leftover elements either from ‘a’ or ‘b’ because we only process elements that are equal to the <strong>min(size(a), size(b))</strong>, until we run out of elements in one of the array. So, whichever array has elements pending, add it to the front of the array and return a.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] merge(<span class="type">int</span>[] a, <span class="type">int</span> sizeA, <span class="type">int</span>[] b, <span class="type">int</span> sizeB)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">counterA</span> <span class="operator">=</span> sizeA-<span class="number">1</span>, counterB = sizeB-<span class="number">1</span>, counterK = sizeA+sizeB-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (counterA &gt; -<span class="number">1</span> &amp;&amp; counterB &gt; -<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (a[counterA] == b[counterB])&#123;</span><br><span class="line">            a[counterK--] = a[counterA--];</span><br><span class="line">            a[counterK--] = b[counterB--];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            a[counterK--] = a[counterA] &gt; b[counterB] ? a[counterA--] : b[counterB--];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (counterA &gt; -<span class="number">1</span>)</span><br><span class="line">        a[counterK--] = a[counterA--];</span><br><span class="line">    <span class="keyword">while</span> (counterB &gt; -<span class="number">1</span>)</span><br><span class="line">        a[counterK--] = b[counterB--];</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Next-Greater-Element-I"><a href="#Next-Greater-Element-I" class="headerlink" title="Next Greater Element I"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/next-greater-element-i/">Next Greater Element I</a><a name="next-greater-element-i"></a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] nextGreaterElement(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">    HashMap&lt;Integer, Integer&gt; index = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();	<span class="comment">// We use the hashmap to keep a</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums2.length; ++i)				<span class="comment">// track of the index of each value</span></span><br><span class="line">        index.put(nums2[i], i);							<span class="comment">// in nums 2. That way, when we want</span></span><br><span class="line">								<span class="comment">// to look for a value greater than a val in nums1, we know</span></span><br><span class="line">    <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[nums1.length];	<span class="comment">// which index to start iterating from.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums1.length; ++i)&#123;	<span class="comment">// So for each val in nums1</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> nums1[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> index.get(val); j &lt; nums2.length; ++j)&#123;	<span class="comment">// Iterate from that value&#x27;s</span></span><br><span class="line">            <span class="keyword">if</span> (nums2[j] &gt; val)&#123;			<span class="comment">// index in nums2 to the end, and see if you can</span></span><br><span class="line">                result[i] = nums2[j];		<span class="comment">// find any val &gt; nums1[i]. If you do, save it</span></span><br><span class="line">                <span class="keyword">break</span>;						<span class="comment">// in the result array and break the loop.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (result[i] == <span class="number">0</span>)		<span class="comment">// Now if we didn&#x27;t find any value, then result[i] would be</span></span><br><span class="line">            result[i] = -<span class="number">1</span>;		<span class="comment">// 0, so we set that index to -1 in our result array.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;				<span class="comment">// simply return the result array.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="String-Without-AAA-or-BBB"><a href="#String-Without-AAA-or-BBB" class="headerlink" title="String Without AAA or BBB"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/string-without-aaa-or-bbb/">String Without AAA or BBB</a><a name="string-without-aaa-or-bbb"></a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">strWithout3a3b</span><span class="params">(<span class="type">int</span> A, <span class="type">int</span> B)</span> &#123;				</span><br><span class="line">    <span class="type">char</span>[] ch = <span class="keyword">new</span> <span class="title class_">char</span>[A+B];		<span class="comment">// We create an char array to store string chars</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> <span class="variable">max</span> <span class="operator">=</span> A &gt; B ? <span class="string">&#x27;a&#x27;</span> : <span class="string">&#x27;b&#x27;</span>;	<span class="comment">// record the most frequent occurring element</span></span><br><span class="line">    <span class="type">char</span> <span class="variable">min</span> <span class="operator">=</span> max == <span class="string">&#x27;a&#x27;</span> ? <span class="string">&#x27;b&#x27;</span> : <span class="string">&#x27;a&#x27;</span>;	<span class="comment">// and the least frequent occurring element</span></span><br><span class="line">    <span class="keyword">while</span> (A &gt; <span class="number">0</span> || B &gt; <span class="number">0</span>)&#123;			<span class="comment">// While we haven&#x27;t added all of the elements</span></span><br><span class="line">    <span class="comment">// We check that if our current index &gt; 1 and our previoud two characters in the array</span></span><br><span class="line">    <span class="comment">// are the same, then we must have written the max occurring char, so it&#x27;s time to write</span></span><br><span class="line">    <span class="comment">// the minimum occurring element. We write it, and then decrement the specific A or B.</span></span><br><span class="line">        <span class="keyword">if</span> (index &gt; <span class="number">1</span> &amp;&amp; max == ch[index-<span class="number">1</span>] &amp;&amp; max == ch[index-<span class="number">2</span>])&#123;</span><br><span class="line">            ch[index++] = min;</span><br><span class="line">            <span class="keyword">if</span> (min == <span class="string">&#x27;a&#x27;</span>)		<span class="comment">// If the minimum freq element is &#x27;a&#x27;, decrement A</span></span><br><span class="line">                A--;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                B--;			<span class="comment">// otherwise decrement B</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (B &gt; A)&#123;		<span class="comment">// Otherwise, if B occurs more than A, then set char to B</span></span><br><span class="line">            ch[index++] = <span class="string">&#x27;b&#x27;</span>;	<span class="comment">// decrement B and increment index</span></span><br><span class="line">            B--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;					<span class="comment">// A occurs more, so add A to the char array.</span></span><br><span class="line">            ch[index++] = <span class="string">&#x27;a&#x27;</span>;	<span class="comment">// Increment index, decrement A count</span></span><br><span class="line">            A--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(ch);		<span class="comment">// Create a string from the char array and return it.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Keyboard-Row"><a href="#Keyboard-Row" class="headerlink" title="Keyboard Row"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/keyboard-row/">Keyboard Row</a><a name="keyboard-row"></a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Maps each character to the row in the keyboard in which it occurs.</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span>[] map = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String[] findWords(String[] words) &#123;</span><br><span class="line"></span><br><span class="line">    String[] w = <span class="keyword">new</span> <span class="title class_">String</span>[words.length];	<span class="comment">// Store filtered words</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;							<span class="comment">// Where to insert the filtered words</span></span><br><span class="line">    <span class="keyword">for</span> (String s: words)					<span class="comment">// for each word in words</span></span><br><span class="line">        <span class="keyword">if</span> (checkWord(s.toLowerCase()))		<span class="comment">// convert it to lowercase and check if all char</span></span><br><span class="line">            w[index++] = s;					<span class="comment">// occurs in the same row, if it does, add it</span></span><br><span class="line">    <span class="keyword">return</span> Arrays.copyOfRange(w, <span class="number">0</span>, index);	<span class="comment">// Simply return a copy of the array from 0</span></span><br><span class="line">&#125;											<span class="comment">// index</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">checkWord</span><span class="params">(String word)</span>&#123;		<span class="comment">// Check if all chars in the word belong in the</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> map[word.charAt(<span class="number">0</span>)-<span class="string">&#x27;a&#x27;</span>];		<span class="comment">// same row. Check first chars row</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c: word.toCharArray())&#123;		<span class="comment">// For all the chars in the word</span></span><br><span class="line">        <span class="keyword">if</span> (map[c-<span class="string">&#x27;a&#x27;</span>] != row)				<span class="comment">// if that char belongs to a different row,</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;					<span class="comment">// return false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;							<span class="comment">// All chars in same row, return true.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Find-Mode-in-Binary-Search-Tree"><a href="#Find-Mode-in-Binary-Search-Tree" class="headerlink" title="Find Mode in Binary Search Tree"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/find-mode-in-binary-search-tree/">Find Mode in Binary Search Tree</a><a name="find-mode-in-binary-search-tree"></a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> TreeNode parent;		<span class="comment">// Keep track of parent at each node</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> maxMode;			<span class="comment">// maxMode we found</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> currentMode;		<span class="comment">// mode recorded at each node</span></span><br><span class="line"><span class="keyword">private</span> Set&lt;Integer&gt; modes;		<span class="comment">// keep distinct modes found</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] findMode(TreeNode root)&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>)			<span class="comment">// node is null, so return empty array</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">    maxMode = <span class="number">1</span>;				<span class="comment">// we have just seen the root, so maxMode so far is 1.</span></span><br><span class="line">    currentMode = <span class="number">1</span>;			<span class="comment">// so is the current mode</span></span><br><span class="line">    modes = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    modes.add(root.val);		<span class="comment">// add the root to our modes set</span></span><br><span class="line">    traverse(root);				<span class="comment">// start traversing it&#x27;s left and right branches</span></span><br><span class="line">    <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[modes.size()];	<span class="comment">// We have found all the modes</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>;				<span class="comment">// keep track of where to insert elements in result array</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i: modes)			<span class="comment">// add all the distinct modes one by one</span></span><br><span class="line">        result[idx++] = i;</span><br><span class="line">    <span class="keyword">return</span> result;				<span class="comment">// and return it.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>)			<span class="comment">// if node is null, stop</span></span><br><span class="line">        <span class="keyword">return</span>;					<span class="comment">// otherwise traverse the left branch</span></span><br><span class="line">    traverse(node.left);		<span class="comment">// Once we hit the null, we start backtracking to the leaf</span></span><br><span class="line">    updateMode(node);			<span class="comment">// then we call updateMode with the node</span></span><br><span class="line">    parent = node;				<span class="comment">// once it&#x27;s done, we update parent as the current node, so </span></span><br><span class="line">    traverse(node.right);		<span class="comment">// when we backtrack, we can easily check that node and it&#x27;s</span></span><br><span class="line">&#125;								<span class="comment">// next node&#x27;s value for similarity. Then traverse right.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateMode</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parent != <span class="literal">null</span> &amp;&amp; parent.val == node.val)&#123;	<span class="comment">// If parent node isn&#x27;t null and the</span></span><br><span class="line">        ++currentMode;			<span class="comment">// node&#x27;s value is the same as parent, we update currentMode</span></span><br><span class="line">        <span class="keyword">if</span> (currentMode &gt;= maxMode)&#123;	<span class="comment">// If the currentMode is greater or equal to maxMode</span></span><br><span class="line">            <span class="keyword">if</span> (currentMode &gt; maxMode)	<span class="comment">// just check if it&#x27;s greater. If it is, remove all </span></span><br><span class="line">                modes.clear();			<span class="comment">// previously recorded modes</span></span><br><span class="line">            modes.add(node.val);		<span class="comment">// Add the current node to the set and update the </span></span><br><span class="line">            maxMode = currentMode;		<span class="comment">// maxMode</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;						<span class="comment">// otherwise, value&#x27;s aren&#x27;t the same. so our currentMode</span></span><br><span class="line">        currentMode = <span class="number">1</span>;		<span class="comment">// becomes 1. If maxMode is also 1, then all we have been </span></span><br><span class="line">        <span class="keyword">if</span> (maxMode == <span class="number">1</span>)		<span class="comment">// seeing are distinct values, so add that node&#x27;s value to</span></span><br><span class="line">            modes.add(node.val);<span class="comment">// to the mode&#x27;s set.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Base-7"><a href="#Base-7" class="headerlink" title="Base 7"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/base-7/">Base 7</a><a name="base-7"></a></h3><p>Solution 1 without StringBuilder (Beats 100%, 7ms)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">convertToBase7</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (num == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> (<span class="type">int</span>)(Math.log(Math.abs(num))/Math.log(<span class="number">7</span>))+<span class="number">1</span>;	<span class="comment">// Calculate # of bits</span></span><br><span class="line">    <span class="type">int</span> idx;		<span class="comment">// where to start inserting from</span></span><br><span class="line">    <span class="type">char</span>[] digits;</span><br><span class="line">    <span class="keyword">if</span> (num &lt; <span class="number">0</span>) &#123;	<span class="comment">// If num is negative</span></span><br><span class="line">        num = -num;	<span class="comment">// Make it positive</span></span><br><span class="line">        digits = <span class="keyword">new</span> <span class="title class_">char</span>[len+<span class="number">1</span>];	<span class="comment">// We need one more space for -ve sign in the front</span></span><br><span class="line">        digits[<span class="number">0</span>] = <span class="string">&#x27;-&#x27;</span>;			<span class="comment">// Put the -ve sign</span></span><br><span class="line">        idx = len;					<span class="comment">// and index is now len</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        digits = <span class="keyword">new</span> <span class="title class_">char</span>[len];		<span class="comment">// otherwise we only need &quot;len&quot; spaces</span></span><br><span class="line">        idx = len-<span class="number">1</span>;				<span class="comment">// index is len-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (num != <span class="number">0</span>) &#123;				<span class="comment">// While num != 0, calculate remainder and add it.</span></span><br><span class="line">        digits[idx--] = (<span class="type">char</span>)(num % <span class="number">7</span> + <span class="string">&#x27;0&#x27;</span>);	<span class="comment">// Divide number by 7</span></span><br><span class="line">        num /= <span class="number">7</span>;</span><br><span class="line">    &#125;     </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(digits);		<span class="comment">// Just create a string and return it.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Solution 2 with StringBuilder</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">convertToBase7</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isNegative</span> <span class="operator">=</span> num &lt; <span class="number">0</span>;	<span class="comment">// Just so we can know if we need to add the &quot;-&quot; sign</span></span><br><span class="line">    <span class="keyword">if</span> (num &lt; <span class="number">0</span>)					<span class="comment">// Take the absolute value of num</span></span><br><span class="line">        num = -num;</span><br><span class="line">    <span class="keyword">while</span> (num &gt; <span class="number">6</span>) &#123;				<span class="comment">// Keep adding the remainder, and dividing num by 7.</span></span><br><span class="line">        sb.append(num % <span class="number">7</span>);</span><br><span class="line">        num /= <span class="number">7</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sb.append(num);					<span class="comment">// Add whatever is left at the end.</span></span><br><span class="line">    <span class="keyword">if</span> (isNegative)					<span class="comment">// If num was negative, add the minus sign.</span></span><br><span class="line">        sb.append(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sb.reverse().toString();	<span class="comment">// Reverse the builder and return the toString()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Relative-Ranks"><a href="#Relative-Ranks" class="headerlink" title="Relative Ranks"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/relative-ranks/">Relative Ranks</a><a name="relative-ranks"></a></h3><p>The idea employed here is simple. We need to store the relative ranks in sorted order. We can sort the array for that, but that is O(n log n). We can do better than that by finding the relative rank in linear time. First we find the maximum score in the array and create another array of length &#x3D; maxScore + 1. We add 1 so that when we see the maxScore in the nums, we can assign it to maxScore index. Once we have done that, now we iterate over the nums array. Variable i keeps track of what rank to assign. We check a value in the array and at that index in our reverse sorted array, we put i+1, which basically marks it’s rank based on it’s position in the rankings. Some of then indexes would be default, that is a score of 0. We then check each value in the descend array and if it’s not 0, we assign it a rank, but not if the ranks are 1, 2 or 3. In that case, we assign it a special value of Gold, SIlver or Bronze.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] findRelativeRanks(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxScore</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n: nums)</span><br><span class="line">        <span class="keyword">if</span> (n &gt; maxScore)</span><br><span class="line">            maxScore = n;</span><br><span class="line">    <span class="type">int</span>[] descend = <span class="keyword">new</span> <span class="title class_">int</span>[maxScore+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; ++i)</span><br><span class="line">        descend[nums[i]] = i+<span class="number">1</span>;</span><br><span class="line">    String[] result = <span class="keyword">new</span> <span class="title class_">String</span>[nums.length];</span><br><span class="line">    <span class="type">int</span> <span class="variable">rank</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> descend.length-<span class="number">1</span>; i &gt; -<span class="number">1</span>; --i)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> descend[i];</span><br><span class="line">        <span class="keyword">if</span> (descend[i] != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (rank == <span class="number">1</span>)</span><br><span class="line">                result[idx-<span class="number">1</span>] = <span class="string">&quot;Gold Medal&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (rank == <span class="number">2</span>)</span><br><span class="line">                result[idx-<span class="number">1</span>] = <span class="string">&quot;Silver Medal&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (rank == <span class="number">3</span>)</span><br><span class="line">                result[idx-<span class="number">1</span>] = <span class="string">&quot;Bronze Medal&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                result[idx-<span class="number">1</span>] = rank + <span class="string">&quot;&quot;</span>;</span><br><span class="line">            ++rank;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Perfect-Number"><a href="#Perfect-Number" class="headerlink" title="Perfect Number"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/perfect-number/">Perfect Number</a><a name="perfect-number"></a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkPerfectNumber</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (num == <span class="number">1</span>)		<span class="comment">// 1 is a special case, where it&#x27;s only factor is itself.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">1</span>;		<span class="comment">// We know our total will atleast be 1, 1 is everyone&#x27;s factor</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= Math.sqrt(num); ++i)	<span class="comment">// Only loop through num&#x27;s sqrt</span></span><br><span class="line">        <span class="keyword">if</span> (num % i == <span class="number">0</span>)&#123;				<span class="comment">// If i divides num perfectly</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">otherFactor</span> <span class="operator">=</span> num/i;	<span class="comment">// Calculate the other factor</span></span><br><span class="line">            total += i + (otherFactor == i ? <span class="number">0</span> : otherFactor);	<span class="comment">// If i and other factor are</span></span><br><span class="line">        &#125;								<span class="comment">// different, add them both, otherwise just i.</span></span><br><span class="line">    <span class="keyword">return</span> total == num;				<span class="comment">// Check in the end if your total is the same as num</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Detect-Capital"><a href="#Detect-Capital" class="headerlink" title="Detect Capital"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/detect-capital/">Detect Capital</a><a name="detect-capital"></a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">detectCapitalUse</span><span class="params">(String word)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> word.length();</span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">2</span>)			<span class="comment">// Empty or size 1 words are ok.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="type">char</span>[] chars = word.toCharArray();	<span class="comment">// Get the char array</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isUpper</span> <span class="operator">=</span> <span class="literal">false</span>;	<span class="comment">// by default we let isUpper to false</span></span><br><span class="line">    <span class="keyword">if</span> (chars[<span class="number">0</span>] &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; chars[<span class="number">0</span>] &lt;= <span class="string">&#x27;Z&#x27;</span>)		<span class="comment">// Check if first two letters are uppercase</span></span><br><span class="line">        isUpper = chars[<span class="number">1</span>] &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; chars[<span class="number">1</span>] &lt;= <span class="string">&#x27;Z&#x27;</span>; <span class="comment">// If first was upper and second wasnt</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; len; ++i)&#123;	<span class="comment">// isUpper = false, otherwise true.</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isAlsoUpper</span> <span class="operator">=</span> chars[i] &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; chars[i] &lt;= <span class="string">&#x27;Z&#x27;</span>; <span class="comment">// We check onwards 1 char</span></span><br><span class="line">        <span class="keyword">if</span> (isUpper &amp;&amp; !isAlsoUpper)	<span class="comment">// If that char is lower and previous part was</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;				<span class="comment">// not lower, invalid use.</span></span><br><span class="line">        <span class="keyword">if</span> (!isUpper &amp;&amp; isAlsoUpper)	<span class="comment">// Or if previous part was lower and current letter</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;				<span class="comment">// is upper, we return false.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;				<span class="comment">// Everything proceeded smoothly. So return true.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Longest-Uncommon-Subsequence-I"><a href="#Longest-Uncommon-Subsequence-I" class="headerlink" title="Longest Uncommon Subsequence I"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/longest-uncommon-subsequence-i/">Longest Uncommon Subsequence I</a><a name="longest-uncommon-subsequence-i"></a></h3><p>This is those kind of problems that shouldn’t be up there. The problem is stated rather poorly and the solution is even stupider. All you are checking for is if the two string’s aren’t the same, then whichever one has a larger length is essentially the longest uncommon subsequence because the other string cannot form the full string. I know, it’s stupid.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findLUSlength</span><span class="params">(String a, String b)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (a.equals(b))</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> a.length() &gt; b.length() ? a.length() : b.length();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Course-Schedule-II"><a href="#Course-Schedule-II" class="headerlink" title="Course Schedule II"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/course-schedule-ii/">Course Schedule II</a><a name="course-schedule-ii"></a></h3><p>This is a graph problem where we require to sort the vertices topologically. There are two choices we have for sorting topologically - Depth First Search approach based on finshing times or the Kahn’s Algorithm. I have used Kahn’s algorithm in this solution. Runtime is 2ms [beats 100%] and uses 45.3 MB space [beats than 90.16%]. The idea for Kahn’s is simple - Enqueue all the nodes which has 0 incoming edges because those are the ones that can be started first. Then while the queue isn’t empty, remove one node at a time, process it’s outgoing nodes and decrease their indegrees by one. The reasoning behind that is let’s say Node 2 has two prerequisites, Node 0 and Node 1. Node 0 and Node 1 have 0 indegrees. So our first two nodes would be Node 1 and Node 0 and if they are finished, then their outgoing Nodes can be started, that is Node 2. Now when you decrease any node’s indegree and they become zero, add them to the queue because they can now be started. Keep doing this until the queue is empty.</p>
<p>In my approach, I’m avoiding any unnecessary data structure and using only the most basic ones like array’s. So instead of using the queue, what I do is fill the array <code>order</code> which also stores the topological order. <code>idx</code> keeps track of the last index available to fill in the array. <code>start</code> mimics the <code>poll</code> behaviour of a queue. <code>while (start != idx)</code> makes sure that while we still have nodes to process, remove the one that can be started and decrease all the indegrees of outgoing edges.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] findOrder(<span class="type">int</span> numCourses, <span class="type">int</span>[][] prerequisites) &#123;</span><br><span class="line">    <span class="type">int</span>[] indegrees = <span class="keyword">new</span> <span class="title class_">int</span>[numCourses];				<span class="comment">// We maintain each node&#x27;s indegree</span></span><br><span class="line">    List&lt;Integer&gt;[] graph = <span class="keyword">new</span> <span class="title class_">ArrayList</span>[numCourses];	<span class="comment">// Each node&#x27;s outgoing edges</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>[] edge: prerequisites) &#123;					<span class="comment">// Process each edge</span></span><br><span class="line">        indegrees[edge[<span class="number">0</span>]]++;							<span class="comment">// Update indegrees</span></span><br><span class="line">        <span class="keyword">if</span> (graph[edge[<span class="number">1</span>]] == <span class="literal">null</span>)						<span class="comment">// Also store the edge in graph</span></span><br><span class="line">            graph[edge[<span class="number">1</span>]] = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        graph[edge[<span class="number">1</span>]].add(edge[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] order = <span class="keyword">new</span> <span class="title class_">int</span>[numCourses];		    <span class="comment">// We don&#x27;t technically need a queue.</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; ++i)        <span class="comment">// Find all nodes who indegree is 0</span></span><br><span class="line">        <span class="keyword">if</span> (indegrees[i] == <span class="number">0</span>)                  <span class="comment">// and put them in the order array</span></span><br><span class="line">            order[idx++] = i;</span><br><span class="line">    <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;                              <span class="comment">// start tracks node to be polled.</span></span><br><span class="line">    <span class="keyword">while</span> (start != idx) &#123;                      <span class="comment">// while we can poll the queue</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> order[start++];                 <span class="comment">// poll the node u</span></span><br><span class="line">        <span class="keyword">if</span> (graph[u] != <span class="literal">null</span>)                   <span class="comment">// If node u has outgoing edges </span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> out: graph[u])             <span class="comment">// Then for each of those nodes</span></span><br><span class="line">                <span class="keyword">if</span> (--indegrees[out] == <span class="number">0</span>)      <span class="comment">// decrease their indegrees and check if it&#x27;s 0</span></span><br><span class="line">                    order[idx++] = out;         <span class="comment">// if it&#x27;s 0, add it to our queue (order)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (idx != numCourses)						<span class="comment">// Cycle check. If our idx != numCourses then</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;&#125;;					<span class="comment">// not all nodes could be processed. So we have</span></span><br><span class="line">    <span class="keyword">return</span> order;								<span class="comment">// a cycle. Otherwise return our order array.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Letter-Combinations-of-a-Phone-Number"><a href="#Letter-Combinations-of-a-Phone-Number" class="headerlink" title="Letter Combinations of a Phone Number"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/letter-combinations-of-a-phone-number/">Letter Combinations of a Phone Number</a><a name="letter-combinations-of-a-phone-number"></a></h3><p>Runtime: 0 ms, faster than 100.00% of Java online submissions for Letter Combinations of a Phone Number.</p>
<p>Memory Usage: 35.9 MB, less than 98.63% of Java online submissions for Letter Combinations of a Phone Number.</p>
<hr>
<p>How do we count numbers? 16, 17, 18, 19 and then what? 20 right? We see that the last number is 19, we can’t go past 9 so we set it to 0 and then increment the precedding digit to get 20. The idea is the same for this problem too. We keep a <code>levels</code> array to keep track of which character do we take from which number’s allowed alphabet letters. For example, let’s say the input string is <code>23</code>. Our <code>levels</code> array would <code>[0, 0]</code> in the beginning. This says pick characters at index 0 and 0 from alphabet characters corresponding to 2 and 3 which gives us <code>ad</code>. Then, we increase the last most counter in our levels array by 1 giving us <code>[0, 1]</code>. This allows us to get <code>ae</code> in the next iteration and levels array would be <code>[0, 2]</code>. We get <code>af</code> and levels array becomes <code>[0, 3]</code>. Now this is where it becomes interesting. We are only allowed three letters for the digit corresponding to 3 and since we already used all of them , we now need to shift to the next character for digit 2, which is <code>b</code>. Level array looks like <code>[1, 0]</code>. This will allow us to get <code>[b,e]</code>. So you get the rough idea now. Only thing now is we watch out when to stop. We stop when we have utilized all available characters from the 0th index’s number’s allowed alphabet letters. In this case, we stop when levels array look like <code>[3, 0]</code>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">char</span>[][] map = &#123;</span><br><span class="line">            &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;,        <span class="comment">// 2</span></span><br><span class="line">            &#123;<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>&#125;,        <span class="comment">// 3</span></span><br><span class="line">            &#123;<span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;i&#x27;</span>&#125;,        <span class="comment">// 4</span></span><br><span class="line">            &#123;<span class="string">&#x27;j&#x27;</span>, <span class="string">&#x27;k&#x27;</span>, <span class="string">&#x27;l&#x27;</span>&#125;,        <span class="comment">// 5</span></span><br><span class="line">            &#123;<span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;o&#x27;</span>&#125;,        <span class="comment">// 6</span></span><br><span class="line">            &#123;<span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;q&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;s&#x27;</span>&#125;,   <span class="comment">// 7</span></span><br><span class="line">            &#123;<span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;u&#x27;</span>, <span class="string">&#x27;v&#x27;</span>&#125;,        <span class="comment">// 8</span></span><br><span class="line">            &#123;<span class="string">&#x27;w&#x27;</span>, <span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;z&#x27;</span>&#125;    <span class="comment">// 9</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();                <span class="comment">// Maintain the list of combinations</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] numbers;                                          <span class="comment">// numbers parsed from input</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] levels;                                           <span class="comment">// utility array to keep track of next character in string</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> n;                                                  <span class="comment">// number of input digits.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; <span class="title function_">solution</span><span class="params">(String digits)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (digits == <span class="literal">null</span> || digits.length() == <span class="number">0</span>)                 <span class="comment">// stop if null or empty string</span></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        n = digits.length();</span><br><span class="line">        numbers = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        levels = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; digits.length(); ++i) &#123;                 <span class="comment">// parse all the digits from the string as int</span></span><br><span class="line">            <span class="keyword">if</span> ((numbers[i] = digits.charAt(i) - <span class="string">&#x27;0&#x27;</span>) &lt; <span class="number">2</span>)          <span class="comment">// stop if any of them is 0 or 1</span></span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        helper();                                                   <span class="comment">// start recursion</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">helper</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (levels[<span class="number">0</span>] == map[numbers[<span class="number">0</span>]-<span class="number">2</span>].length)                  <span class="comment">// if we are done iterating over all possible combinations,</span></span><br><span class="line">            <span class="keyword">return</span>;                                                 <span class="comment">// stop recursion.</span></span><br><span class="line">        <span class="type">char</span>[] s = <span class="keyword">new</span> <span class="title class_">char</span>[n];                                     <span class="comment">// stores all the characters of the string</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i)                                 <span class="comment">// loop through levels array. The value at each index</span></span><br><span class="line">            s[i] = map[numbers[i]-<span class="number">2</span>][levels[i]];                    <span class="comment">// tells us which character to keep from which map index</span></span><br><span class="line">        levels[n-<span class="number">1</span>]++;                                              <span class="comment">// Increase the entry at the end of the levels array</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> levels.length-<span class="number">1</span>; i &gt; <span class="number">0</span>; --i) &#123;                 <span class="comment">// Now loop through the levels array from the end</span></span><br><span class="line">            <span class="keyword">if</span> (levels[i] == map[numbers[i]-<span class="number">2</span>].length) &#123;            <span class="comment">// If the value = total number of characters allowed for that number</span></span><br><span class="line">                levels[i] = <span class="number">0</span>;                                      <span class="comment">// then we set it to 0 and increment the previous level entry</span></span><br><span class="line">                levels[i - <span class="number">1</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        result.add(<span class="keyword">new</span> <span class="title class_">String</span>(s));                                  <span class="comment">// Add the string and induce next recursive call.</span></span><br><span class="line">        helper();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Sudoku-Solver"><a href="#Sudoku-Solver" class="headerlink" title="Sudoku Solver"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/sudoku-solver/">Sudoku Solver</a><a name="sudoku-solver"></a></h3><p>Runtime: 4 ms, faster than 90.01% of Java online submissions for Sudoku Solver.</p>
<p>Memory Usage: 35.1 MB, less than 71.93% of Java online submissions for Sudoku Solver.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">char</span>[][] board;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">solveSudoku</span><span class="params">(<span class="type">char</span>[][] board)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.board = board;</span><br><span class="line">    solve(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">solve</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> col)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (col == <span class="number">9</span>) &#123;                                 <span class="comment">// If col is 9, make it 0 and shift to the next row</span></span><br><span class="line">        col = <span class="number">0</span>;</span><br><span class="line">        row += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (row == <span class="number">9</span>)                               <span class="comment">// If row is also 9 now, then it means we have successfully filled all cells</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;                            <span class="comment">// So return true and end backtracking.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">10</span>; ++i) &#123;                  <span class="comment">// Otherwise, we start picking values from 1-9</span></span><br><span class="line">        <span class="keyword">if</span> (board[row][col] == <span class="string">&#x27;.&#x27;</span>) &#123;               <span class="comment">// And try to plug it into empty cells</span></span><br><span class="line">            <span class="keyword">if</span> (isValid(row, col, i)) &#123;             <span class="comment">// If that value is valid in that cell</span></span><br><span class="line">                board[row][col] = (<span class="type">char</span>)(i+<span class="string">&#x27;0&#x27;</span>);    <span class="comment">// fill it</span></span><br><span class="line">                <span class="keyword">if</span> (solve(row, col+<span class="number">1</span>))          <span class="comment">// and move on to fill the next cell via recursive call</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;                    <span class="comment">// If the recursion ended by returning true, then return true to signal success</span></span><br><span class="line">                <span class="keyword">else</span>                                <span class="comment">// Otherwise, we were not able to put an value in that cell</span></span><br><span class="line">                    board[row][col] = <span class="string">&#x27;.&#x27;</span>;          <span class="comment">// so change it back to 0 and the backtracking would try the next higher value in that cell.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> solve(row, col+<span class="number">1</span>);           <span class="comment">// That cell wasn&#x27;t empty, so move on to the next empty cell.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;                                   <span class="comment">// No solution found.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> col, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="comment">// row check</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>; c &lt; <span class="number">9</span>; ++c)</span><br><span class="line">        <span class="keyword">if</span> (board[row][c] - <span class="string">&#x27;0&#x27;</span> == val)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// column check</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">0</span>; r &lt; <span class="number">9</span>; ++r)</span><br><span class="line">        <span class="keyword">if</span> (board[r][col] - <span class="string">&#x27;0&#x27;</span> == val)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// box check</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span> row / <span class="number">3</span> * <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> col / <span class="number">3</span> * <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">3</span>; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[top+i][left+j] - <span class="string">&#x27;0&#x27;</span> == val)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Bulls-and-Cows"><a href="#Bulls-and-Cows" class="headerlink" title="Bulls and Cows"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/bulls-and-cows/">Bulls and Cows</a><a name="bulls-and-cows"></a></h3><p>Runtime: 1 ms, faster than 100.00% of Java online submissions for Bulls and Cows.</p>
<p>Memory Usage: 36.3 MB, less than 100.00% of Java online submissions for Bulls and Cows.</p>
<p>The idea is simple, first record the frequency of the digits of the secret number. Then we first find number of <code>bulls</code> by checking for exact indices match. After that we start to record the number of <code>cows</code>. The way we do is by again iterating over the <code>guess</code> string; only if there was a character mismatch and we still have the character available from <code>freq</code> table, we have a <code>cow</code>. Update it and decrement the frequency of the number we just used up.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">getHint</span><span class="params">(String secret, String guess)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">bulls</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">cows</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>[] freq = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];							<span class="comment">// Freq of available digits from secret</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; guess.length(); ++i) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">s</span> <span class="operator">=</span> secret.charAt(i);</span><br><span class="line">        freq[s - <span class="string">&#x27;0&#x27;</span>]++;								<span class="comment">// Record the freq of the digit</span></span><br><span class="line">        <span class="keyword">if</span> (s == guess.charAt(i)) &#123;						<span class="comment">// If it&#x27;s a match, we have a bulls.</span></span><br><span class="line">            bulls++;</span><br><span class="line">            freq[s - <span class="string">&#x27;0&#x27;</span>]--;							<span class="comment">// We just used the character, so decrement it.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; guess.length(); ++i) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> secret.charAt(i) - <span class="string">&#x27;0&#x27;</span>;					<span class="comment">// Convert the chars into int</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">g</span> <span class="operator">=</span> guess.charAt(i) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (s != g &amp;&amp; freq[g] &gt; <span class="number">0</span>) &#123;					<span class="comment">// Only if they are a mismtach and we have a number g available in freq table</span></span><br><span class="line">            cows++;										<span class="comment">// then it&#x27;s a cow.</span></span><br><span class="line">            freq[g]--;									<span class="comment">// We used up the number, so decrement it&#x27;s freq.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>().append(bulls).append(<span class="string">&quot;A&quot;</span>).append(cows).append(<span class="string">&quot;B&quot;</span>).toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="N-Queens-I"><a href="#N-Queens-I" class="headerlink" title="N-Queens I"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/n-queens/">N-Queens I</a><a name="n-queens-1"></a></h3><p>Runtime: 3 ms, faster than 73.76% of Java online submissions for N-Queens.<br>Memory Usage: 37.6 MB, less than 100.00% of Java online submissions for N-Queens.</p>
<p>The idea is same as sudoku, but insteading of scanning rows, we scan columns. Start with row 0, column 0 and see if we can place a queen there, if yes place it and try the next cell of row 0 by recursing. We can’t put the queen in the same row again, so we keep changing rows with column 1 until we find somewhere to place it. Keep doing this until you were successfully able to place all the queens as checked by the condition <code>col == n</code>. If so, add that solution to our list of accepted solutions.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NQueens</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] board;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;String&gt;&gt; result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">solveNQueens</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">        board = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        solve(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">solve</span><span class="params">(<span class="type">int</span> col)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (col == n)</span><br><span class="line">            addToList();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> <span class="number">0</span>; row &lt; n; ++row) &#123;</span><br><span class="line">            <span class="keyword">if</span> (canPlaceQueen(row, col)) &#123;</span><br><span class="line">                board[row][col] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (solve(col+<span class="number">1</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    board[row][col] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addToList</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        StringBuilder sb;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] r: board) &#123;</span><br><span class="line">            sb = <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i: r)</span><br><span class="line">                sb.append(i == <span class="number">1</span> ? <span class="string">&#x27;Q&#x27;</span> : <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">            list.add(sb.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        result.add(list);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">canPlaceQueen</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> col)</span> &#123;</span><br><span class="line">        <span class="comment">// Check all rows for the same column</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; col; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[row][i] == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Check upper left diagonal of the cell</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> row, j = col; i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; i--, j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][j] == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Check lower left diagonal of the cell.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> row, j = col; i &lt; n &amp;&amp; j &gt;= <span class="number">0</span>; i++, j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][j] == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="K-diff-pairs-in-an-Array"><a href="#K-diff-pairs-in-an-Array" class="headerlink" title="K-diff pairs in an Array"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/k-diff-pairs-in-an-array/">K-diff pairs in an Array</a><a name="k-diff-pairs-in-an-array"></a></h3><p>Pretty intuitive solution. Build a frequency HashMap for all the numbers in the array. In a special case where <code>diff</code> is 0, just count occurences in our <code>freq</code> map whose values are 2 or more. In other case, just loop through all the keys and make sure it’s supplement exists to count the number of K-diff pairs.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findPairs</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (k &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pairs</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    HashMap&lt;Integer, Integer&gt; freq = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i: nums) &#123;</span><br><span class="line">        freq.put(i, freq.getOrDefault(i, <span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i: freq.values())</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">1</span>)</span><br><span class="line">                pairs++;</span><br><span class="line">        <span class="keyword">return</span> pairs;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i: freq.keySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (freq.containsKey(i+k))</span><br><span class="line">            pairs++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pairs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Is-Subsequence"><a href="#Is-Subsequence" class="headerlink" title="Is Subsequence"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/is-subsequence/submissions/">Is Subsequence</a><a name="is-subsequence"></a></h3><p>Runtime: 0 ms, faster than 100.00% of Java online submissions for Is Subsequence.<br>Memory Usage: 49.6 MB, less than 100.00% of Java online submissions for Is Subsequence.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSubsequence</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> -<span class="number">1</span>;								<span class="comment">// Set it to 0 to start check for 0th index</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c: s.toCharArray()) &#123;				<span class="comment">// For all the characters in String s</span></span><br><span class="line">        idx = t.indexOf(c, idx+<span class="number">1</span>);				<span class="comment">// Find it&#x27;s index in String t from index one more than the last index matched</span></span><br><span class="line">        <span class="keyword">if</span> (idx &lt; <span class="number">0</span>)							<span class="comment">// idx &lt; 0 means not found</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Minimum-Absolute-Difference-in-BST"><a href="#Minimum-Absolute-Difference-in-BST" class="headerlink" title="Minimum Absolute Difference in BST"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/minimum-absolute-difference-in-bst/">Minimum Absolute Difference in BST</a><a name="minimum-absolute-difference-in-bst"></a></h3><p>The idea is to use the Inorder traversal of a BST. We repeatively iterate over the left branch to find the minimum diff and then do the same for the right branch, but this time we already know that the parent of the right branch has to be its minimum, so first set it and then traverse the right branch to find the minimum difference.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Integer.MAX_VALUE;								<span class="comment">// Hold the minimum difference.</span></span><br><span class="line"><span class="type">int</span> <span class="variable">prev</span> <span class="operator">=</span> Integer.MAX_VALUE;								<span class="comment">// Holds the minimum value observed for the right branch</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMinimumDifference</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    traverse(root);											<span class="comment">// Start iterating from the root.</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>)										<span class="comment">// Null node, so stop recursion</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    traverse(node.left);									<span class="comment">// Keep traversing till the end of the tree</span></span><br><span class="line">    res = Math.min(Math.abs(node.val-prev), res);			<span class="comment">// Check if we have a minimum, if so set it.</span></span><br><span class="line">    prev = node.val;										<span class="comment">// The smallest value for the right branch is it&#x27;s parent</span></span><br><span class="line">    traverse(node.right);									<span class="comment">// Set it first and then traverse.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="BST-Tree-to-Greater-Tree"><a href="#BST-Tree-to-Greater-Tree" class="headerlink" title="BST Tree to Greater Tree"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/convert-bst-to-greater-tree/">BST Tree to Greater Tree</a><a name="bst-tree-to-greater-tree"></a></h3><p>The idea is simple. In a BST, we know everything on the right side of a node is greater than it and it’s left side. So when we are at any node, it’s value would be its value + sum of everything on its right side. So, we first compute the node’s value and then notice that the value for the node on the left is nothing but its value + parents value. So the node’s value is computed, do the same thing for the left side, but this time, the starting sum would be the parent’s value.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">convertBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    traverse(root, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">traverse</span><span class="params">(TreeNode node, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    node.val += traverse(node.right, sum);</span><br><span class="line">    <span class="keyword">return</span> traverse(node.left, node.val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Student-Attendance-Record-I"><a href="#Student-Attendance-Record-I" class="headerlink" title="Student Attendance Record I"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/student-attendance-record-i/">Student Attendance Record I</a><a name="student-attendance-record-I"></a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkRecord</span><span class="params">(String s)</span> &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">A</span> <span class="operator">=</span> <span class="number">0</span>;												<span class="comment">// Count number of A&#x27;s seen</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> <span class="number">0</span>;												<span class="comment">// Count number of consecutive L&#x27;s seen</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">char</span> c: s.toCharArray()) &#123;		<span class="comment">// Loop through each character</span></span><br><span class="line">          <span class="keyword">if</span> (c == <span class="string">&#x27;A&#x27;</span>) &#123;								<span class="comment">// If c is A, increment A</span></span><br><span class="line">              A++;</span><br><span class="line">              <span class="keyword">if</span> (A &gt; <span class="number">1</span>)								<span class="comment">// If A is more than 1, return false</span></span><br><span class="line">                  <span class="keyword">return</span> <span class="type">false</span></span><br><span class="line">              <span class="variable">L</span> <span class="operator">=</span> <span class="number">0</span>;										<span class="comment">// Always set L count to 0</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;L&#x27;</span>) &#123;					<span class="comment">// If c is L,</span></span><br><span class="line">              L++;											<span class="comment">// We might have consecutive L&#x27;s, so start counting</span></span><br><span class="line">              <span class="keyword">if</span> (L &gt; <span class="number">2</span>) &#123;							<span class="comment">// If we have more than 2 consecutive L&#x27;s</span></span><br><span class="line">                  <span class="keyword">return</span> <span class="literal">false</span>;					<span class="comment">// return false</span></span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span>													<span class="comment">// Lastly, we might have a P, that will reset our</span></span><br><span class="line">              L = <span class="number">0</span>;										<span class="comment">// consecutive L streak.</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;											<span class="comment">// Everything passed, so return true.</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Reverse-Words-in-String-III"><a href="#Reverse-Words-in-String-III" class="headerlink" title="Reverse Words in String III"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/reverse-words-in-a-string-iii/">Reverse Words in String III</a><a name="reverse-words-in-string-iii"></a></h3><p>Runtime: 2 ms, faster than 99.34% of Java online submissions for Reverse Words in a String III.</p>
<p>Memory Usage: 37.9 MB, less than 100.00% of Java online submissions for Reverse Words in a String III.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">reverseWords</span><span class="params">(String s)</span> &#123;</span><br><span class="line">      <span class="type">char</span>[] arr = s.toCharArray();</span><br><span class="line">      <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> arr.length;</span><br><span class="line">      <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      <span class="type">int</span> end;</span><br><span class="line">      <span class="keyword">while</span> (start &lt; len) &#123;											<span class="comment">// Check the whole string</span></span><br><span class="line">          end = start;													<span class="comment">// find the index of the first whitespace</span></span><br><span class="line">          <span class="keyword">while</span>(end &lt; len &amp;&amp; arr[end] != <span class="string">&#x27; &#x27;</span>)		<span class="comment">// denoting end of the word</span></span><br><span class="line">              end++;</span><br><span class="line">          reverseWord(arr, start, end-<span class="number">1</span>);				<span class="comment">// reverse that specific word</span></span><br><span class="line">          start = end+<span class="number">1</span>;												<span class="comment">// update start to the new word beginning</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(arr);										<span class="comment">// create a new string out of the array</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	Reverses a word in-place by iterating n/2 times where n = len of the word.</span></span><br><span class="line"><span class="comment">	Traverse upto the middle point of the word while swapping each word from start+offset to end-	 offset.</span></span><br><span class="line"><span class="comment">	**/</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reverseWord</span><span class="params">(<span class="type">char</span>[] arr, <span class="type">int</span> start, <span class="type">int</span> stop)</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= (stop-start)/<span class="number">2</span>; ++i) &#123;</span><br><span class="line">          <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> arr[start+i];</span><br><span class="line">          arr[start+i] = arr[stop-i];</span><br><span class="line">          arr[stop-i] = temp;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Quad-Tree-Intersection"><a href="#Quad-Tree-Intersection" class="headerlink" title="Quad Tree Intersection"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/quad-tree-intersection/">Quad Tree Intersection</a><a name="quad-tree-intersection"></a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Node <span class="title function_">intersect</span><span class="params">(Node qt1, Node qt2)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (qt1.isLeaf)										<span class="comment">// If only a leaf, then return the one with true val</span></span><br><span class="line">          <span class="keyword">return</span> qt1.val ? qt1 : qt2;</span><br><span class="line">      <span class="keyword">if</span> (qt2.isLeaf)</span><br><span class="line">          <span class="keyword">return</span> qt2.val ? qt2 : qt1;</span><br><span class="line">      <span class="type">Node</span> <span class="variable">n</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();							<span class="comment">// Prepare for recursion</span></span><br><span class="line">      n.val = <span class="literal">true</span>;											<span class="comment">// By default, each level node is not a leaf with </span></span><br><span class="line">      n.isLeaf = <span class="literal">false</span>;									<span class="comment">// value = true</span></span><br><span class="line">  </span><br><span class="line">  		<span class="comment">// Keep traversing all the way to a terminal node and then store it.</span></span><br><span class="line">      n.topLeft = intersect(qt1.topLeft, qt2.topLeft);</span><br><span class="line">      n.topRight = intersect(qt1.topRight, qt2.topRight);</span><br><span class="line">      n.bottomLeft = intersect(qt1.bottomLeft, qt2.bottomLeft);</span><br><span class="line">      n.bottomRight = intersect(qt1.bottomRight, qt2.bottomRight);</span><br><span class="line">  </span><br><span class="line">  		<span class="comment">// Check now if you&#x27;re at the base case. If n&#x27;s children are leaves and all their values are same, then make n a leaf and it&#x27;s value the same as it&#x27;s child.</span></span><br><span class="line">      <span class="keyword">if</span> (n.topLeft.isLeaf &amp;&amp; n.topRight.isLeaf &amp;&amp; n.bottomLeft.isLeaf &amp;&amp; n.bottomRight.isLeaf &amp;&amp; (n.topLeft.val == n.topRight.val &amp;&amp; n.topRight.val == n.bottomLeft.val &amp;&amp; n.bottomLeft.val == n.bottomRight.val)) &#123;</span><br><span class="line">          n.isLeaf = <span class="literal">true</span>;</span><br><span class="line">          n.val = n.topLeft.val;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> n;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Long-Pressed-Name"><a href="#Long-Pressed-Name" class="headerlink" title="Long Pressed Name"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/long-pressed-name/">Long Pressed Name</a><a name="long-pressed-name"></a></h3><p>Runtime: 0 ms, faster than 100.00% of Java online submissions for Long Pressed Name.</p>
<p>Memory Usage: 34.2 MB, less than 100.00% of Java online submissions for Long Pressed Name.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isLongPressedName</span><span class="params">(String name, String typed)</span> &#123;</span><br><span class="line">      <span class="type">char</span>[] n = name.toCharArray();						<span class="comment">// Arrays are much nicer to work with</span></span><br><span class="line">      <span class="type">char</span>[] t = typed.toCharArray();						<span class="comment">// Record start and stop points for both</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">startN</span> <span class="operator">=</span> <span class="number">0</span>, endN = n.length, startT = <span class="number">0</span>, endT = t.length;</span><br><span class="line">      <span class="keyword">while</span> (startT &lt; endT) &#123;										<span class="comment">// While we haven&#x27;t looked at the whole string</span></span><br><span class="line">          <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> startN+<span class="number">1</span>;									<span class="comment">// Let&#x27;s first count same consecutive letters</span></span><br><span class="line">          <span class="type">int</span> <span class="variable">countN</span> <span class="operator">=</span> <span class="number">1</span>;												<span class="comment">// in String name</span></span><br><span class="line">          <span class="keyword">while</span> (temp &lt; endN &amp;&amp; n[startN] == n[temp]) &#123;</span><br><span class="line">              temp++;</span><br><span class="line">              countN++;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="type">int</span> <span class="variable">countT</span> <span class="operator">=</span> <span class="number">0</span>;												<span class="comment">// Do the same for typed string</span></span><br><span class="line">          <span class="keyword">while</span> (startT &lt; endT &amp;&amp; n[startN] == t[startT]) &#123;</span><br><span class="line">              startT++;</span><br><span class="line">              countT++;</span><br><span class="line">          &#125;																			<span class="comment">// If consecutive letters in typed string are</span></span><br><span class="line">          <span class="keyword">if</span> (countT &lt; countN)									<span class="comment">// less than the ones in original name</span></span><br><span class="line">              <span class="keyword">return</span> <span class="literal">false</span>;											<span class="comment">// return false</span></span><br><span class="line">          startN = temp;												<span class="comment">// Otherwise, prepare for next character</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> startN == endN;										<span class="comment">// Lastly, check if we were able to match</span></span><br><span class="line">  &#125;																							<span class="comment">// all character of the name string</span></span><br></pre></td></tr></table></figure>

<h3 id="Binary-Tree-Zigzag-Level-Order-Traversal"><a href="#Binary-Tree-Zigzag-Level-Order-Traversal" class="headerlink" title="Binary Tree Zigzag Level Order Traversal"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/">Binary Tree Zigzag Level Order Traversal</a><a name="binary-tree-zigzag-level-order-traversal"></a></h3><p>The idea here is simple. We perform a BFS as usual using a Queue but I maintain a variable called <code>dir</code> to check which side do I add from. <code>dir=1</code> means add from Right-&gt;Left and <code>dir=-1</code> means add from usual Left-&gt;Right. I am also using LinkedList because of easy addition of elements in both direction. When I need to add from Right-&gt;Left, I use the <code>addFirst(E e)</code> method of LinkedList to add to the head, otherwise normal add to the tail. One important thing to take care of at each iteration is to know how many nodes to dequeue, hence the usage of the variable <code>children</code>. This allows me to keep track of how many children were added to the queue at each stage so I dequeue exactly that many children in the next stage. Apart from that, everything is straightforward.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">zigzagLevelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">      List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">      <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">          <span class="keyword">return</span> list;</span><br><span class="line">      Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">      q.add(root);										<span class="comment">// Children = 1 because only root is added.</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">dir</span> <span class="operator">=</span> <span class="number">1</span>, children = <span class="number">1</span>;			<span class="comment">// Added the root, so next time dir = 1 (Right-&gt;Left)</span></span><br><span class="line">      <span class="keyword">while</span>(!q.isEmpty()) &#123;</span><br><span class="line">          <span class="type">int</span> <span class="variable">pushed</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">          LinkedList&lt;Integer&gt; l = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; children; ++i) &#123;		<span class="comment">// Poll only those nodes that were queued in</span></span><br><span class="line">              <span class="type">TreeNode</span> <span class="variable">u</span> <span class="operator">=</span> q.poll();							<span class="comment">// the previous stage.</span></span><br><span class="line">              <span class="keyword">if</span> (dir == <span class="number">1</span>)</span><br><span class="line">                  l.add(u.val);</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                  l.addFirst(u.val);							<span class="comment">// Left-&gt;Right add</span></span><br><span class="line">              <span class="keyword">if</span> (u.left != <span class="literal">null</span>) &#123;								<span class="comment">// Add children, notice I am counting here</span></span><br><span class="line">                  q.add(u.left);									<span class="comment">// how many children I am pushing/queuing</span></span><br><span class="line">                  ++pushed;												<span class="comment">// to the queue</span></span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (u.right != <span class="literal">null</span>) &#123;							<span class="comment">// Same thing for right child.</span></span><br><span class="line">                  q.add(u.right);</span><br><span class="line">                  ++pushed;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          list.add(l);														<span class="comment">// Add this list to main list</span></span><br><span class="line">          children = pushed;											<span class="comment">// update # of children pushed</span></span><br><span class="line">          dir = dir == <span class="number">1</span> ? -<span class="number">1</span>: <span class="number">1</span>;									<span class="comment">// update dir for next iteration</span></span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> list;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Array-Partition-I"><a href="#Array-Partition-I" class="headerlink" title="Array Partition I"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/array-partition-i/">Array Partition I</a><a name="array-partition-I"></a></h3><p>Runtime: 3 ms, faster than 99.90% of Java online submissions for Array Partition I.</p>
<p>Memory Usage: 40.1 MB, less than 100.00% of Java online submissions for Array Partition I.</p>
<p>I originally came up with the sorting solution where you sort the array and look at two numbers at a time and keep the smaller number out of them and add to the sum. It was way slower, so I checked the fastest submission and this one is pretty smart. The idea is really good. We know there are going to be 20,001 numbers, so reserve an array for it. Now let’s say we had duplicates in our array, ex [1,2,1,4,1,1], if we were to sort it, we would get [1,1,1,1,2,4]. Notice that those four 1’s don’t really matter because each of them pairs up with the other to give you a one 1. That is why we mark those particular indices as true and false. Notice that in our variable <code>sum</code> we would have counted them individually, making <code>sum = 4</code> when in fact it should be 2 since we only take one of them from two pairs. If we have even occurrence of any number, they would be false, meaning we don’t need to account them in the <code>diff</code> calculation. Now coming to <code>diff</code> how do we compute it? First we have the <code>seen</code> array to know which elements we need to look at. If that particular index is true, then we check if it’s the first element of the pair which we maintain via the boolean value <code>firstElemOfPair</code>. If its true, then <code>first</code> becomes that value. Otherwise, we know that we’re looking at the second element so we update the <code>diff</code> which is basically that value subtract <code>first</code>. Notice that if we look at a pair in our example as (2,4), we would pick 2 and the <code>diff</code> would be 2. This needs to be subtracted from our <code>sum</code>, hence the reason to maintain both of them. At the end, we finally subtract sum and diff and divide the result by 2 because we were doubling our diff’s too.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">arrayPairSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">      <span class="type">boolean</span>[] seen = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">20001</span>];</span><br><span class="line">      <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> n: nums) &#123;</span><br><span class="line">          seen[n + <span class="number">10000</span>] = !seen[n+<span class="number">10000</span>];</span><br><span class="line">          sum += n;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">int</span> <span class="variable">diff</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      <span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      <span class="type">boolean</span> <span class="variable">firstElemOfPair</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; seen.length; ++i) &#123;</span><br><span class="line">          <span class="keyword">if</span> (seen[i]) &#123;</span><br><span class="line">              <span class="keyword">if</span> (firstElemOfPair)</span><br><span class="line">                  first = i;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                  diff += i-first;</span><br><span class="line">              firstElemOfPair = !firstElemOfPair;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> (sum-diff)/<span class="number">2</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Reshape-the-Matrix"><a href="#Reshape-the-Matrix" class="headerlink" title="Reshape the Matrix"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/reshape-the-matrix/">Reshape the Matrix</a><a name="reshape-the-matrix"></a></h3><p>Runtime: 1 ms, faster than 100.00% of Java online submissions for Reshape the Matrix.</p>
<p>Memory Usage: 38.4 MB, less than 100.00% of Java online submissions for Reshape the Matrix.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[][] matrixReshape(<span class="type">int</span>[][] nums, <span class="type">int</span> r, <span class="type">int</span> c) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">numsR</span> <span class="operator">=</span> nums.length;				                    <span class="comment">// Get rows and col of nums</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">numsC</span> <span class="operator">=</span> nums[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">if</span> (numsR * numsC != r*c || (numsR == r &amp;&amp; numsC == c))	<span class="comment">// If can&#x27;t reshape or problems</span></span><br><span class="line">        <span class="keyword">return</span> nums;									        <span class="comment">// asks to reshape in the same dimensions, return the same array</span></span><br><span class="line">    <span class="type">int</span>[][] mat = <span class="keyword">new</span> <span class="title class_">int</span>[r][c];			                    <span class="comment">// New matrix to be returned</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> <span class="number">0</span>, col = <span class="number">0</span>, nR = <span class="number">0</span>, nC = <span class="number">0</span>; 	                <span class="comment">// To keep track of which element to consume and where to place it in the new matrix</span></span><br><span class="line">    <span class="keyword">while</span> (row != r) &#123;</span><br><span class="line">        mat[row][col++] = nums[nR][nC++];	                    <span class="comment">// Increment only the column value for both</span></span><br><span class="line">        <span class="keyword">if</span> (col == c) &#123;								        <span class="comment">// Check if we are at boundary, if so, increment row</span></span><br><span class="line">            col = <span class="number">0</span>;									        <span class="comment">// and set col to 0 for both cases.</span></span><br><span class="line">            ++row;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nC == numsC) &#123;</span><br><span class="line">            nC = <span class="number">0</span>;</span><br><span class="line">            ++nR;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mat;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Swap-Nodes-in-Pairs"><a href="#Swap-Nodes-in-Pairs" class="headerlink" title="Swap Nodes in Pairs"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/swap-nodes-in-pairs/">Swap Nodes in Pairs</a><a name="swap-nodes-in-pairs"></a></h3><p>Runtime: 0 ms, faster than 100.00% of Java online submissions for Swap Nodes in Pairs.</p>
<p>Memory Usage: 34.5 MB, less than 100.00% of Java online submissions for Swap Nodes in Pairs.</p>
<p>The idea is simple. We add a dummy node in front for simplicity as it allows us to generalize the concept of getting two nodes at a time. We maintain a current pointer that points to the node in the actual LinkedList. Then, we get it’s next and it’s next.next and store it into n1 and n2. Now notice that before making n2’s next &#x3D; n1, we need to store n2’s next into n1’s next. After we do that, we need to make sure that current’s next is n2 which is now working with the actual LinkedList. Then, we need to make sure that current.next.next is n1 which we just fixed and update current which is basically n1.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">swapPairs</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    dummy.next = head;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">curr</span> <span class="operator">=</span> dummy;</span><br><span class="line">    <span class="keyword">while</span> (curr.next != <span class="literal">null</span> &amp;&amp; curr.next.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">n1</span> <span class="operator">=</span> curr.next;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">n2</span> <span class="operator">=</span> n1.next;</span><br><span class="line">        n1.next = n2.next;</span><br><span class="line">        curr.next = n2;</span><br><span class="line">        curr.next.next = n1;</span><br><span class="line">        curr = curr.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Generate-Parentheses"><a href="#Generate-Parentheses" class="headerlink" title="Generate Parentheses"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/generate-parentheses/">Generate Parentheses</a><a name="generate-parentheses"></a></h3><p>Iterative Approach 1: This one is very slow.</p>
<p>Runtime: 4 ms, faster than 8.87% of Java online submissions for Generate Parentheses.</p>
<p>Memory Usage: 36.1 MB, less than 100.00% of Java online submissions for Generate Parentheses.</p>
<p>The idea is simple. We basically do a BFS and keep track of the parentheses combination we have obtained so far. Poll the queue and check if it’s length is 2*n (for a given n, we would have # of open brackets &#x3D; # of closed brackets), add it to the list and check next combination. If not, then check if we can add an open bracket, add it and update number of open bracket count and add this combination to the queue. Then try to see if we can add a closed bracket, if you can add it, then update closed bracket count add that combination to the queue. Keep doing this until the queue becomes empty. This is the first approach I came up with which is naive as you can see since it’s doing an exhaustive search for all valid combination.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String data;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> open;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> close;</span><br><span class="line"></span><br><span class="line">    Node(String s, <span class="type">int</span> o, <span class="type">int</span> c) &#123;</span><br><span class="line">        data = s;</span><br><span class="line">        open = o;</span><br><span class="line">        close = c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;String&gt; <span class="title function_">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    Queue&lt;Node&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    q.add(<span class="keyword">new</span> <span class="title class_">Node</span>(<span class="string">&quot;(&quot;</span>, <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">u</span> <span class="operator">=</span> q.poll();</span><br><span class="line">        <span class="keyword">if</span> (u.data.length() == <span class="number">2</span>*n)</span><br><span class="line">            list.add(u.data);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(u.data, u.open, u.close);</span><br><span class="line">            <span class="type">Node</span> <span class="variable">n2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(u.data, u.open, u.close);</span><br><span class="line">            <span class="keyword">if</span> (n1.open &lt; n) &#123;</span><br><span class="line">                n1.data = u.data + <span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">                ++n1.open;</span><br><span class="line">                q.add(n1);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (n2.close &lt; u.open) &#123;</span><br><span class="line">                n2.data = u.data + <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">                ++n2.close;</span><br><span class="line">                q.add(n2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Recursive Solution 2: This one is much more faster. I generalized the above idea into the fact that I am adding only valid combinations and any invalid combinations are automatically discarded. The logic is as follows: We know for a given n, the string length should be 2*n. So that forms our base case for recursion, if the length of String <code>s</code> is <code>2n</code>, we want to add it to the list. Otherwise, we check if the number of open brackets we have so far is less than <code>n</code>. If so, we can add an open bracket. Then check if number of close bracket is less than <code>open</code>, if so that sequence would be valid and add a close bracket and recurse.</p>
<p>Runtime: 1 ms, faster than 95.16% of Java online submissions for Generate Parentheses.<br>Memory Usage: 36.1 MB, less than 100.00% of Java online submissions for Generate Parentheses.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;String&gt; <span class="title function_">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    helper(list, <span class="string">&quot;(&quot;</span>, <span class="number">1</span>, <span class="number">0</span>, n);</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">helper</span><span class="params">(List&lt;String&gt; list, String s, <span class="type">int</span> open, <span class="type">int</span> close, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s.length() == <span class="number">2</span>*n)</span><br><span class="line">        list.add(s);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (open &lt; n)</span><br><span class="line">            helper(list, s+<span class="string">&#x27;(&#x27;</span>, open+<span class="number">1</span>, close, n);</span><br><span class="line">        <span class="keyword">if</span> (close &lt; open)</span><br><span class="line">            helper(list, s+<span class="string">&#x27;)&#x27;</span>, open, close+<span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>###<a target="_blank" rel="noopener" href="https://leetcode.com/problems/distribute-candies/">Distribute Candies</a><a name="distribute-candies"></a></p>
<p>Pretty simple solution. We want to give maximize the number of unique candies to give to the sister. So we maintain a hashset to collect all the unique candies first. Both of them get half the candies, so let <code>s = number of candies they get</code>. Now, if the size of the set is greater than or equal to <code>s</code>, then the sister only gets <code>s</code> candies out of it. Otherwise, the maximum amount of unique candies she can get is equal to the set size.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">distributeCandies</span><span class="params">(<span class="type">int</span>[] candies)</span> &#123;</span><br><span class="line">    Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(candies.length);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i: candies)</span><br><span class="line">        set.add(i);</span><br><span class="line">    <span class="type">int</span> <span class="variable">share</span> <span class="operator">=</span> candies.length/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> set.size() &gt;= share ? share: set.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Maximum-subproduct-subarray"><a href="#Maximum-subproduct-subarray" class="headerlink" title="Maximum subproduct subarray"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/maximum-product-subarray/">Maximum subproduct subarray</a><a name="maximum-subproduct-subarray"></a></h3><p>Credits for this simplistic solution to LeetCode user <a target="_blank" rel="noopener" href="https://leetcode.com/problems/maximum-product-subarray/discuss/48230/Possibly-simplest-solution-with-O(n)-time-complexity">mzchen</a>. The approach is very clever. Notice that if this problem was about finding maximum sum subarray, then a negative number would break the contiguous array. Here, what it does is that it makes our maximum product minimum when we see a negative number and vice versa. We keep track of maximum and minimum we have so far and check if we have a negative number. If so swap our max and min. Then, find the local maximum and minimum between current number and multiplying that number with our current max or min. After that, update our global max value and keep doing this for all values in the array.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProduct</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>, imax = max, imin = max; i &lt; nums.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> imax;</span><br><span class="line">            imax = imin;</span><br><span class="line">            imin = temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        imax = Math.max(nums[i], imax * nums[i]);</span><br><span class="line">        imin = Math.min(nums[i], imin * nums[i]);</span><br><span class="line">        max = Math.max(max, imax);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Binary-Tree-Right-Side-View"><a href="#Binary-Tree-Right-Side-View" class="headerlink" title="Binary Tree Right Side View"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/binary-tree-right-side-view/">Binary Tree Right Side View</a><a name="binary-tree-right-side-view"></a></h3><p>Runtime: 1 ms, faster than 95.45% of Java online submissions for Binary Tree Right Side View.</p>
<p>Memory Usage: 36.3 MB, less than 100.00% of Java online submissions for Binary Tree Right Side View.</p>
<p>This is an interesting problem cause initially, I thought we would always have a complete binary tree and I made my initial solution oriented towards it. But then I saw that it doesn’t say that anywhere and it could be any kind of binary tree. So it got me thinking towards a more generalized approach. Notice that to get a right side view of the binary tree, we only need the last value at any given level and put it into the list. So we maintain a queue and also the number of elements we enqueue at each stage. Initially, we put the root node in our queue and our enqueue count is 1. We dequeue exactly that many elements and again enqueue each of those dequeued node’s children. Notice that I am using the variable <code>newEnqueued</code> to keep track of newly enqueued elements. Lastly, we need to check if we dequeued the last element. If so, that must be a part of the solution since it has to be the rightmost element at that level, so I add it to the list. Update <code>enqueued</code> to the new value and repeat until our queue isn’t empty.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">rightSideView</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    q.add(root);</span><br><span class="line">    <span class="type">int</span> <span class="variable">enqueued</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">newEnqueued</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; enqueued; ++i) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">u</span> <span class="operator">=</span> q.poll();</span><br><span class="line">            <span class="keyword">if</span> (u.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                q.add(u.left);</span><br><span class="line">                ++newEnqueued;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (u.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                q.add(u.right);</span><br><span class="line">                ++newEnqueued;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i == enqueued-<span class="number">1</span>)</span><br><span class="line">                list.add(u.val);</span><br><span class="line">        &#125;</span><br><span class="line">        enqueued = newEnqueued;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Find-Minimum-in-Rotated-Sorted-Array"><a href="#Find-Minimum-in-Rotated-Sorted-Array" class="headerlink" title="Find Minimum in Rotated Sorted Array"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/submissions/">Find Minimum in Rotated Sorted Array</a><a name="find-minimum-in-rotated-sorted-array"></a></h3><p>Runtime: 0 ms, faster than 100.00% of Java online submissions for Find Minimum in Rotated Sorted Array.</p>
<p>Memory Usage: 38.6 MB, less than 77.27% of Java online submissions for Find Minimum in Rotated Sorted Array.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMin</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">1</span>)									<span class="comment">// Base case.</span></span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length-<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span> (nums[left] &gt; nums[right]) &#123;		<span class="comment">// While we are in the ascending order half,</span></span><br><span class="line">        mid = (left + right)/<span class="number">2</span>;						<span class="comment">// Find the middle element</span></span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt;= nums[left])			<span class="comment">// If mid element &gt;= left element, then our min</span></span><br><span class="line">            left = mid + <span class="number">1</span>;								<span class="comment">// must be in the right half.</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            right = mid;									<span class="comment">// otherwise min in the left half.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[left];										<span class="comment">// left points to minimum element.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Binary-Search-Tree-Iterator"><a href="#Binary-Search-Tree-Iterator" class="headerlink" title="Binary Search Tree Iterator"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/binary-search-tree-iterator/">Binary Search Tree Iterator</a><a name="binary-search-tree-iterator"></a></h3><p>Runtime: 15 ms, faster than 99.74% of Java online submissions for Binary Search Tree Iterator.</p>
<p>Memory Usage: 49.9 MB, less than 93.83% of Java online submissions for Binary Search Tree Iterator.</p>
<p>Logic is same as your In-Order traversal of any Binary Tree, but store the node values you visit in any data structure. Here I am using an ArrayList for storing each of the visited node’s value. Maintain <code>idx</code> value to keep track of which value to return. <code>hasNext()</code> method returns true as long as <code>idx &lt; list.size()</code>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BSTIterator</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; list;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BSTIterator</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        traverse(root);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        traverse(node.left);</span><br><span class="line">        list.add(node.val);</span><br><span class="line">        traverse(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** <span class="doctag">@return</span> the next smallest number */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> list.get(idx++);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** <span class="doctag">@return</span> whether we have a next smallest number */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> idx != list.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Find-Peak-Element"><a href="#Find-Peak-Element" class="headerlink" title="Find Peak Element"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/find-peak-element/">Find Peak Element</a><a name="find-peak-element"></a></h3><p>This question was asked to me for my internship at Yahoo! The idea is simple, we want any one of the peak. So to achieve <code>O(log n)</code> time, we have to mimic binary search algorithm. We look at the middle element and check it’s neighbor, if it’s greater than the middle element, then we know we will have atleast one peak on the right side. Why? Think what could happen. We know that the element next to middle is greater than it, so there are two possibilities on the right side, either elements keep increasing to the right of the middle’s next element or we might go up till a particular index and then go down. So in any case, we will have a peak on the right side. On the other case, if the element on the right side is smaller than the middle, then we know that the left half including the middle will have the peak cause middle is already greater than middle’s right, so we might have middle as the peak itself.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findPeakElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> nums[<span class="number">0</span>], high = nums.length - <span class="number">1</span>, mid;</span><br><span class="line">    <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">        mid = (low + high)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; nums[mid+<span class="number">1</span>])</span><br><span class="line">            low = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            high = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Next-Permutation"><a href="#Next-Permutation" class="headerlink" title="Next Permutation"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/next-permutation/">Next Permutation</a><a name="next-permutation"></a></h3><p>Runtime: 0 ms, faster than 100.00% of Java online submissions for Next Permutation.</p>
<p>Memory Usage: 40.3 MB, less than 47.00% of Java online submissions for Next Permutation.</p>
<p>This one was quite interesting in the sense it seems difficult but is very simple once you try out a few example. If we want to find the next lexicographical greater number, then we need to find a particular index from the right side of the array such that the number after it is greater than itself, because by swapping them would give us a next larger number. So what I first do is find the index of the number such that <code>num[idx] &gt; num[idx-1]</code>. We know at this point that all the numbers after that index are reverse sorted, so we need to fix it and sort them in increasing order because lexicographical order demands all the numbers in increasing manner. Example, say <code>nums = [2,3,1,4,2,1,0]</code>. You can see that that the next number should be <code>[2,3,2,0,1,1,4]</code>. Notice that I replaced the number at index 2 with the first number which is greater than it if the array after index 2 was sorted. This gaurantees us a larger lexicographical number. So the first while loop finds us that index number and then I reverse the array after it. Once you reverse it, we should expect the <code>nums</code> array to look like <code>[2,3,1,0,1,2,4]</code>. Note that now we need to find the number larger than the number at index 2, which is 1 in this case. The first number greater than 1 is 2, so the second while loop finds it and then we simply swap them to give us the next larger lexicographically greater number &#x3D;&gt; <code>[2,3,2,0,1,1,4].</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">nextPermutation</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> nums.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (idx &gt; <span class="number">0</span> &amp;&amp; nums[idx] &lt;= nums[idx-<span class="number">1</span>])</span><br><span class="line">        --idx;</span><br><span class="line">    reverse(nums, idx);</span><br><span class="line">    <span class="keyword">if</span> (idx == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> nums[idx-<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> idx;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; nums.length &amp;&amp; nums[i] &lt;= val)</span><br><span class="line">        ++i;</span><br><span class="line">    swap(nums, i, idx-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> idx1, <span class="type">int</span> idx2)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[idx1];</span><br><span class="line">    arr[idx1] = arr[idx2];</span><br><span class="line">    arr[idx2] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> start)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> arr.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (start &lt; end)</span><br><span class="line">        swap(arr, start++, end--);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Search-in-Rotated-Sorted-Array"><a href="#Search-in-Rotated-Sorted-Array" class="headerlink" title="Search in Rotated Sorted Array"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/search-in-rotated-sorted-array/">Search in Rotated Sorted Array</a><a name="search-in-rotated-sorted-array"></a></h3><p>The idea is same as binary search except you need to keep track of which half to stay in. We compute the middle index and the value at that index. If the middle value is the target, then return that index. Otherwise, find the correct half. If the number on the left side is &lt; middle value then we know that between the left and middle index, values are increasing. We only need to now check if target is &lt; middle value, if so we need to adjust our right pointer otherwise adjust the left pointer. If left value is not &lt; middle value then we are at a shift where the array is pivoted. We again need to confirm now which half to take. There would be some index <code>i</code> such that <code>nums[left] &gt; nums[i] &lt; nums[mid]</code> and value are increasing upto <code>i</code> and shifts from index <code>i</code> onwards. In this case, we again need to adjust our index pointers and we repeat this loop until <code>left &lt;= right</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right)/<span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">midVal</span> <span class="operator">=</span> nums[mid];</span><br><span class="line">        <span class="keyword">if</span> (target == midVal)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[left] &lt;= midVal) &#123;</span><br><span class="line">            <span class="keyword">if</span> (target &lt; midVal &amp;&amp; target &gt;= nums[left])</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (target &gt; midVal &amp;&amp; target &lt;= nums[right])</span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Transpose-Matrix"><a href="#Transpose-Matrix" class="headerlink" title="Transpose Matrix"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/transpose-matrix/">Transpose Matrix</a><a name="transpose-matrix"></a></h3><p>Pretty straightforward. Create matrix B of opposite dimensions to those of A. We maintain <code>br</code> and <code>bc</code> which tracks row and columns of B. We iterate over each element of A and put it in <code>B[br][bc]</code> and then ideally we would increment <code>bc</code> for an exact copy, but since we want transpose, we increment <code>br</code> and then reset it to 0 if we fill all the values in a row and increment column count, giving us the tranpose of the matrix.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[][] transpose(<span class="type">int</span>[][] A) &#123;</span><br><span class="line">    <span class="type">int</span>[][] B = <span class="keyword">new</span> <span class="title class_">int</span>[A[<span class="number">0</span>].length][A.length];</span><br><span class="line">    <span class="type">int</span> <span class="variable">br</span> <span class="operator">=</span> <span class="number">0</span>, bc = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; A.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; A[<span class="number">0</span>].length; ++j) &#123;</span><br><span class="line">            B[br][bc] = A[i][j];</span><br><span class="line">            <span class="keyword">if</span> (++br == B.length) &#123;</span><br><span class="line">                br = <span class="number">0</span>;</span><br><span class="line">                ++bc;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> B;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Merge-K-Sorted-Lists"><a href="#Merge-K-Sorted-Lists" class="headerlink" title="Merge K Sorted Lists"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/merge-k-sorted-lists/submissions/">Merge K Sorted Lists</a><a name="merge-k-sorted-lists"></a></h3><p>This was an onsite interview question at ThousandEyes. The idea is simple. Basically, we have multiple sorted lists so we have access to one value at a time, that is head of the lists initially and the consecutive nodes. So we need to fetch the minimum element out of all of them in constant time. The easiest way for us to do this is to use a PriorityQueue and define the logic of comparision of two ListNodes. Then, we add all the nodes inside the PQ and build our resulting List. Fetch the minimum valued ListNode and add it to our list. Then we also need to update that particular list’s head, so we  add that list’s next in the PQ so the next time it is fetched, we fetch the correct node of the list. Repeat this until the list is empty and return dummy’s next node.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">mergeKLists</span><span class="params">(ListNode[] lists)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (lists.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    PriorityQueue&lt;ListNode&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(lists.length, (n1, n2) -&gt; n1.val - n2.val);</span><br><span class="line">    <span class="keyword">for</span> (ListNode ln: lists)</span><br><span class="line">        <span class="keyword">if</span> (ln != <span class="literal">null</span>)</span><br><span class="line">            pq.add(ln);</span><br><span class="line">    <span class="keyword">if</span> (pq.isEmpty())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">ret</span> <span class="operator">=</span> node;</span><br><span class="line">    <span class="keyword">while</span> (!pq.isEmpty()) &#123;</span><br><span class="line">        node.next = pq.poll();</span><br><span class="line">        node = node.next;</span><br><span class="line">        <span class="keyword">if</span> (node.next != <span class="literal">null</span>)</span><br><span class="line">            pq.add(node.next);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="https://samirpaul.in">Samir Paul</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://samirpaul.in/posts/leetcode-solutions-cheatsheet/">https://samirpaul.in/posts/leetcode-solutions-cheatsheet/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/LeetCode/">LeetCode</a></div><div class="post_share"><div class="social-share" data-image="/assets/img/leetcode-img-blogpost-leetcode-solutions-cheetsheet-md.webp" data-sites="facebook,twitter,linkedin"></div><link rel="stylesheet" href="/pluginsSrc/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="/pluginsSrc/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/complete-computer-science-study-plan-to-become-a-software-engineer/" title="Complete Computer Science Study Plan to Become a Software Engineer"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/img/complete-computer-science-study-plan-to-become-a-software-engineer-images.webp" onerror="onerror=null;src='/assets/img/404.webp'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">Complete Computer Science Study Plan to Become a Software Engineer</div></div></a></div><div class="next-post pull-right"><a href="/posts/system-design-course/" title="System Design Course"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/img/Getting-Started-with-System-Design-samirpaulb-assets.webp" onerror="onerror=null;src='/assets/img/404.webp'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">System Design Course</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/posts/0003-longest-substring-without-repeating-characters/" title="0003 longest substring without repeating characters"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/img/leetcode-cover-img.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-06</div><div class="title">0003 longest substring without repeating characters</div></div></a></div><div><a href="/posts/0004-median-of-two-sorted-arrays/" title="0004 median of two sorted arrays"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/img/leetcode-cover-img.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-06</div><div class="title">0004 median of two sorted arrays</div></div></a></div><div><a href="/posts/0002-add-two-numbers/" title="0002 add two numbers"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/img/leetcode-cover-img.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-06</div><div class="title">0002 add two numbers</div></div></a></div><div><a href="/posts/0005-longest-palindromic-substring/" title="0005 longest palindromic substring"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/img/leetcode-cover-img.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-06</div><div class="title">0005 longest palindromic substring</div></div></a></div><div><a href="/posts/0006-zigzag-conversion/" title="0006 zigzag conversion"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/img/leetcode-cover-img.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-06</div><div class="title">0006 zigzag conversion</div></div></a></div><div><a href="/posts/0010-regular-expression-matching/" title="0010 regular expression matching"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/img/leetcode-cover-img.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-06</div><div class="title">0010 regular expression matching</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> Comment</span></div></div><div class="comment-wrap"><div><div id="disqus_thread"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/img/avatar.webp" onerror="this.onerror=null;this.src='/assets/img/404.webp'" alt="avatar"/></div><div class="author-info__name">Samir Paul</div><div class="author-info__description">Software Engineer</div></div><div class="card-info-data site-data is-center"><a href="/posts/"><div class="headline">Articles</div><div class="length-num">1314</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">74</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">9</div></a></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://www.linkedin.com/in/SamirPaul" target="_blank" title="LinkedIn"><i class="fab fa-linkedin" style="color: #4a7dbe;"></i></a><a class="social-icon" href="https://github.com/SamirPaul1" target="_blank" title="Github"><i class="fab fa-github" style="color: #4a7dbe;"></i></a><a class="social-icon" href="https://instagram.com/SamirPaulb" target="_blank" title="Instagram"><i class="fab fa-instagram" style="color: #4a7dbe;"></i></a><a class="social-icon" href="https://www.facebook.com/SamirPaulb" target="_blank" title="Facebook"><i class="fab fa-facebook" style="color: #4a7dbe;"></i></a><a class="social-icon" href="https://twitter.com/SamirPaulb" target="_blank" title="Twitter"><i class="fab fa-twitter" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">Welcome to my technical blog!</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Quick-Access-Links"><span class="toc-number">1.</span> <span class="toc-text">Quick Access Links</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#LeetCode"><span class="toc-number">1.1.</span> <span class="toc-text">LeetCode</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-Two-Sum"><span class="toc-number"></span> <span class="toc-text">1-Two Sum</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Brute-Force"><span class="toc-number">1.</span> <span class="toc-text">Brute Force</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#One-Pass-Hash-Table"><span class="toc-number">2.</span> <span class="toc-text">One Pass Hash Table</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-Add-Two-Numbers"><span class="toc-number"></span> <span class="toc-text">2-Add Two Numbers</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Elementary-Math-Solution"><span class="toc-number">1.</span> <span class="toc-text">Elementary Math Solution</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-Substring-No-Repeat"><span class="toc-number"></span> <span class="toc-text">3-Substring No Repeat</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Brute-Force-1"><span class="toc-number">1.</span> <span class="toc-text">Brute Force</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Sliding-Window"><span class="toc-number">2.</span> <span class="toc-text">Sliding Window</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Sliding-Window-Optimized"><span class="toc-number">3.</span> <span class="toc-text">Sliding Window Optimized</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-Median-of-Two-Sorted-Arrays"><span class="toc-number"></span> <span class="toc-text">4-Median of Two Sorted Arrays</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Recursive-Approach"><span class="toc-number">1.</span> <span class="toc-text">Recursive Approach</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-Longest-Palindromic-Substring"><span class="toc-number"></span> <span class="toc-text">5-Longest Palindromic Substring</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Longest-Common-Substring"><span class="toc-number">1.</span> <span class="toc-text">Longest Common Substring</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Brute-Force-2"><span class="toc-number">2.</span> <span class="toc-text">Brute Force</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Dynamic-Programming"><span class="toc-number">3.</span> <span class="toc-text">Dynamic Programming</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Expand-Around-Center"><span class="toc-number">4.</span> <span class="toc-text">Expand Around Center</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Manacher%E2%80%99s-Algorithm"><span class="toc-number">5.</span> <span class="toc-text">Manacher’s Algorithm</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-ZigZag-Conversion"><span class="toc-number"></span> <span class="toc-text">6-ZigZag Conversion</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Sort-by-Row"><span class="toc-number">1.</span> <span class="toc-text">Sort by Row</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Visit-by-Row"><span class="toc-number">2.</span> <span class="toc-text">Visit by Row</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-Reverse-Integer"><span class="toc-number"></span> <span class="toc-text">7-Reverse Integer</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Pop-and-Push-Digits-and-Check-Before-Overflow"><span class="toc-number">1.</span> <span class="toc-text">Pop and Push Digits and Check Before Overflow</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-String-to-Integer-atoi"><span class="toc-number"></span> <span class="toc-text">8-String to Integer (atoi)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ASCII-Conversion"><span class="toc-number">1.</span> <span class="toc-text">ASCII Conversion</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-Palindrome-Number"><span class="toc-number"></span> <span class="toc-text">9-Palindrome Number</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Revert-Half-of-the-Number"><span class="toc-number">1.</span> <span class="toc-text">Revert Half of the Number</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-Regular-Expression-Matching"><span class="toc-number"></span> <span class="toc-text">10-Regular Expression Matching</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Recursion"><span class="toc-number">1.</span> <span class="toc-text">Recursion</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Dynamic-Programming-1"><span class="toc-number">2.</span> <span class="toc-text">Dynamic Programming</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Non-Recursive"><span class="toc-number">3.</span> <span class="toc-text">Non-Recursive</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11-Container-with-the-Most-Water"><span class="toc-number"></span> <span class="toc-text">11-Container with the Most Water</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Brute-Force-3"><span class="toc-number">1.</span> <span class="toc-text">Brute Force</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Two-Pointer-Approach"><span class="toc-number">2.</span> <span class="toc-text">Two Pointer Approach</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#12-Integer-To-Roman"><span class="toc-number"></span> <span class="toc-text">12-Integer To Roman</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#String-Array"><span class="toc-number">1.</span> <span class="toc-text">String Array</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#13-Roman-to-Integer"><span class="toc-number"></span> <span class="toc-text">13-Roman to Integer</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Character-Array"><span class="toc-number">1.</span> <span class="toc-text">Character Array</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#14-Longest-Common-Prefix"><span class="toc-number"></span> <span class="toc-text">14-Longest Common Prefix</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Horizontal-Scanning"><span class="toc-number">1.</span> <span class="toc-text">Horizontal Scanning</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vertical-Scanning"><span class="toc-number">2.</span> <span class="toc-text">Vertical Scanning</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Divide-and-Conquer"><span class="toc-number">3.</span> <span class="toc-text">Divide and Conquer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Binary-Search"><span class="toc-number">4.</span> <span class="toc-text">Binary Search</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Further-Thoughts"><span class="toc-number">5.</span> <span class="toc-text">Further Thoughts</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#15-3Sum"><span class="toc-number"></span> <span class="toc-text">15-3Sum</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Sorted-Array"><span class="toc-number">1.</span> <span class="toc-text">Sorted Array</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#16-3Sum-Closest"><span class="toc-number"></span> <span class="toc-text">16-3Sum Closest</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Pointers"><span class="toc-number">1.</span> <span class="toc-text">3 Pointers</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#17-Letter-Combinations-of-a-Phone-Number"><span class="toc-number"></span> <span class="toc-text">17-Letter Combinations of a Phone Number</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Backtracking"><span class="toc-number">1.</span> <span class="toc-text">Backtracking</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#First-In-First-Out-FIFO-Queue"><span class="toc-number">2.</span> <span class="toc-text">First In First Out (FIFO) Queue</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#18-4Sum"><span class="toc-number"></span> <span class="toc-text">18-4Sum</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Sorted-Array-1"><span class="toc-number">1.</span> <span class="toc-text">Sorted Array</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#19-Remove-Nth-Node-From-End-of-List"><span class="toc-number"></span> <span class="toc-text">19-Remove Nth Node From End of List</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Two-Pass-Algorithm"><span class="toc-number">1.</span> <span class="toc-text">Two Pass Algorithm</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#One-Pass-Algorithm"><span class="toc-number">2.</span> <span class="toc-text">One Pass Algorithm</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#20-Valid-Parentheses"><span class="toc-number"></span> <span class="toc-text">20-Valid Parentheses</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Counting-method"><span class="toc-number">1.</span> <span class="toc-text">Counting method</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Stacks"><span class="toc-number">2.</span> <span class="toc-text">Stacks</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#21-Merge-Two-Sorted-Lists"><span class="toc-number"></span> <span class="toc-text">21-Merge Two Sorted Lists</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Recursive"><span class="toc-number">1.</span> <span class="toc-text">Recursive</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Non-Recursive-1"><span class="toc-number">2.</span> <span class="toc-text">Non-Recursive</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#22-Generate-Parentheses"><span class="toc-number"></span> <span class="toc-text">22-Generate Parentheses</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Brute-Force-4"><span class="toc-number">1.</span> <span class="toc-text">Brute Force</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Backtracking-1"><span class="toc-number">2.</span> <span class="toc-text">Backtracking</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Closure-Number"><span class="toc-number">3.</span> <span class="toc-text">Closure Number</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#23-Merge-k-Sorted-Lists"><span class="toc-number"></span> <span class="toc-text">23-Merge k Sorted Lists</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Brute-Force-5"><span class="toc-number">1.</span> <span class="toc-text">Brute Force</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#146-LRU-Cache"><span class="toc-number"></span> <span class="toc-text">146-LRU Cache</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Index"><span class="toc-number"></span> <span class="toc-text">Index</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Lowest-Common-Ancestor"><span class="toc-number">0.1.</span> <span class="toc-text">Lowest Common Ancestor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Count-And-Say"><span class="toc-number">0.2.</span> <span class="toc-text">Count And Say</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Maximum-SubArray"><span class="toc-number">0.3.</span> <span class="toc-text">Maximum SubArray</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Plus-One"><span class="toc-number">0.4.</span> <span class="toc-text">Plus One</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Sqrt-of-X"><span class="toc-number">0.5.</span> <span class="toc-text">Sqrt of X</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Climbing-Stairs"><span class="toc-number">0.6.</span> <span class="toc-text">Climbing Stairs</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Remove-Duplicates-from-sorted-list"><span class="toc-number">0.7.</span> <span class="toc-text">Remove Duplicates from sorted list</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Same-Tree"><span class="toc-number">0.8.</span> <span class="toc-text">Same Tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Symmetric-Tree"><span class="toc-number">0.9.</span> <span class="toc-text">Symmetric Tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Max-Depth-of-Binary-Tree"><span class="toc-number">0.10.</span> <span class="toc-text">Max Depth of Binary Tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Convert-Sorted-Array-to-Binary-Search-Tree"><span class="toc-number">0.11.</span> <span class="toc-text">Convert Sorted Array to Binary Search Tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Balanced-Binary-Tree"><span class="toc-number">0.12.</span> <span class="toc-text">Balanced Binary Tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Minimum-Depth-of-Binary-Tree"><span class="toc-number">0.13.</span> <span class="toc-text">Minimum Depth of Binary Tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Path-Sum"><span class="toc-number">0.14.</span> <span class="toc-text">Path Sum</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Pascal%E2%80%99s-Triangle"><span class="toc-number">0.15.</span> <span class="toc-text">Pascal’s Triangle</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Valid-Palindrome"><span class="toc-number">0.16.</span> <span class="toc-text">Valid Palindrome</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Pascal%E2%80%99s-Triangle-II"><span class="toc-number">0.17.</span> <span class="toc-text">Pascal’s Triangle II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Best-Time-to-Buy-and-Sell-Stock"><span class="toc-number">0.18.</span> <span class="toc-text">Best Time to Buy and Sell Stock</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Best-Time-to-Buy-and-Sell-Stock-II"><span class="toc-number">0.19.</span> <span class="toc-text">Best Time to Buy and Sell Stock II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Single-Number"><span class="toc-number">0.20.</span> <span class="toc-text">Single Number</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linked-List-Cycle"><span class="toc-number">0.21.</span> <span class="toc-text">Linked List Cycle</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Min-Stack"><span class="toc-number">0.22.</span> <span class="toc-text">Min Stack</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Intersection-of-Two-Linked-Lists"><span class="toc-number">0.23.</span> <span class="toc-text">Intersection of Two Linked Lists</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Two-Sum-II-Input-array-is-sorted"><span class="toc-number">0.24.</span> <span class="toc-text">Two Sum II - Input array is sorted</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Excel-Sheet-Column-Title"><span class="toc-number">0.25.</span> <span class="toc-text">Excel Sheet Column Title</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Majority-Element"><span class="toc-number">0.26.</span> <span class="toc-text">Majority Element</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Excel-Sheet-Column-Number"><span class="toc-number">0.27.</span> <span class="toc-text">Excel Sheet Column Number</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Factorial-Trailing-Zeroes"><span class="toc-number">0.28.</span> <span class="toc-text">Factorial Trailing Zeroes</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Combine-Two-Tables"><span class="toc-number">0.29.</span> <span class="toc-text">Combine Two Tables</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Second-Highest-Salary"><span class="toc-number">0.30.</span> <span class="toc-text">Second Highest Salary</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Employees-Earning-More-Than-Their-Managers"><span class="toc-number">0.31.</span> <span class="toc-text">Employees Earning More Than Their Managers</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Duplicate-Emails"><span class="toc-number">0.32.</span> <span class="toc-text">Duplicate Emails</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Customers-Who-Never-Order"><span class="toc-number">0.33.</span> <span class="toc-text">Customers Who Never Order</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Rotate-Array"><span class="toc-number">0.34.</span> <span class="toc-text">Rotate Array</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Delete-Duplicate-Emails"><span class="toc-number">0.35.</span> <span class="toc-text">Delete Duplicate Emails</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Rising-Temperature"><span class="toc-number">0.36.</span> <span class="toc-text">Rising Temperature</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#X-of-a-Kind-in-a-Deck-of-Cards"><span class="toc-number">0.37.</span> <span class="toc-text">X of a Kind in a Deck of Cards</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Reverse-Integer"><span class="toc-number">0.38.</span> <span class="toc-text">Reverse Integer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Add-Two-Numbers"><span class="toc-number">0.39.</span> <span class="toc-text">Add Two Numbers</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Longest-Substring-Without-Repeating-Characters"><span class="toc-number">0.40.</span> <span class="toc-text">Longest Substring Without Repeating Characters</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#House-Robber"><span class="toc-number">0.41.</span> <span class="toc-text">House Robber</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Happy-Number"><span class="toc-number">0.42.</span> <span class="toc-text">Happy Number</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Remove-Linked-List-Elements"><span class="toc-number">0.43.</span> <span class="toc-text">Remove Linked List Elements</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Count-Primes"><span class="toc-number">0.44.</span> <span class="toc-text">Count Primes</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Isomorphic-Strings"><span class="toc-number">0.45.</span> <span class="toc-text">Isomorphic Strings</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Reverse-LinkedList"><span class="toc-number">0.46.</span> <span class="toc-text">Reverse LinkedList</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Contains-Duplicate"><span class="toc-number">0.47.</span> <span class="toc-text">Contains Duplicate</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Contains-Duplicate-II"><span class="toc-number">0.48.</span> <span class="toc-text">Contains Duplicate II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Implement-Stack-Using-Queues"><span class="toc-number">0.49.</span> <span class="toc-text">Implement Stack Using Queues</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Invert-Binary-Tree"><span class="toc-number">0.50.</span> <span class="toc-text">Invert Binary Tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Fibonacci-Number"><span class="toc-number">0.51.</span> <span class="toc-text">Fibonacci Number</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#kth-Largest-Element"><span class="toc-number">0.52.</span> <span class="toc-text">kth Largest Element</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Power-Of-Two"><span class="toc-number">0.53.</span> <span class="toc-text">Power Of Two</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Valid-Sudoku"><span class="toc-number">0.54.</span> <span class="toc-text">Valid Sudoku</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Implement-Queue-Using-Stack"><span class="toc-number">0.55.</span> <span class="toc-text">Implement Queue Using Stack</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Palindrome-LinkedList"><span class="toc-number">0.56.</span> <span class="toc-text">Palindrome LinkedList</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Delete-Node-in-a-Linked-List"><span class="toc-number">0.57.</span> <span class="toc-text">Delete Node in a Linked List</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Is-Anagram"><span class="toc-number">0.58.</span> <span class="toc-text">Is Anagram</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Binary-Tree-Paths"><span class="toc-number">0.59.</span> <span class="toc-text">Binary Tree Paths</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Add-Digits"><span class="toc-number">0.60.</span> <span class="toc-text">Add Digits</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Largest-Perimeter-Triangle"><span class="toc-number">0.61.</span> <span class="toc-text">Largest Perimeter Triangle</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Ugly-Number"><span class="toc-number">0.62.</span> <span class="toc-text">Ugly Number</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Missing-Number"><span class="toc-number">0.63.</span> <span class="toc-text">Missing Number</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Is-Bad-Version"><span class="toc-number">0.64.</span> <span class="toc-text">Is Bad Version</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Move-Zeroes"><span class="toc-number">0.65.</span> <span class="toc-text">Move Zeroes</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Word-Pattern"><span class="toc-number">0.66.</span> <span class="toc-text">Word Pattern</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Can-Win-Nim"><span class="toc-number">0.67.</span> <span class="toc-text">Can Win Nim</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Power-Of-Three"><span class="toc-number">0.68.</span> <span class="toc-text">Power Of Three</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Power-of-Four"><span class="toc-number">0.69.</span> <span class="toc-text">Power of Four</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Reverse-String"><span class="toc-number">0.70.</span> <span class="toc-text">Reverse String</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Implement-strStr"><span class="toc-number">0.71.</span> <span class="toc-text">Implement strStr()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Reverse-Vowels-of-a-String"><span class="toc-number">0.72.</span> <span class="toc-text">Reverse Vowels of a String</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Intersection-of-two-arrays"><span class="toc-number">0.73.</span> <span class="toc-text">Intersection of two arrays</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Is-Perfect-Square"><span class="toc-number">0.74.</span> <span class="toc-text">Is Perfect Square</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Sum-of-Two-Integers"><span class="toc-number">0.75.</span> <span class="toc-text">Sum of Two Integers</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Guess-Number-Higher-or-Lower"><span class="toc-number">0.76.</span> <span class="toc-text">Guess Number Higher or Lower</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Ransom-Note"><span class="toc-number">0.77.</span> <span class="toc-text">Ransom Note</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#First-Unique-Character-in-a-String"><span class="toc-number">0.78.</span> <span class="toc-text">First Unique Character in a String</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Find-the-Difference"><span class="toc-number">0.79.</span> <span class="toc-text">Find the Difference</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Nth-Digit"><span class="toc-number">0.80.</span> <span class="toc-text">Nth Digit</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Sum-of-Left-Leaves"><span class="toc-number">0.81.</span> <span class="toc-text">Sum of Left Leaves</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Longest-Palindrome"><span class="toc-number">0.82.</span> <span class="toc-text">Longest Palindrome</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Fizz-Buzz"><span class="toc-number">0.83.</span> <span class="toc-text">Fizz Buzz</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Third-maximum-Number"><span class="toc-number">0.84.</span> <span class="toc-text">Third maximum Number</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Add-Two-Strings"><span class="toc-number">0.85.</span> <span class="toc-text">Add Two Strings</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Construct-Quad-Tree"><span class="toc-number">0.86.</span> <span class="toc-text">Construct Quad Tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#N-ary-Tree-Level-Order-Traversal"><span class="toc-number">0.87.</span> <span class="toc-text">N-ary Tree Level Order Traversal</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Number-of-Segments-in-a-String"><span class="toc-number">0.88.</span> <span class="toc-text">Number of Segments in a String</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Binary-Tree-Level-Order-Traversal"><span class="toc-number">0.89.</span> <span class="toc-text">Binary Tree Level Order Traversal</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Path-Sum-III"><span class="toc-number">0.90.</span> <span class="toc-text">Path Sum III</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Find-All-Anagrams-in-a-String"><span class="toc-number">0.91.</span> <span class="toc-text">Find All Anagrams in a String</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Arranging-Coins"><span class="toc-number">0.92.</span> <span class="toc-text">Arranging Coins</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hamming-Distance"><span class="toc-number">0.93.</span> <span class="toc-text">Hamming Distance</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String-Compression"><span class="toc-number">0.94.</span> <span class="toc-text">String Compression</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Number-of-Boomerangs"><span class="toc-number">0.95.</span> <span class="toc-text">Number of Boomerangs</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Find-All-Numbers-Disappeared-in-an-Array"><span class="toc-number">0.96.</span> <span class="toc-text">Find All Numbers Disappeared in an Array</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Assign-Cookies"><span class="toc-number">0.97.</span> <span class="toc-text">Assign Cookies</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Poor-Pigs"><span class="toc-number">0.98.</span> <span class="toc-text">Poor Pigs</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Find-Pivot-Index"><span class="toc-number">0.99.</span> <span class="toc-text">Find Pivot Index</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Squares-of-a-Sorted-Array"><span class="toc-number">0.100.</span> <span class="toc-text">Squares of a Sorted Array</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Repeated-Substring-Pattern"><span class="toc-number">0.101.</span> <span class="toc-text">Repeated Substring Pattern</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Island-Perimeter"><span class="toc-number">0.102.</span> <span class="toc-text">Island Perimeter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Number-Complement"><span class="toc-number">0.103.</span> <span class="toc-text">Number Complement</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Binary-Watch"><span class="toc-number">0.104.</span> <span class="toc-text">Binary Watch</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Minimum-Moves-to-Equal-Array-Elements"><span class="toc-number">0.105.</span> <span class="toc-text">Minimum Moves to Equal Array Elements</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#License-Key-Formatting"><span class="toc-number">0.106.</span> <span class="toc-text">License Key Formatting</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Max-Consecutive-Ones"><span class="toc-number">0.107.</span> <span class="toc-text">Max Consecutive Ones</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Permutations"><span class="toc-number">0.108.</span> <span class="toc-text">Permutations</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Construct-the-Rectangle"><span class="toc-number">0.109.</span> <span class="toc-text">Construct the Rectangle</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Merge-Intervals"><span class="toc-number">0.110.</span> <span class="toc-text">Merge Intervals</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Merged-sorted-lists"><span class="toc-number">0.111.</span> <span class="toc-text">Merged sorted lists</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Next-Greater-Element-I"><span class="toc-number">0.112.</span> <span class="toc-text">Next Greater Element I</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String-Without-AAA-or-BBB"><span class="toc-number">0.113.</span> <span class="toc-text">String Without AAA or BBB</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Keyboard-Row"><span class="toc-number">0.114.</span> <span class="toc-text">Keyboard Row</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Find-Mode-in-Binary-Search-Tree"><span class="toc-number">0.115.</span> <span class="toc-text">Find Mode in Binary Search Tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Base-7"><span class="toc-number">0.116.</span> <span class="toc-text">Base 7</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Relative-Ranks"><span class="toc-number">0.117.</span> <span class="toc-text">Relative Ranks</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Perfect-Number"><span class="toc-number">0.118.</span> <span class="toc-text">Perfect Number</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Detect-Capital"><span class="toc-number">0.119.</span> <span class="toc-text">Detect Capital</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Longest-Uncommon-Subsequence-I"><span class="toc-number">0.120.</span> <span class="toc-text">Longest Uncommon Subsequence I</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Course-Schedule-II"><span class="toc-number">0.121.</span> <span class="toc-text">Course Schedule II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Letter-Combinations-of-a-Phone-Number"><span class="toc-number">0.122.</span> <span class="toc-text">Letter Combinations of a Phone Number</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Sudoku-Solver"><span class="toc-number">0.123.</span> <span class="toc-text">Sudoku Solver</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Bulls-and-Cows"><span class="toc-number">0.124.</span> <span class="toc-text">Bulls and Cows</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#N-Queens-I"><span class="toc-number">0.125.</span> <span class="toc-text">N-Queens I</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#K-diff-pairs-in-an-Array"><span class="toc-number">0.126.</span> <span class="toc-text">K-diff pairs in an Array</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Is-Subsequence"><span class="toc-number">0.127.</span> <span class="toc-text">Is Subsequence</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Minimum-Absolute-Difference-in-BST"><span class="toc-number">0.128.</span> <span class="toc-text">Minimum Absolute Difference in BST</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BST-Tree-to-Greater-Tree"><span class="toc-number">0.129.</span> <span class="toc-text">BST Tree to Greater Tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Student-Attendance-Record-I"><span class="toc-number">0.130.</span> <span class="toc-text">Student Attendance Record I</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Reverse-Words-in-String-III"><span class="toc-number">0.131.</span> <span class="toc-text">Reverse Words in String III</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Quad-Tree-Intersection"><span class="toc-number">0.132.</span> <span class="toc-text">Quad Tree Intersection</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Long-Pressed-Name"><span class="toc-number">0.133.</span> <span class="toc-text">Long Pressed Name</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Binary-Tree-Zigzag-Level-Order-Traversal"><span class="toc-number">0.134.</span> <span class="toc-text">Binary Tree Zigzag Level Order Traversal</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Array-Partition-I"><span class="toc-number">0.135.</span> <span class="toc-text">Array Partition I</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Reshape-the-Matrix"><span class="toc-number">0.136.</span> <span class="toc-text">Reshape the Matrix</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Swap-Nodes-in-Pairs"><span class="toc-number">0.137.</span> <span class="toc-text">Swap Nodes in Pairs</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Generate-Parentheses"><span class="toc-number">0.138.</span> <span class="toc-text">Generate Parentheses</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Maximum-subproduct-subarray"><span class="toc-number">0.139.</span> <span class="toc-text">Maximum subproduct subarray</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Binary-Tree-Right-Side-View"><span class="toc-number">0.140.</span> <span class="toc-text">Binary Tree Right Side View</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Find-Minimum-in-Rotated-Sorted-Array"><span class="toc-number">0.141.</span> <span class="toc-text">Find Minimum in Rotated Sorted Array</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Binary-Search-Tree-Iterator"><span class="toc-number">0.142.</span> <span class="toc-text">Binary Search Tree Iterator</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Find-Peak-Element"><span class="toc-number">0.143.</span> <span class="toc-text">Find Peak Element</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Next-Permutation"><span class="toc-number">0.144.</span> <span class="toc-text">Next Permutation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Search-in-Rotated-Sorted-Array"><span class="toc-number">0.145.</span> <span class="toc-text">Search in Rotated Sorted Array</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Transpose-Matrix"><span class="toc-number">0.146.</span> <span class="toc-text">Transpose Matrix</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Merge-K-Sorted-Lists"><span class="toc-number">0.147.</span> <span class="toc-text">Merge K Sorted Lists</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/data-structures-and-algorithms-for-coding-interview/" title="Data Structures and Algorithms for Coding Interview"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/img/dsalgo.webp" onerror="this.onerror=null;this.src='/assets/img/404.webp'" alt="Data Structures and Algorithms for Coding Interview"/></a><div class="content"><a class="title" href="/posts/data-structures-and-algorithms-for-coding-interview/" title="Data Structures and Algorithms for Coding Interview">Data Structures and Algorithms for Coding Interview</a><time datetime="2023-08-15T04:25:52.000Z" title="Created 2023-08-15 09:55:52">2023-08-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/system-design-course/" title="System Design Course"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/img/Getting-Started-with-System-Design-samirpaulb-assets.webp" onerror="this.onerror=null;this.src='/assets/img/404.webp'" alt="System Design Course"/></a><div class="content"><a class="title" href="/posts/system-design-course/" title="System Design Course">System Design Course</a><time datetime="2023-08-15T04:24:59.000Z" title="Created 2023-08-15 09:54:59">2023-08-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/leetcode-solutions-cheatsheet/" title="Leetcode Solutions Cheatsheet"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/img/leetcode-img-blogpost-leetcode-solutions-cheetsheet-md.webp" onerror="this.onerror=null;this.src='/assets/img/404.webp'" alt="Leetcode Solutions Cheatsheet"/></a><div class="content"><a class="title" href="/posts/leetcode-solutions-cheatsheet/" title="Leetcode Solutions Cheatsheet">Leetcode Solutions Cheatsheet</a><time datetime="2023-08-15T04:24:55.000Z" title="Created 2023-08-15 09:54:55">2023-08-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/complete-computer-science-study-plan-to-become-a-software-engineer/" title="Complete Computer Science Study Plan to Become a Software Engineer"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/img/complete-computer-science-study-plan-to-become-a-software-engineer-images.webp" onerror="this.onerror=null;this.src='/assets/img/404.webp'" alt="Complete Computer Science Study Plan to Become a Software Engineer"/></a><div class="content"><a class="title" href="/posts/complete-computer-science-study-plan-to-become-a-software-engineer/" title="Complete Computer Science Study Plan to Become a Software Engineer">Complete Computer Science Study Plan to Become a Software Engineer</a><time datetime="2023-08-15T04:24:52.000Z" title="Created 2023-08-15 09:54:52">2023-08-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/computer-networks-notes/" title="Computer Networks Notes"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/img/computer-networks-preview-blog-banner.webp" onerror="this.onerror=null;this.src='/assets/img/404.webp'" alt="Computer Networks Notes"/></a><div class="content"><a class="title" href="/posts/computer-networks-notes/" title="Computer Networks Notes">Computer Networks Notes</a><time datetime="2023-08-15T04:24:52.000Z" title="Created 2023-08-15 09:54:52">2023-08-15</time></div></div></div></div></div></div></main><footer id="footer" style="background: $#ffffff"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Samir Paul</div><div class="footer_custom_text"><a href="/sitemap.xml"><i class="fa fa-sitemap"></i> Sitemap</a>&nbsp;&nbsp;<a href="/index.xml"><i class="fa fa-rss"></i> Feed</a>&nbsp;&nbsp;<a target="_blank" rel="noopener" href="https://www.linkedin.com/in/SamirPaul"><i class="fab fa-linkedin"></i> LinkedIn</a>&nbsp;&nbsp;<a target="_blank" rel="noopener" href="https://github.com/SamirPaul1"><i class="fab fa-github"></i> GitHub</a>&nbsp;&nbsp;<a target="_blank" rel="noopener" href="https://twitter.com/SamirPaulb"><i class="fab fa-twitter"></i> Twitter</a>&nbsp;&nbsp;<a target="_blank" rel="noopener" href="https://instagram.com/SamirPaulb"><i class="fab fa-instagram"></i> Instagram</a></p></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="Scroll To Comments"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/pluginsSrc/@fancyapps/ui/dist/fancybox/fancybox.umd.js"></script><script src="/pluginsSrc/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>function loadDisqus () {
  const disqus_config = function () {
    this.page.url = 'https://samirpaul.in/posts/leetcode-solutions-cheatsheet/'
    this.page.identifier = '/posts/leetcode-solutions-cheatsheet/'
    this.page.title = 'Leetcode Solutions Cheatsheet'
  }

  const disqusReset = () => {
    DISQUS.reset({
      reload: true,
      config: disqus_config
    })
  }

  btf.addModeChange('disqus', disqusReset)

  if (window.DISQUS) disqusReset()
  else {
    (function() { 
      var d = document, s = d.createElement('script');
      s.src = 'https://samirpaul.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  }
}

if ('Disqus' === 'Disqus' || !true) {
  if (true) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
  else loadDisqus()
} else {
  function loadOtherComment () {
    loadDisqus()
  }
}
</script></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  Loading the Database</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>